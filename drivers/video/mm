Only in msm: cmc623.h
Only in msm: cmc623_sysfs.c
Only in msm: cmc624.h
Only in msm: cmc624_sysfs.c
Only in msm: ea8868_volt_tbl.h
Only in /home/shade/kernel-msm/drivers/video/msm: ebi2_epson_s1d_qvga.c
Only in /home/shade/kernel-msm/drivers/video/msm: ebi2_host.c
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/ebi2_lcd.c msm/ebi2_lcd.c
--- /home/shade/kernel-msm/drivers/video/msm/ebi2_lcd.c	2012-08-06 13:47:56.746145919 -0700
+++ msm/ebi2_lcd.c	2012-08-10 12:10:27.370062703 -0700
@@ -56,6 +56,8 @@
 	.probe = ebi2_lcd_probe,
 	.remove = ebi2_lcd_remove,
 	.suspend = NULL,
+	.suspend_late = NULL,
+	.resume_early = NULL,
 	.resume = NULL,
 	.shutdown = NULL,
 	.driver = {
@@ -69,42 +71,17 @@
 static void *ebi2_lcd_cfg1;
 static void __iomem *lcd01_base;
 static void __iomem *lcd02_base;
-static int lcd01_base_phys;
 static int ebi2_lcd_resource_initialized;
 
 static struct platform_device *pdev_list[MSM_FB_MAX_DEV_LIST];
 static int pdev_list_cnt;
-static struct lcdc_platform_data *ebi2_pdata;
-
-static int ebi2_lcd_on(struct platform_device *pdev)
-{
-	int ret;
-
-	if (ebi2_pdata && ebi2_pdata->lcdc_power_save)
-		ebi2_pdata->lcdc_power_save(1);
-
-	ret = panel_next_on(pdev);
-	return ret;
-}
-
-static int ebi2_lcd_off(struct platform_device *pdev)
-{
-	int ret;
-
-	ret = panel_next_off(pdev);
-
-	if (ebi2_pdata && ebi2_pdata->lcdc_power_save)
-		ebi2_pdata->lcdc_power_save(0);
-
-	return ret;
-}
 
 static int ebi2_lcd_probe(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
 	struct platform_device *mdp_dev = NULL;
 	struct msm_fb_panel_data *pdata = NULL;
-	int rc, i, hw_version;
+	int rc, i;
 
 	if (pdev->id == 0) {
 		for (i = 0; i < pdev->num_resources; i++) {
@@ -121,7 +98,6 @@
 				ebi2_lcd_cfg1 = (void *)(ebi2_base + 0x24);
 			} else if (!strncmp(pdev->resource[i].name,
 						"lcd01", 5)) {
-				lcd01_base_phys = pdev->resource[i].start;
 				lcd01_base = ioremap(pdev->resource[i].start,
 						pdev->resource[i].end -
 						pdev->resource[i].start + 1);
@@ -142,9 +118,7 @@
 				}
 			}
 		}
-		ebi2_pdata = pdev->dev.platform_data;
 		ebi2_lcd_resource_initialized = 1;
-
 		return 0;
 	}
 
@@ -184,19 +158,15 @@
 
 	/* data chain */
 	pdata = mdp_dev->dev.platform_data;
-	pdata->on = ebi2_lcd_on;
-	pdata->off = ebi2_lcd_off;
+	pdata->on = panel_next_on;
+	pdata->off = panel_next_off;
 	pdata->next = pdev;
 
 	/* get/set panel specific fb info */
 	mfd->panel_info = pdata->panel_info;
 
-	hw_version = inp32((int)ebi2_base + 8);
-
 	if (mfd->panel_info.bpp == 24)
 		mfd->fb_imgType = MDP_RGB_888;
-	else if (mfd->panel_info.bpp == 18)
-		mfd->fb_imgType = MDP_RGB_888;
 	else
 		mfd->fb_imgType = MDP_RGB_565;
 
@@ -211,12 +181,10 @@
 		 * configure both.
 		 */
 		outp32(ebi2_lcd_cfg0, mfd->panel_info.wait_cycle);
-		if (hw_version < 0x2020) {
-			if (mfd->panel_info.bpp == 18)
-				outp32(ebi2_lcd_cfg1, 0x01000000);
-			else
-				outp32(ebi2_lcd_cfg1, 0x0);
-		}
+		if (mfd->panel_info.bpp == 18)
+			outp32(ebi2_lcd_cfg1, 0x01000000);
+		else
+			outp32(ebi2_lcd_cfg1, 0x0);
 	} else {
 #ifdef DEBUG_EBI2_LCD
 		/*
@@ -233,18 +201,10 @@
 	 */
 	if (mfd->panel_info.pdest == DISPLAY_1) {
 		mfd->cmd_port = lcd01_base;
-		if (hw_version >= 0x2020) {
-			mfd->data_port =
-				(void *)((uint32) mfd->cmd_port + 0x80);
-			mfd->data_port_phys =
-				(void *)(lcd01_base_phys + 0x80);
-		} else {
-			mfd->data_port =
-			    (void *)((uint32) mfd->cmd_port +
-				    EBI2_PRIM_LCD_RS_PIN);
-			mfd->data_port_phys =
-			    (void *)(LCD_PRIM_BASE_PHYS + EBI2_PRIM_LCD_RS_PIN);
-		}
+		mfd->data_port =
+		    (void *)((uint32) mfd->cmd_port + EBI2_PRIM_LCD_RS_PIN);
+		mfd->data_port_phys =
+		    (void *)(LCD_PRIM_BASE_PHYS + EBI2_PRIM_LCD_RS_PIN);
 	} else {
 		mfd->cmd_port = lcd01_base;
 		mfd->data_port =
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/external_common.c msm/external_common.c
--- /home/shade/kernel-msm/drivers/video/msm/external_common.c	2012-08-20 15:40:53.000119039 -0700
+++ msm/external_common.c	2012-08-17 10:16:29.555174046 -0700
@@ -9,13 +9,18 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
  */
 
 #include <linux/types.h>
 #include <linux/bitops.h>
 #include <linux/mutex.h>
 
-/* #define DEBUG */
+#define DEBUG
 #define DEV_DBG_PREFIX "EXT_COMMON: "
 
 #include "msm_fb.h"
@@ -29,7 +34,9 @@
 EXPORT_SYMBOL(external_common_state);
 DEFINE_MUTEX(external_common_state_hpd_mutex);
 EXPORT_SYMBOL(external_common_state_hpd_mutex);
-
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+int get_best_display_Mode(void);
+#endif
 
 static int atoi(const char *name)
 {
@@ -101,7 +108,7 @@
 	 * only when MHL support is included.
 	 */
 }
-#endif
+#endif /* DEBUG_EDID */
 
 const char *video_format_2string(uint32 format)
 {
@@ -257,8 +264,8 @@
 struct hdmi_disp_mode_timing_type
 	hdmi_mhl_supported_video_mode_lut[HDMI_VFRMT_MAX] = {
 	HDMI_SETTINGS_640x480p60_4_3,
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x480p60_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x480p60_16_9),
+	HDMI_SETTINGS_720x480p60_4_3,
+	HDMI_SETTINGS_720x480p60_16_9,
 	HDMI_SETTINGS_1280x720p60_16_9,
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080i60_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480i60_4_3),
@@ -272,9 +279,9 @@
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480p60_4_3),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x480p60_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080p60_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x576p50_4_3),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_720x576p50_16_9),
-	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1280x720p50_16_9),
+	HDMI_SETTINGS_720x576p50_4_3,
+	HDMI_SETTINGS_720x576p50_16_9,
+	HDMI_SETTINGS_1280x720p50_16_9,
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1920x1080i50_16_9),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576i50_4_3),
 	VFRMT_NOT_SUPPORTED(HDMI_VFRMT_1440x576i50_16_9),
@@ -341,7 +348,11 @@
 		ret += snprintf(buf+ret, PAGE_SIZE-ret, "%d",
 			external_common_state->video_resolution+1);
 
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+	DEV_DBG("%s: '%s' : %s\n", __func__, buf, video_format_2string(get_best_display_Mode()));
+#else
 	DEV_DBG("%s: '%s'\n", __func__, buf);
+#endif
 	ret += snprintf(buf+ret, PAGE_SIZE-ret, "\n");
 	return ret;
 }
@@ -356,6 +367,16 @@
 	return ret;
 }
 
+static ssize_t hdmi_common_dvi_enable(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = snprintf(buf, PAGE_SIZE, "%d\n",
+		!external_common_state->hdmi_sink);
+	DEV_DBG("%s: '%d'\n", __func__,
+		!external_common_state->hdmi_sink);
+	return ret;
+}
+
 static ssize_t hdmi_common_rda_hpd(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
@@ -635,9 +656,9 @@
 	mutex_unlock(&external_common_state_hpd_mutex);
 
 	video_mode = atoi(buf)-1;
-	DEV_INFO("%s: video_mode is %d\n", __func__, video_mode);
 	kobject_uevent(external_common_state->uevent_kobj, KOBJ_OFFLINE);
 #ifdef CONFIG_FB_MSM_HDMI_COMMON
+	DEV_INFO("%s: [jgk] video_mode=%d\n", __func__, video_mode);
 	disp_mode = hdmi_common_get_supported_mode(video_mode);
 	if (!disp_mode) {
 		DEV_INFO("%s: FAILED: mode not supported (%d)\n",
@@ -704,6 +725,7 @@
 static DEVICE_ATTR(hdcp, S_IRUGO, hdmi_common_rda_hdcp, NULL);
 static DEVICE_ATTR(3d_present, S_IRUGO, hdmi_common_rda_3d_present, NULL);
 static DEVICE_ATTR(hdcp_present, S_IRUGO, hdmi_common_rda_hdcp_present, NULL);
+static DEVICE_ATTR(isdvi, S_IRUGO, hdmi_common_dvi_enable, NULL);
 #endif
 #ifdef CONFIG_FB_MSM_HDMI_3D
 static DEVICE_ATTR(format_3d, S_IRUGO | S_IWUGO, hdmi_3d_rda_format_3d,
@@ -722,6 +744,7 @@
 	&dev_attr_hpd.attr,
 	&dev_attr_3d_present.attr,
 	&dev_attr_hdcp_present.attr,
+	&dev_attr_isdvi.attr,
 #endif
 #ifdef CONFIG_FB_MSM_HDMI_3D
 	&dev_attr_format_3d.attr,
@@ -957,7 +980,7 @@
 
 	/*edid buffer 1, byte 2 being 4 means no non-DTD/Data block collection
 	  present.
-	  edid buffer 1, byte 2 being 0 menas no non-DTD/DATA block collection
+	  edid buffer 1, byte 2 being 0 means no non-DTD/DATA block collection
 	  present and no DTD data present.*/
 	if ((in_buf[2] == 0) || (in_buf[2] == 4)) {
 		DEV_WARN("EDID: no DTD or non-DTD data present\n");
@@ -1183,6 +1206,13 @@
 		DEV_INFO("%s: *no mode* found\n", __func__);
 }
 
+#if defined(CONFIG_FB_MSM_HDMI_MHL)	//defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+extern bool mhl_hpd_state;
+bool mhl_is_connected( void ) {
+	return mhl_hpd_state;
+}
+#endif
+
 static void add_supported_video_format(
 	struct hdmi_disp_mode_list_type *disp_mode_list,
 	uint32 video_format)
@@ -1214,6 +1244,24 @@
 	}
 }
 
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+static int hdmi_edid_check_resolution_supported(int resolution)
+{
+	int	found = 0;
+	int i;
+	if (external_common_state->disp_mode_list.num_of_elements) {
+		uint32 *video_mode = external_common_state->disp_mode_list.disp_mode_list;
+		for (i = 0; i < external_common_state->disp_mode_list.num_of_elements; i++){
+			if (video_mode[i] == resolution) {
+				found = 1;
+				break;
+			}
+		}
+	}
+	return found;
+}
+#endif
+
 static void hdmi_edid_get_display_mode(const uint8 *data_buf,
 	struct hdmi_disp_mode_list_type *disp_mode_list,
 	uint32 num_og_cea_blocks)
@@ -1307,20 +1355,36 @@
 		}
 	}
 
-	if (!has480p)
+#if 0//defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+{
+	boolean has720p	= FALSE;
+	has720p = hdmi_edid_check_resolution_supported(HDMI_VFRMT_1280x720p60_16_9);
+	if (!has720p && external_common_state->hdmi_sink == false) {
+		/* If DVI monitor is connected and cannot find 720p value then
+		 * set default resolution as 720p
+		 * requested by andykkim on AUG 16, 2011 - jgk.20110817
+		 */
+		add_supported_video_format(disp_mode_list,
+			HDMI_VFRMT_1280x720p60_16_9);
+		DEV_ERR("%s[jgk]: DVI connected!!, forcely set as 720p!!\n",__func__);
+	}
+}
+#endif
+
+	if (!has480p) {
 		/* Need to add default 640 by 480 timings, in case not described
 		 * in the EDID structure.
 		 * All DTV sink devices should support this mode */
-		add_supported_video_format(disp_mode_list,
-			HDMI_VFRMT_640x480p60_4_3);
+	    add_supported_video_format(disp_mode_list,
+		    HDMI_VFRMT_640x480p60_4_3);
+//		DEV_ERR("%s[jgk]: HDMI connected!!, forcely set as 480p!!\n",__func__);
+	}
 }
 
 static int hdmi_common_read_edid_block(int block, uint8 *edid_buf)
 {
 	uint32 ndx, check_sum, print_len;
-#ifdef DEBUG
 	const u8 *b = edid_buf;
-#endif
 	int status = external_common_state->read_edid_block(block, edid_buf);
 	if (status)
 		goto error;
@@ -1407,7 +1471,7 @@
 	switch (num_og_cea_blocks) {
 	case 0: /* No CEA extension */
 		external_common_state->hdmi_sink = false;
-		DEV_DBG("HDMI DVI mode: %s\n",
+		DEV_DBG("HDMI DVI mode(0): %s\n",
 			external_common_state->hdmi_sink ? "no" : "yes");
 		break;
 	case 1: /* Read block 1 */
@@ -1426,6 +1490,11 @@
 				external_common_state->hdmi_sink = TRUE ;
 			else
 				external_common_state->hdmi_sink = FALSE ;
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+			DEV_DBG("HDMI DVI mode(1): %s\n",
+				external_common_state->hdmi_sink ? "no" : "yes");
+#endif
+
 			hdmi_edid_extract_latency_fields(edid_buf+0x80);
 			hdmi_edid_extract_speaker_allocation_data(
 				edid_buf+0x80);
@@ -1492,6 +1561,64 @@
 }
 EXPORT_SYMBOL(hdmi_common_read_edid);
 
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+//Rajucm: Implimentation of Edid order.
+//This funcion re-order given videomode
+static int get_mhl_v1_supported_video_modes(int mode)
+{
+	switch (mode)
+	{
+        case HDMI_VFRMT_1440x480i60_4_3:
+        case HDMI_VFRMT_1440x480i60_16_9:
+            return 1; // 480i
+        case HDMI_VFRMT_1440x576i50_4_3:
+        case HDMI_VFRMT_1440x576i50_16_9:
+            return 2; // 576i
+        case HDMI_VFRMT_640x480p60_4_3:
+            return 3; // 480p x640
+        case HDMI_VFRMT_720x480p60_4_3:
+        case HDMI_VFRMT_720x480p60_16_9:
+            return 4; // 480p x720
+        case HDMI_VFRMT_720x576p50_4_3:
+        case HDMI_VFRMT_720x576p50_16_9:
+            return 5; // 576p
+        case HDMI_VFRMT_1920x1080i60_16_9:
+            return 6; // 1080i
+        case HDMI_VFRMT_1280x720p50_16_9:
+            return 7; // 720p
+		case HDMI_VFRMT_1280x720p60_16_9:
+			return 8;
+        case HDMI_VFRMT_1920x1080p24_16_9:
+			return 9;
+        case HDMI_VFRMT_1920x1080p25_16_9:
+			return 10;
+        case HDMI_VFRMT_1920x1080p30_16_9:
+        case HDMI_VFRMT_1920x1080p50_16_9:
+        case HDMI_VFRMT_1920x1080p60_16_9:
+	        return 11;
+        default:
+			//Rajucm: for all unsupported videomodes by mhl_ic_sii9244
+			DEV_DBG("Resolution %d: %s not supported by mhl_ic_sii9244\n", mode, video_format_2string(mode));
+			return -1;
+     }
+}
+int get_best_display_Mode(void)
+{
+	int order=0, bestOrder = 0, bestMode = HDMI_VFRMT_640x480p60_4_3, i;
+	if (external_common_state->disp_mode_list.num_of_elements) {
+		uint32 *video_mode = external_common_state->disp_mode_list.disp_mode_list;
+		for (i = 0; i < external_common_state->disp_mode_list.num_of_elements; i++){
+			order = get_mhl_v1_supported_video_modes(video_mode[i]);
+			if (order > bestOrder) {
+				bestOrder = order;
+				bestMode = video_mode[i];
+			}
+		}
+	}
+	return bestMode;
+}
+#endif
+
 bool hdmi_common_get_video_format_from_drv_data(struct msm_fb_data_type *mfd)
 {
 	uint32 format;
@@ -1523,7 +1650,12 @@
 				: HDMI_VFRMT_1440x576i50_16_9;
 			break;
 		case 1920:
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2) || defined (CONFIG_VIDEO_MHL_TABLET_V1)
+// Max supported resolution by sii9234/44 is 1080p 30Hz
+			format = HDMI_VFRMT_1920x1080p30_16_9;
+#else
 			format = HDMI_VFRMT_1920x1080p60_16_9;
+#endif
 			break;
 		}
 	}
@@ -1583,6 +1715,33 @@
 }
 EXPORT_SYMBOL(hdmi_mhl_get_supported_mode);
 
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+//Rajucm: mentain vfbi timing correction for bestresolution...
+static struct fb_var_screeninfo current_vscrinfo;
+struct fb_var_screeninfo *hdmi_fb_vscrinfo(void)
+{
+	const struct hdmi_disp_mode_timing_type *timing =
+		hdmi_common_get_supported_mode(
+		external_common_state->video_resolution);
+		if (timing == NULL || !timing->supported)
+		return NULL;
+		DEV_DBG("%d : %s\n", external_common_state->video_resolution,
+			video_format_2string(external_common_state->video_resolution));
+		current_vscrinfo.reserved[3] = timing->video_format;
+		current_vscrinfo.xres=timing->active_h;
+		current_vscrinfo.yres=timing->active_v;
+		current_vscrinfo.right_margin=timing->front_porch_h;
+		current_vscrinfo.hsync_len=timing->pulse_width_h;
+		current_vscrinfo.left_margin=timing->back_porch_h;
+		current_vscrinfo.lower_margin=timing->front_porch_v;
+		current_vscrinfo.vsync_len=timing->pulse_width_v;
+		current_vscrinfo.upper_margin=timing->back_porch_v;
+		current_vscrinfo.pixclock=timing->pixel_freq*1000;
+		return &current_vscrinfo;
+}
+EXPORT_SYMBOL(hdmi_fb_vscrinfo);
+#endif
+
 void hdmi_common_init_panel_info(struct msm_panel_info *pinfo)
 {
 	const struct hdmi_disp_mode_timing_type *timing =
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/external_common.h msm/external_common.h
--- /home/shade/kernel-msm/drivers/video/msm/external_common.h	2012-08-20 15:40:53.008119038 -0700
+++ msm/external_common.h	2012-08-10 12:10:27.371062703 -0700
@@ -9,10 +9,21 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
  */
 #ifndef __EXTERNAL_COMMON_H__
 #define __EXTERNAL_COMMON_H__
+
+#define QCT_SWITCH_STATE_CMD
+#ifdef QCT_SWITCH_STATE_CMD
 #include <linux/switch.h>
+#endif
+
+#define DEV_INFO_ENA
 
 #ifdef DEBUG
 #ifndef DEV_DBG_PREFIX
@@ -20,11 +31,17 @@
 #endif
 #define DEV_DBG(args...)	pr_debug(DEV_DBG_PREFIX args)
 #else
-#define DEV_DBG(args...)	(void)0
+#define DEV_DBG(args...)	dev_info(external_common_state->dev, args)
 #endif /* DEBUG */
+#ifdef DEV_INFO_ENA
 #define DEV_INFO(args...)	dev_info(external_common_state->dev, args)
-#define DEV_WARN(args...)	dev_warn(external_common_state->dev, args)
-#define DEV_ERR(args...)	dev_err(external_common_state->dev, args)
+#define DEV_WARN(args...)	dev_info(external_common_state->dev, args)
+#define DEV_ERR(args...)	dev_info(external_common_state->dev, args)
+#else
+#define DEV_INFO(args...)	 do {} while (0)
+#define DEV_WARN(args...)	 do {} while (0)
+#define DEV_ERR(args...)	 do {} while (0)
+#endif
 
 #ifdef CONFIG_FB_MSM_TVOUT
 #define TVOUT_VFRMT_NTSC_M_720x480i		0
@@ -153,9 +170,15 @@
 #define HDMI_SETTINGS_1440x480i60_16_9					\
 	{HDMI_VFRMT_1440x480i60_16_9,    1440, 38,  124, 114, TRUE,	\
 	 240, 4, 3, 15, TRUE, 27000, 60000, TRUE, TRUE}
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2) && !defined(CONFIG_VIDEO_MHL_TABLET_V1)
 #define HDMI_SETTINGS_1920x1080p60_16_9					\
 	{HDMI_VFRMT_1920x1080p60_16_9,   1920, 88,  44,  148,  FALSE,	\
 	 1080, 4, 5, 36, FALSE, 148500, 60000, FALSE, TRUE}
+#else // due to MHL limitation, 1080p60 is not supported - jgk.20111214
+#define HDMI_SETTINGS_1920x1080p60_16_9					\
+	{HDMI_VFRMT_1920x1080p60_16_9,   1920, 88,  44,  148,  FALSE,	\
+	 1080, 4, 5, 36, FALSE, 148500, 60000, FALSE, FALSE}
+#endif
 #define HDMI_SETTINGS_720x576p50_4_3					\
 	{HDMI_VFRMT_720x576p50_4_3,      720,  12,  64,  68,   TRUE,	\
 	 576,  5, 5, 39, TRUE, 27000, 50000, FALSE, TRUE}
@@ -171,15 +194,30 @@
 #define HDMI_SETTINGS_1440x576i50_16_9					\
 	{HDMI_VFRMT_1440x576i50_16_9,    1440, 24,  126, 138,  TRUE,	\
 	 288,  2, 3, 19, TRUE, 27000, 50000, TRUE, TRUE}
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2) && !defined(CONFIG_VIDEO_MHL_TABLET_V1)
 #define HDMI_SETTINGS_1920x1080p50_16_9					\
 	{HDMI_VFRMT_1920x1080p50_16_9,   1920,  528,  44,  148,  FALSE,	\
 	 1080, 4, 5, 36, FALSE, 148500, 50000, FALSE, TRUE}
+#else // due to MHL limitation, 1080p60 is not supported - jgk.20111214
+#define HDMI_SETTINGS_1920x1080p50_16_9					\
+	{HDMI_VFRMT_1920x1080p50_16_9,   1920,  528,  44,  148,  FALSE,	\
+	 1080, 4, 5, 36, FALSE, 148500, 50000, FALSE, FALSE}
+#endif
+#ifdef CONFIG_VIDEO_MHL_TABLET_V1
+#define HDMI_SETTINGS_1920x1080p24_16_9					\
+	{HDMI_VFRMT_1920x1080p24_16_9,   1920,  638,  44,  148,  FALSE,	\
+	 1080, 4, 5, 36, FALSE, 74250, 24000, FALSE, FALSE}
+#define HDMI_SETTINGS_1920x1080p25_16_9					\
+	{HDMI_VFRMT_1920x1080p25_16_9,   1920,  528,  44,  148,  FALSE,	\
+	 1080, 4, 5, 36, FALSE, 74250, 25000, FALSE, FALSE}
+#else
 #define HDMI_SETTINGS_1920x1080p24_16_9					\
 	{HDMI_VFRMT_1920x1080p24_16_9,   1920,  638,  44,  148,  FALSE,	\
 	 1080, 4, 5, 36, FALSE, 74250, 24000, FALSE, TRUE}
 #define HDMI_SETTINGS_1920x1080p25_16_9					\
 	{HDMI_VFRMT_1920x1080p25_16_9,   1920,  528,  44,  148,  FALSE,	\
 	 1080, 4, 5, 36, FALSE, 74250, 25000, FALSE, TRUE}
+#endif
 #define HDMI_SETTINGS_1920x1080p30_16_9					\
 	{HDMI_VFRMT_1920x1080p30_16_9,   1920,  88,   44,  148,  FALSE,	\
 	 1080, 4, 5, 36, FALSE, 74250, 30000, FALSE, TRUE}
@@ -203,7 +241,9 @@
 	struct kobject *uevent_kobj;
 	uint32 video_resolution;
 	struct device *dev;
+#ifdef QCT_SWITCH_STATE_CMD
 	struct switch_dev sdev;
+#endif
 #ifdef CONFIG_FB_MSM_HDMI_3D
 	boolean format_3d;
 	void (*switch_3d)(boolean on);
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/hdmi_msm.c msm/hdmi_msm.c
--- /home/shade/kernel-msm/drivers/video/msm/hdmi_msm.c	2012-08-20 15:40:53.009119039 -0700
+++ msm/hdmi_msm.c	2012-08-17 10:16:29.556174047 -0700
@@ -30,6 +30,10 @@
 #include "msm_fb.h"
 #include "hdmi_msm.h"
 
+#ifdef CONFIG_VIDEO_MHL_TABLET_V1	
+#include <linux/switch.h>
+#endif
+
 /* Supported HDMI Audio channels */
 #define MSM_HDMI_AUDIO_CHANNEL_2		0
 #define MSM_HDMI_AUDIO_CHANNEL_4		1
@@ -57,6 +61,31 @@
 #define HDCP_DDC_CTRL_1		0x0124
 #define HDMI_DDC_CTRL		0x020C
 
+#ifdef HDMI_VIDEO_QUANTIZATION_ISSUE
+/*
+ * MHL CTS 3.2.3.2 Pixel Encoding - passed
+ * test by shkim@hdatc-korea.com
+ */
+#define DMA_E_BASE	0xB0000
+void video_quantization_setting(void)
+{
+	if(external_common_state->video_resolution == HDMI_VFRMT_640x480p60_4_3)
+	{
+		/* full range */
+		MDP_OUTP(MDP_BASE + DMA_E_BASE + 0x70, 0x00FF0000);
+		MDP_OUTP(MDP_BASE + DMA_E_BASE + 0x74, 0x00FF0000);
+		MDP_OUTP(MDP_BASE + DMA_E_BASE + 0x78, 0x00FF0000);
+	}
+	else
+	{
+		/* limited range */
+		MDP_OUTP(MDP_BASE + DMA_E_BASE + 0x70, 0x00EB0010);
+		MDP_OUTP(MDP_BASE + DMA_E_BASE + 0x74, 0x00EB0010);
+		MDP_OUTP(MDP_BASE + DMA_E_BASE + 0x78, 0x00EB0010);
+	}
+}
+#endif
+
 struct workqueue_struct *hdmi_work_queue;
 struct hdmi_msm_state_type *hdmi_msm_state;
 
@@ -72,10 +101,21 @@
 static inline void hdmi_msm_hdcp_enable(void) {}
 #endif
 
+static boolean hdmi_msm_is_dvi_mode(void);
 static void hdmi_msm_turn_on(void);
 static int hdmi_msm_audio_off(void);
 static int hdmi_msm_read_edid(void);
 static void hdmi_msm_hpd_off(void);
+static int hdmi_msm_hpd_on(bool trigger_handler);
+
+#if defined(CONFIG_VIDEO_MHL_V1) && defined(CONFIG_VIDEO_MHL_V2) && defined(CONFIG_VIDEO_MHL_TABLET_V1)
+#error "only one among CONFIG_VIDEO_MHL_V1 and CONFIG_VIDEO_MHL_V2 should be defined"
+#endif
+
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+static DECLARE_WAIT_QUEUE_HEAD(hdmi_msm_resolution_switchEvent);
+static DECLARE_WAIT_QUEUE_HEAD(hdmi_msm_state_work_completedEvent);
+#endif
 
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT
 
@@ -757,10 +797,52 @@
 }
 #endif /* DEBUG */
 
-static void hdmi_msm_turn_on(void);
-static int hdmi_msm_audio_off(void);
-static int hdmi_msm_read_edid(void);
-static void hdmi_msm_hpd_off(void);
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+static bool mhl_connected = false;
+static bool mhl_disconnected = false;
+
+bool mhl_hpd_state = false;
+bool rstate = false;
+static bool resolution_switch_signal = false;
+static bool state_work_completed = true;
+
+void mhl_hpd_handler(bool state)
+{
+	DEV_INFO("mhl_hpd_handler with state as %d\n", state);
+	if(mhl_hpd_state == state)
+		return;
+	wait_event_interruptible_timeout(hdmi_msm_state_work_completedEvent, state_work_completed, msecs_to_jiffies(4000));
+	state_work_completed = false;
+	hdmi_msm_state->hpd_cable_chg_detected = TRUE;
+	mhl_hpd_state = state;
+	
+	if(hdmi_msm_state->pd->bootup_ck)
+		rstate = state && hdmi_msm_state->boot_completion;
+	else
+		rstate = state;
+	
+	if(rstate)
+	{
+		msleep(200);	//To make sure that the previous  disconnect event handling  is completed.
+						//The audio off in case of disconnection with 2 iterations is found to be taking  > 200 ms.
+		hdmi_msm_hpd_on(false);
+	  	mhl_connected = true;
+		queue_work(hdmi_work_queue, &hdmi_msm_state->hpd_state_work);		
+	}
+	else
+	{			
+		mhl_disconnected = true;
+		queue_work(hdmi_work_queue, &hdmi_msm_state->hpd_state_work);		 
+	}	
+	
+}
+EXPORT_SYMBOL(mhl_hpd_handler);
+
+bool is_hdmi_ready(void)
+{
+	return (!hdmi_msm_state || !hdmi_msm_state->hpd_initialized || !HDMI_BASE )?FALSE:TRUE;		
+}
+#endif
 
 static void hdmi_msm_hpd_state_work(struct work_struct *work)
 {
@@ -770,10 +852,14 @@
 	if (!hdmi_msm_state || !hdmi_msm_state->hpd_initialized ||
 		!MSM_HDMI_BASE) {
 		DEV_DBG("%s: ignored, probe failed\n", __func__);
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+		state_work_completed = true;
+#endif
 		return;
 	}
 
 	DEV_DBG("%s:Got interrupt\n", __func__);
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
 	/* HPD_INT_STATUS[0x0250] */
 	hpd_state = (HDMI_INP(0x0250) & 0x2) >> 1;
 	mutex_lock(&external_common_state_hpd_mutex);
@@ -800,6 +886,13 @@
 			__func__);
 		return;
 	}
+#else
+	mutex_lock(&external_common_state_hpd_mutex);
+	mutex_lock(&hdmi_msm_state_mutex);
+	hpd_state = 0x0000 | mhl_hpd_state;
+	external_common_state->hpd_state = hpd_state;
+	mutex_unlock(&external_common_state_hpd_mutex);
+#endif
 
 	hdmi_msm_state->hpd_stable = 1;
 	DEV_INFO("HDMI HPD: event detected\n");
@@ -821,19 +914,34 @@
 		DEV_INFO("HDMI HPD: QDSP OFF\n");
 		kobject_uevent_env(external_common_state->uevent_kobj,
 				   KOBJ_CHANGE, envp);
+#ifdef QCT_SWITCH_STATE_CMD
 		switch_set_state(&external_common_state->sdev, 0);
 		DEV_INFO("Hdmi state switch to %d: %s\n",
 			external_common_state->sdev.state,  __func__);
+#endif
+
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
 		if (hpd_state) {
+#else
+		if (hpd_state && mhl_connected) {
+#endif
 			hdmi_msm_read_edid();
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 			hdmi_msm_state->reauth = FALSE ;
 #endif
 			/* Build EDID table */
 			hdmi_msm_turn_on();
+
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+			mhl_connected = false;
+#endif
 			DEV_INFO("HDMI HPD: sense CONNECTED: send ONLINE\n");
 			kobject_uevent(external_common_state->uevent_kobj,
 				KOBJ_ONLINE);
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+			wait_event_interruptible_timeout(hdmi_msm_resolution_switchEvent, resolution_switch_signal, msecs_to_jiffies(3*1000)); // Placed here instead of hdcp enable function as this is a first time issue and when the auth_fail_int happens the hdcp_enable function should not wait unnecessarily.
+			resolution_switch_signal = false;// set to false for the next sync detect.
+#endif
 			hdmi_msm_hdcp_enable();
 #ifndef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 			/* Send Audio for HDMI Compliance Cases*/
@@ -842,18 +950,44 @@
 			DEV_INFO("HDMI HPD: sense : send HDCP_PASS\n");
 			kobject_uevent_env(external_common_state->uevent_kobj,
 				KOBJ_CHANGE, envp);
+#endif
+#ifdef QCT_SWITCH_STATE_CMD
 			switch_set_state(&external_common_state->sdev, 1);
 			DEV_INFO("Hdmi state switch to %d: %s\n",
 				external_common_state->sdev.state, __func__);
+#else
+			switch_set_state(&hdmi_msm_state->hdmi_audio_switch, 1);
 #endif
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2) || defined(CONFIG_VIDEO_MHL_TABLET_V1)
+			/*sending hdmi_audio_ch*/
+			switch_set_state(&hdmi_msm_state->hdmi_audio_ch,
+				hdmi_msm_is_dvi_mode() ?
+				0 : 2);
+#endif
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
 		} else {
+#else
+		} else if (mhl_disconnected) {
+			mhl_disconnected = false;
+#endif
 			DEV_INFO("HDMI HPD: sense DISCONNECTED: send OFFLINE\n"
 				);
 			kobject_uevent(external_common_state->uevent_kobj,
 				KOBJ_OFFLINE);
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2) || defined(CONFIG_VIDEO_MHL_TABLET_V1)
+			/*sending hdmi_audio_ch*/
+			switch_set_state(&hdmi_msm_state->hdmi_audio_ch, -1);
+#endif
+#ifdef QCT_SWITCH_STATE_CMD
 			switch_set_state(&external_common_state->sdev, 0);
 			DEV_INFO("Hdmi state switch to %d: %s\n",
 				external_common_state->sdev.state,  __func__);
+#else
+			switch_set_state(&hdmi_msm_state->hdmi_audio_switch, 0);
+#endif
+#ifdef CONFIG_VIDEO_MHL_TABLET_V1
+			wake_unlock(&hdmi_msm_state->wake_lock);
+#endif
 		}
 	}
 
@@ -959,7 +1093,9 @@
 	/* HDMI_HPD_INT_CTRL[0x0254] */
 	hpd_int_ctrl = HDMI_INP_ND(0x0254);
 	if ((hpd_int_ctrl & (1 << 2)) && (hpd_int_status & (1 << 0))) {
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
 		boolean cable_detected = (hpd_int_status & 2) >> 1;
+#endif
 
 		/* HDMI_HPD_INT_CTRL[0x0254] */
 		/* Clear all interrupts, timer will turn IRQ back on
@@ -970,6 +1106,7 @@
 
 		DEV_DBG("%s: HPD IRQ, Ctrl=%04x, State=%04x\n", __func__,
 			hpd_int_ctrl, hpd_int_status);
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
 		mutex_lock(&hdmi_msm_state_mutex);
 		hdmi_msm_state->hpd_cable_chg_detected = TRUE;
 
@@ -995,6 +1132,7 @@
 			hdmi_msm_state->hpd_during_auth = TRUE;
 			mutex_unlock(&hdcp_auth_state_mutex);
 		}
+#endif
 		return IRQ_HANDLED;
 	}
 
@@ -1005,6 +1143,7 @@
 		/* SW_DONE INT occured, clr it */
 		HDMI_OUTP_ND(0x0214, ddc_int_ctrl | (1 << 1));
 		complete(&hdmi_msm_state->ddc_sw_done);
+		DEV_DBG("ddc_int_ctrl ISR IRQ_HANDLED\n");
 		return IRQ_HANDLED;
 	}
 
@@ -1078,15 +1217,26 @@
 			& ~((1 << 6) | (1 << 4)));
 		DEV_INFO("HDCP: AUTH_FAIL_INT received, LINK0_STATUS=0x%08x\n",
 			HDMI_INP_ND(0x011C));
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
 		if (hdmi_msm_state->full_auth_done) {
+#else
+		//DEV_DBG("The full_auth_proc_done in isr = %d\n", full_auth_proc_done); 
+		// Praveen added the mhl_hpd_state flag. mhl_hpd_state will be true only when mhl cable is connected.
+		if (hdmi_msm_state->full_auth_done && mhl_hpd_state) {
+#endif
 			envp[0] = "HDCP_STATE=FAIL";
 			envp[1] = NULL;
 			DEV_INFO("HDMI HPD:QDSP OFF\n");
 			kobject_uevent_env(external_common_state->uevent_kobj,
-			KOBJ_CHANGE, envp);
+				KOBJ_CHANGE, envp);
+#ifdef QCT_SWITCH_STATE_CMD
 			switch_set_state(&external_common_state->sdev, 0);
 			DEV_INFO("Hdmi state switch to %d: %s\n",
 				external_common_state->sdev.state,  __func__);
+#endif
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+			hdmi_msm_set_mode(true); // to stop the noisy screen display
+#endif
 			mutex_lock(&hdcp_auth_state_mutex);
 			hdmi_msm_state->full_auth_done = FALSE;
 			mutex_unlock(&hdcp_auth_state_mutex);
@@ -1104,7 +1254,7 @@
 		hdmi_msm_state->full_auth_done = FALSE;
 
 		mutex_unlock(&hdcp_auth_state_mutex);
-		DEV_DBG("calling reauthenticate from %s HDCP FAIL INT ",
+		DEV_DBG("calling reauthenticate from %s HDCP FAIL INT\n",
 		    __func__);
 
 		/* Clear AUTH_FAIL_INFO as well */
@@ -1339,7 +1489,11 @@
 	 * Setting 31:24 bits : Time units to wait before timeout
 	 * when clock is being stalled by external sink device
 	 */
-	HDMI_OUTP_ND(0x0224, 0xff000000);
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+	HDMI_OUTP_ND(0x0224, 0);				// from Celox GB, jgk.20111215
+#elif defined(CONFIG_VIDEO_MHL_TABLET_V1)
+	HDMI_OUTP_ND(0x0224, 0xff000000);		// QC org
+#endif
 
 	/* 0x027C HDMI_DDC_REF
 	   [6] REFTIMER_ENABLE	Enable the timer
@@ -2352,7 +2506,9 @@
 
 	static uint8 buf[0xFF];
 	memset(buf, 0, sizeof(buf));
-
+#ifndef CONFIG_VIDEO_MHL_TABLET_V1
+	INIT_COMPLETION(hdmi_msm_state->hdcp_success_done);
+#endif
 	if (!is_part1_done) {
 		is_part1_done = TRUE;
 
@@ -2450,13 +2606,13 @@
 			[0] ENABLE */
 		/* encryption_enable | enable  */
 		HDMI_OUTP(0x0110, (1 << 8) | (1 << 0));
-
+#ifndef CONFIG_VIDEO_MHL_TABLET_V1
 		/*
 		 * Check to see if a HDCP DDC Failure is indicated in
 		 * HDCP_DDC_STATUS. If yes, clear it.
 		 */
 		check_and_clear_HDCP_DDC_Failure();
-
+#endif
 		/* 0x0118 HDCP_INT_CTRL
 		 *    [2] AUTH_SUCCESS_MASK	[R/W]	Mask bit for\
 		 *					HDCP Authentication
@@ -2484,7 +2640,7 @@
 		[9] AN_1_READY */
 		/* wait for an0 and an1 ready bits to be set in LINK0_STATUS */
 
-		mutex_lock(&hdcp_auth_state_mutex);
+		mutex_lock(&hdmi_msm_state_mutex);
 		timeout_count = 100;
 		while (((HDMI_INP_ND(0x011C) & (0x3 << 8)) != (0x3 << 8))
 			&& timeout_count--)
@@ -2498,13 +2654,11 @@
 			mutex_unlock(&hdcp_auth_state_mutex);
 			goto error;
 		}
-
 		/*
 		 * A small delay is needed here to avoid device crash observed
 		 * during reauthentication in MSM8960
 		 */
-		msleep(20);
-
+		msleep(25);
 		/* 0x0168 HDCP_RCVPORT_DATA12
 		   [23:8] BSTATUS
 		   [7:0] BCAPS */
@@ -2519,7 +2673,7 @@
 		   [31:0] LINK0_AN_1 */
 		/* read an1 calculation */
 		link0_an_1 = HDMI_INP(0x0150);
-		mutex_unlock(&hdcp_auth_state_mutex);
+		mutex_unlock(&hdmi_msm_state_mutex);
 
 		/* three bits 28..30 */
 		hdcp_key_state((HDMI_INP(0x011C) >> 28) & 0x7);
@@ -2597,22 +2751,28 @@
 		}
 
 		DEV_DBG("HDCP: R0'=%02x%02x\n", buf[1], buf[0]);
-		INIT_COMPLETION(hdmi_msm_state->hdcp_success_done);
+		//INIT_COMPLETION(hdmi_msm_state->hdcp_success_done);
 		/* 0x013C HDCP_RCVPORT_DATA2_0
 		[15:0] LINK0_RI */
 		HDMI_OUTP(0x013C, (((uint32)buf[1]) << 8) | buf[0]);
-
+#ifdef CONFIG_VIDEO_MHL_TABLET_V1
+	        INIT_COMPLETION(hdmi_msm_state->hdcp_success_done);
+		timeout_count = wait_for_completion_interruptible_timeout(
+			&hdmi_msm_state->hdcp_success_done, HZ/2);
+#else
 		timeout_count = wait_for_completion_interruptible_timeout(
 			&hdmi_msm_state->hdcp_success_done, HZ*2);
+#endif
 
 		if (!timeout_count) {
 			ret = -ETIMEDOUT;
 			is_match = HDMI_INP(0x011C) & BIT(12);
+			if (!is_match){
 			DEV_ERR("%s(%d): timedout, Link0=<%s>\n", __func__,
 			  __LINE__,
 			  is_match ? "RI_MATCH" : "No RI Match INTR in time");
-			if (!is_match)
 				goto error;
+	  	        }
 		}
 
 		/* 0x011C HDCP_LINK0_STATUS
@@ -2865,7 +3025,7 @@
 	for (i = 0; i < ksv_bytes - 1; i++) {
 		/* Write KSV byte and do not set DONE bit[0] */
 		HDMI_OUTP_ND(0x0244, kvs_fifo[i] << 16);
-
+#ifndef CONFIG_VIDEO_MHL_TABLET_V1
 		/* Once 64 bytes have been written, we need to poll for
 		 * HDCP_SHA_BLOCK_DONE before writing any further
 		 */
@@ -2886,7 +3046,7 @@
 				goto error;
 			}
 		}
-
+#endif
 	}
 
 	/* Write l to DONE bit[0] */
@@ -2919,6 +3079,7 @@
 		goto error;
 	}
 
+	//DEV_INFO("HDCP: authentication part2 with 0x011c= %x",  HDMI_INP_ND(0x011C));
 	DEV_INFO("HDCP: authentication part II, successful\n");
 
 hdcp_error:
@@ -2930,6 +3091,7 @@
 {
 	int ret = 0;
 	int poll = 3000;
+	//DEV_INFO("HDCP: authentication part3 with 0x011c= %x",  HDMI_INP_ND(0x011C));
 	while (poll) {
 		/* 0x011C HDCP_LINK0_STATUS
 		    [30:28]  KEYS_STATE = 3 = "Valid"
@@ -2961,9 +3123,11 @@
 	char *envp[2];
 
 	if (!hdmi_msm_has_hdcp()) {
+#ifdef QCT_SWITCH_STATE_CMD
 		switch_set_state(&external_common_state->sdev, 1);
 		DEV_INFO("Hdmi state switch to %d: %s\n",
 			external_common_state->sdev.state, __func__);
+#endif
 		return;
 	}
 
@@ -2985,6 +3149,13 @@
 	hdmi_msm_state->full_auth_done = FALSE;
 	mutex_unlock(&hdcp_auth_state_mutex);
 
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+	/* jgk.20110714
+	 * AKSV read is coming prior to HDMI CORE clk, which can make stability issues
+	 * so put it later than HDMI CORE clk */
+	msleep(5);
+#endif
+
 	/* PART I Authentication*/
 	ret = hdcp_authentication_part1();
 	if (ret)
@@ -3036,9 +3207,11 @@
 		kobject_uevent_env(external_common_state->uevent_kobj,
 		    KOBJ_CHANGE, envp);
 	}
+#ifdef QCT_SWITCH_STATE_CMD
 	switch_set_state(&external_common_state->sdev, 1);
 	DEV_INFO("Hdmi state switch to %d: %s\n",
 		external_common_state->sdev.state, __func__);
+#endif
 	return;
 
 error:
@@ -3054,13 +3227,19 @@
 		mutex_unlock(&hdcp_auth_state_mutex);
 	} else {
 		DEV_WARN("[DEV_DBG]: Calling reauth from [%s]\n", __func__);
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
 		if (hdmi_msm_state->panel_power_on)
+#else
+		if (hdmi_msm_state->panel_power_on || external_common_state->hpd_state)
+#endif
 			queue_work(hdmi_work_queue,
 			    &hdmi_msm_state->hdcp_reauth_work);
 	}
+#ifdef QCT_SWITCH_STATE_CMD
 	switch_set_state(&external_common_state->sdev, 0);
 	DEV_INFO("Hdmi state switch to %d: %s\n",
 		external_common_state->sdev.state, __func__);
+#endif
 }
 #endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT */
 
@@ -3353,6 +3532,24 @@
 }
 EXPORT_SYMBOL(hdmi_audio_enable);
 
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2) || defined(CONFIG_VIDEO_MHL_TABLET_V1)
+void rcp_cbus_uevent(u8 rcpCode)        
+{
+       char env_buf[120];
+       char *envp[2];
+       int env_offset = 0;
+       memset(env_buf, 0, sizeof(env_buf));
+       printk("%s : RCP Message Recvd , rcpCode = 0x%x\n",__func__,rcpCode);
+       sprintf(env_buf, "MHL_RCP=%x", rcpCode);        
+       envp[env_offset++] = env_buf;
+       envp[env_offset] = NULL;
+       kobject_uevent_env(external_common_state->uevent_kobj, KOBJ_CHANGE, envp);
+     return;
+}
+EXPORT_SYMBOL(rcp_cbus_uevent);
+#endif
+
+
 #define HDMI_AUDIO_PKT_CTRL			0x0020
 #define HDMI_AUDIO_SAMPLE_SEND_ENABLE		1
 
@@ -3579,7 +3776,6 @@
 void hdmi_msm_audio_sample_rate_reset(int rate)
 {
 	msm_hdmi_sample_rate = rate;
-
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 	if (hdmi_msm_has_hdcp())
 		hdcp_deauthenticate();
@@ -3624,8 +3820,8 @@
 		&& (i--)) {
 		audio_pkt_ctrl = HDMI_INP_ND(0x0020);
 		audio_cfg = HDMI_INP_ND(0x01D0);
-		DEV_DBG("%d times :: HDMI AUDIO PACKET is %08x and "
-		"AUDIO CFG is %08x", i, audio_pkt_ctrl, audio_cfg);
+		DEV_DBG("%s() %d times :: HDMI AUDIO PACKET is %08x and "
+			"AUDIO CFG is %08x", __func__, i, audio_pkt_ctrl, audio_cfg);
 		msleep(100);
 		if (!i) {
 			DEV_ERR("%s:failed to set BIT[0] AUDIO PACKET"
@@ -3648,7 +3844,7 @@
 	 0x10,	0x10,	0x10,	0x10,	0x10, 0x10, 0x10}, /*00*/
 	{0x18,	0x18,	0x28,	0x28,	0x28,	 0x28,	0x28,	0x28,	0x28,
 	 0x28,	0x28,	0x28,	0x28,	0x18, 0x28, 0x18}, /*01*/
-	{0x04,	0x04,	0x04,	0x04,	0x04,	 0x04,	0x04,	0x04,	0x04,
+	{0x00,	0x04,	0x04,	0x04,	0x00,	 0x04,	0x04,	0x04,	0x04,
 	 0x04,	0x04,	0x04,	0x04,	0x88, 0x04, 0x04}, /*02*/
 	{0x02,	0x06,	0x11,	0x15,	0x04,	 0x13,	0x10,	0x05,	0x1F,
 	 0x14,	0x20,	0x22,	0x21,	0x01, 0x03, 0x11}, /*03*/
@@ -3956,14 +4152,14 @@
 		&& (i--)) {
 		audio_pkt_ctrl = HDMI_INP_ND(0x0020);
 		audio_cfg = HDMI_INP_ND(0x01D0);
-		DEV_DBG("%d times :: HDMI AUDIO PACKET is %08x and "
-			"AUDIO CFG is %08x", i, audio_pkt_ctrl, audio_cfg);
+		DEV_DBG("%s() %d times :: HDMI AUDIO PACKET is %08x and "
+			"AUDIO CFG is %08x", __func__, i, audio_pkt_ctrl, audio_cfg);
 		msleep(20);
 	}
 
-	mutex_lock(&hdcp_auth_state_mutex);
+	mutex_lock(&hdmi_msm_state_mutex);
 	hdmi_msm_reset_core();
-	mutex_unlock(&hdcp_auth_state_mutex);
+	mutex_unlock(&hdmi_msm_state_mutex);
 
 	hdmi_msm_init_phy(external_common_state->video_resolution);
 	/* HDMI_USEC_REFTIMER[0x0208] */
@@ -4009,10 +4205,12 @@
 	DEV_INFO("HDMI Core: Initialized\n");
 }
 
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
 static void hdmi_msm_hpd_state_timer(unsigned long data)
 {
 	queue_work(hdmi_work_queue, &hdmi_msm_state->hpd_state_work);
 }
+#endif
 
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 static void hdmi_msm_hdcp_timer(unsigned long data)
@@ -4068,14 +4266,29 @@
 		return;
 	}
 
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+	if (!hdmi_msm_state || !HDMI_BASE) {  //Praveen: probe failed hence no use in disabling/enabling clks as they are released.(  if probe failed, SS has seen kernel panic at this point as clks are released and set to NULL, enable/disable call caused panic).
+		return;
+	}
+#endif
+
 	DEV_DBG("%s: (timer, clk, 5V, core, IRQ off)\n", __func__);
 	del_timer(&hdmi_msm_state->hpd_state_timer);
 	disable_irq(hdmi_msm_state->irq);
 
 	hdmi_msm_set_mode(FALSE);
-	hdmi_msm_state->hpd_initialized = FALSE;
+
+#ifdef WORKAROUND_FOR_HDMI_CURRENT_LEAKAGE_FIX
 	hdmi_msm_powerdown_phy();
+#else//QC org
+	//HDMI_OUTP_ND(0x0308, 0x7F); /*0b01111111*/
+	//HDMI_OUTP_ND(0x0308, 0xFF); /*0b11111111*/
+#endif
+
+	hdmi_msm_state->hpd_initialized = FALSE;
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
 	hdmi_msm_state->pd->cec_power(0);
+#endif
 	hdmi_msm_state->pd->enable_5v(0);
 	hdmi_msm_state->pd->core_power(0, 1);
 	hdmi_msm_clk(0);
@@ -4090,6 +4303,30 @@
 #endif
 }
 
+static int hdmi_msm_set_txphy_init(void)
+{
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2) || defined(CONFIG_VIDEO_MHL_TABLET_V1)
+	if (!hdmi_msm_state || !HDMI_BASE) {
+		return 0;
+	}
+#endif
+
+	hdmi_msm_clk(1);
+	hdmi_msm_state->pd->core_power(1, 1);
+	hdmi_msm_state->pd->enable_5v(1);
+
+	hdmi_msm_set_mode(FALSE);
+
+	HDMI_OUTP_ND(0x0308, 0xFF); /*0b11111111*/
+	DEV_DBG("HDMI[0x0308] => [%08x]\n", HDMI_INP(0x0308));
+
+	hdmi_msm_state->pd->enable_5v(0);
+	hdmi_msm_state->pd->core_power(0, 1);
+	hdmi_msm_clk(0);
+
+	return 0;
+}
+
 static int hdmi_msm_hpd_on(bool trigger_handler)
 {
 	static int phy_reset_done;
@@ -4100,10 +4337,18 @@
 		return 0;
 	}
 
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2) || defined(CONFIG_VIDEO_MHL_TABLET_V1)
+	if (!hdmi_msm_state || !HDMI_BASE) {  //Praveen: probe failed hence no use in disabling/enabling clks as they are released.(  if probe failed, SS has seen kernel panic at this point as clks are released and set to NULL, enable/disable call caused panic).
+		return 0;
+	}
+#endif
+
 	hdmi_msm_clk(1);
 	hdmi_msm_state->pd->core_power(1, 1);
 	hdmi_msm_state->pd->enable_5v(1);
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2) && !defined(CONFIG_VIDEO_MHL_TABLET_V1)
 	hdmi_msm_state->pd->cec_power(1);
+#endif
 	hdmi_msm_dump_regs("HDMI-INIT: ");
 	hdmi_msm_set_mode(FALSE);
 
@@ -4149,9 +4394,11 @@
 	return 0;
 }
 
+#ifndef CONFIG_VIDEO_MHL_TABLET_V1
 static int hdmi_msm_power_ctrl(boolean enable)
 {
-	if (!external_common_state->hpd_feature_on)
+	if (!external_common_state->hpd_feature_on ||
+		!external_common_state->hpd_state)
 		return 0;
 
 	if (enable)
@@ -4161,15 +4408,53 @@
 
 	return 0;
 }
+#endif
+
+#ifdef CONFIG_VIDEO_MHL_TABLET_V1
+int hdmi_msm_hpd_switch(bool detect_flag)
+{
+	if(detect_flag)
+	{
+		printk("hdmi_hpd_on !!!!");
+		hdmi_msm_state->dock_state = TRUE;
+		if(!hdmi_msm_state->boot_state)
+			hdmi_msm_hpd_on(true);
+	}
+	else
+	{
+		printk("hdmi_hpd_off !!!!");
+		hdmi_msm_state->dock_state = FALSE;
+	}
+}
+EXPORT_SYMBOL(hdmi_msm_hpd_switch);
+#endif
 
 static int hdmi_msm_power_on(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd = platform_get_drvdata(pdev);
 	bool changed;
 
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+	int rc;
+	struct fb_var_screeninfo *var = &mfd->fbi->var;
+#endif
+
 	if (!hdmi_msm_state || !hdmi_msm_state->hdmi_app_clk || !MSM_HDMI_BASE)
 		return -ENODEV;
 
+
+//Added to fix boot up HDMI issue
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+	if(!hdmi_msm_state->hpd_initialized && !mhl_connected){  //hpd from mhl not from the hpd feature.
+		rc = hdmi_msm_hpd_on(false);
+		DEV_INFO("HPD: panel power on without mhl connected, hence should be powered off by caller\n");
+		if (rc) {
+			DEV_WARN("HPD: activation failed: rc=%d\n", rc);			
+			return rc;
+		}
+	}
+#endif
+	
 	DEV_INFO("power: ON (%dx%d %d)\n", mfd->var_xres, mfd->var_yres,
 		mfd->var_pixclock);
 
@@ -4183,6 +4468,9 @@
 #endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT */
 
 	changed = hdmi_common_get_video_format_from_drv_data(mfd);
+
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
+	// Hpd is not turned on or off baseed on the user option. Mhl triggers the on and dtv_off puts the hdmi in off state..
 	if (!external_common_state->hpd_feature_on || mfd->ref_cnt) {
 		int rc = hdmi_msm_hpd_on(true);
 		DEV_INFO("HPD: panel power without 'hpd' feature on\n");
@@ -4191,6 +4479,8 @@
 			return rc;
 		}
 	}
+#endif
+
 	hdmi_msm_audio_info_setup(TRUE, 0, 0, 0, FALSE);
 
 	mutex_lock(&external_common_state_hpd_mutex);
@@ -4202,11 +4492,24 @@
 	} else
 		mutex_unlock(&external_common_state_hpd_mutex);
 
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+	if (var->reserved[3]) {
+			DEV_DBG("praveen: In var reserved sending wakeup\n");
+			resolution_switch_signal = true;
+			wake_up_interruptible(&hdmi_msm_resolution_switchEvent);
+		}
+#endif
 	hdmi_msm_dump_regs("HDMI-ON: ");
 
 	DEV_INFO("power=%s DVI= %s\n",
 		hdmi_msm_is_power_on() ? "ON" : "OFF" ,
 		hdmi_msm_is_dvi_mode() ? "ON" : "OFF");
+
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+	state_work_completed = true;
+	wake_up_interruptible(&hdmi_msm_state_work_completedEvent);
+#endif
+	
 	return 0;
 }
 
@@ -4223,33 +4526,56 @@
 	if (!hdmi_msm_state->hdmi_app_clk)
 		return -ENODEV;
 
-#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 	mutex_lock(&hdmi_msm_state_mutex);
+#ifdef CONFIG_VIDEO_MHL_TABLET_V1
 	if (hdmi_msm_state->hdcp_activating) {
+#else
+	if (mhl_hpd_state /*|| hdmi_msm_state->hdcp_activating*/) {
+#endif
 		hdmi_msm_state->panel_power_on = FALSE;
 		mutex_unlock(&hdmi_msm_state_mutex);
-		DEV_INFO("HDCP: activating, returning\n");
+		DEV_INFO("%s : mhl_hpd_state is still Active, returning\n",__func__);
 		return 0;
 	}
 	mutex_unlock(&hdmi_msm_state_mutex);
-#endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT */
 
 	DEV_INFO("power: OFF (audio off, Reset Core)\n");
 	hdmi_msm_audio_off();
+#ifdef  CONFIG_VIDEO_MHL_TABLET_V1
+	disable_irq(hdmi_msm_state->irq);
+	hdmi_msm_set_mode(FALSE);
+	HDMI_OUTP_ND(0x0308, 0x7F); /*0b01111111*/
+	hdmi_msm_state->hpd_initialized = FALSE;
+	hdmi_msm_state->pd->enable_5v(0);
+	hdmi_msm_state->pd->core_power(0, 1);
+	hdmi_msm_clk(0);
+	hdmi_msm_state->hpd_initialized = FALSE;
+#else
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 	hdcp_deauthenticate();
 #endif
 	hdmi_msm_hpd_off();
+#endif /*CONFIG_VIDEO_MHL_TABLET_V1*/
 	hdmi_msm_powerdown_phy();
 	hdmi_msm_dump_regs("HDMI-OFF: ");
-	hdmi_msm_hpd_on(true);
-
+#ifdef CONFIG_VIDEO_MHL_TABLET_V1
+	if(hdmi_msm_state->dock_state)
+    	        hdmi_msm_hpd_on(false);
+#endif
+	
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
+	// Hpd is not turned on or off baseed on the user option. Mhl triggers the on and dtv_off puts the hdmi in off state..
 	mutex_lock(&external_common_state_hpd_mutex);
 	if (!external_common_state->hpd_feature_on || mfd->ref_cnt)
 		hdmi_msm_hpd_off();
 	mutex_unlock(&external_common_state_hpd_mutex);
+#endif
 
 	hdmi_msm_state->panel_power_on = FALSE;
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+	state_work_completed = true;
+	wake_up_interruptible(&hdmi_msm_state_work_completedEvent);
+#endif
 	return 0;
 }
 
@@ -4351,6 +4677,15 @@
 		goto error;
 	}
 
+	if(hdmi_msm_state->pd->bootup_ck)
+		hdmi_msm_state->boot_completion = false;
+
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2) || defined(CONFIG_VIDEO_MHL_TABLET_V1)
+	/*uevent for info of hdmi audio channel*/
+	hdmi_msm_state->hdmi_audio_ch.name = "ch_hdmi_audio";
+	switch_dev_register(&hdmi_msm_state->hdmi_audio_ch);
+#endif
+
 	rc = request_threaded_irq(hdmi_msm_state->irq, NULL, &hdmi_msm_isr,
 		IRQF_TRIGGER_HIGH | IRQF_ONESHOT, "hdmi_msm_isr", NULL);
 	if (rc) {
@@ -4359,6 +4694,7 @@
 	}
 	disable_irq(hdmi_msm_state->irq);
 
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
 	init_timer(&hdmi_msm_state->hpd_state_timer);
 	hdmi_msm_state->hpd_state_timer.function =
 		hdmi_msm_hpd_state_timer;
@@ -4366,6 +4702,7 @@
 
 	hdmi_msm_state->hpd_state_timer.expires = 0xffffffffL;
 	add_timer(&hdmi_msm_state->hpd_state_timer);
+#endif
 
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 	init_timer(&hdmi_msm_state->hdcp_timer);
@@ -4398,9 +4735,13 @@
 
 	DEV_INFO("HDMI HPD: ON\n");
 
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2) && !defined(CONFIG_VIDEO_MHL_TABLET_V1)
 	rc = hdmi_msm_hpd_on(true);
 	if (rc)
 		goto error;
+#endif
+
+	(void)hdmi_msm_set_txphy_init();
 
 	if (hdmi_msm_has_hdcp()) {
 		/* Don't Set Encryption in case of non HDCP builds */
@@ -4418,9 +4759,11 @@
 		del_timer(&hdmi_msm_state->hdcp_timer);
 #endif
 	}
-
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2) && !defined(CONFIG_VIDEO_MHL_TABLET_V1)
 	queue_work(hdmi_work_queue, &hdmi_msm_state->hpd_read_work);
+#endif
 
+#ifdef QCT_SWITCH_STATE_CMD
 	/* Initialize hdmi node and register with switch driver */
 	if (hdmi_prim_display)
 		external_common_state->sdev.name = "hdmi_as_primary";
@@ -4428,6 +4771,15 @@
 		external_common_state->sdev.name = "hdmi";
 	if (switch_dev_register(&external_common_state->sdev) < 0)
 		DEV_ERR("Hdmi switch registration failed\n");
+#else
+	hdmi_msm_state->hdmi_audio_switch.name = "hdmi";
+	switch_dev_register(&hdmi_msm_state->hdmi_audio_switch);
+#endif
+
+#ifdef CONFIG_VIDEO_MHL_TABLET_V1
+	hdmi_msm_state->pd->cec_power(0);
+	wake_lock_init(&hdmi_msm_state->wake_lock, WAKE_LOCK_SUSPEND, "hdmi_msm");
+#endif
 
 	return 0;
 
@@ -4462,8 +4814,10 @@
 
 	DEV_INFO("HDMI HPD: OFF\n");
 
+#ifdef QCT_SWITCH_STATE_CMD
 	/* Unregister hdmi node from switch driver */
 	switch_dev_unregister(&external_common_state->sdev);
+#endif
 
 	hdmi_msm_hpd_off();
 	free_irq(hdmi_msm_state->irq, NULL);
@@ -4500,14 +4854,33 @@
 	int rc = 0;
 
 	DEV_INFO("%s: %d\n", __func__, on);
+#ifdef CONFIG_VIDEO_MHL_TABLET_V1
+	hdmi_msm_state->boot_state = FALSE;
+
 	if (on) {
 		rc = hdmi_msm_hpd_on(true);
 	} else {
 		hdmi_msm_hpd_off();
+#ifdef QCT_SWITCH_STATE_CMD
 		/* Set HDMI switch node to 0 on HPD feature disable */
 		switch_set_state(&external_common_state->sdev, 0);
+#endif
 	}
 
+	/*Reduce the power consumption in idle*/
+	if(!hdmi_msm_state->dock_state)
+		hdmi_msm_hpd_off();
+#endif
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
+	if(hdmi_msm_state->pd->bootup_ck){
+		if(mhl_hpd_state){ /* Added to fix boot up HDMI issue */
+			hdmi_msm_hpd_on(false);
+			mhl_connected = true;
+			queue_work(hdmi_work_queue, &hdmi_msm_state->hpd_state_work);
+		}
+		hdmi_msm_state->boot_completion = true;
+	}
+#endif
 	return rc;
 }
 
@@ -4520,7 +4893,9 @@
 static struct msm_fb_panel_data hdmi_msm_panel_data = {
 	.on = hdmi_msm_power_on,
 	.off = hdmi_msm_power_off,
+#ifndef CONFIG_VIDEO_MHL_TABLET_V1
 	.power_ctrl = hdmi_msm_power_ctrl,
+#endif
 };
 
 static struct platform_device this_device = {
@@ -4536,8 +4911,10 @@
 	if (cpu_is_msm8930())
 		return 0;
 
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2) && !defined(CONFIG_VIDEO_MHL_TABLET_V1)
 	if (msm_fb_detect_client("hdmi_msm"))
 		return 0;
+#endif
 
 #ifdef CONFIG_FB_MSM_HDMI_AS_PRIMARY
 	hdmi_prim_display = 1;
@@ -4552,7 +4929,11 @@
 	}
 
 	external_common_state = &hdmi_msm_state->common;
+#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2) && !defined(CONFIG_VIDEO_MHL_TABLET_V1)
 	external_common_state->video_resolution = HDMI_VFRMT_1920x1080p60_16_9;
+#else
+	external_common_state->video_resolution = HDMI_VFRMT_1920x1080p30_16_9;
+#endif
 #ifdef CONFIG_FB_MSM_HDMI_3D
 	external_common_state->switch_3d = hdmi_msm_switch_3d;
 #endif
@@ -4610,7 +4991,9 @@
 		platform_driver_unregister(&this_driver);
 		goto init_exit;
 	}
-
+#ifdef CONFIG_VIDEO_MHL_TABLET_V1
+	hdmi_msm_state->boot_state = TRUE;
+#endif
 	pr_debug("%s: success:"
 #ifdef DEBUG
 		" DEBUG"
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/hdmi_msm.h msm/hdmi_msm.h
--- /home/shade/kernel-msm/drivers/video/msm/hdmi_msm.h	2012-08-20 15:40:53.009119039 -0700
+++ msm/hdmi_msm.h	2012-08-10 12:10:27.372062702 -0700
@@ -13,7 +13,9 @@
 #ifndef __HDMI_MSM_H__
 #define __HDMI_MSM_H__
 
+#include <linux/switch.h>
 #include <mach/msm_iomap.h>
+#include <linux/wakelock.h>
 #include "external_common.h"
 /* #define PORT_DEBUG */
 
@@ -33,6 +35,9 @@
 #define HDMI_INP(offset)		inpdw(MSM_HDMI_BASE+(offset))
 #endif
 
+// a software workaround for a potential HW problem with HDMI which exists on V1 and V2 8660 units
+#define WORKAROUND_FOR_HDMI_CURRENT_LEAKAGE_FIX
+
 
 /*
  * Ref. HDMI 1.4a
@@ -110,6 +115,17 @@
 	void __iomem *hdmi_io;
 
 	struct external_common_state_type common;
+#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2) || defined(CONFIG_VIDEO_MHL_TABLET_V1)
+	struct switch_dev	hdmi_audio_ch;
+#endif
+	boolean	boot_completion;
+	struct wake_lock wake_lock;
+	boolean dock_state;
+	boolean boot_state;
+
+#ifndef QCT_SWITCH_STATE_CMD
+	struct switch_dev	hdmi_audio_switch;
+#endif
 };
 
 extern struct hdmi_msm_state_type *hdmi_msm_state;
Only in msm: hdmi_msm_tablet.c
Only in msm: hdmi_msm_tablet.h
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/Kconfig msm/Kconfig
--- /home/shade/kernel-msm/drivers/video/msm/Kconfig	2012-08-20 15:40:52.999119039 -0700
+++ msm/Kconfig	2012-08-20 14:44:30.408350342 -0700
@@ -1,5 +1,6 @@
-
 source "drivers/video/msm/vidc/Kconfig"
+source "drivers/video/msm/mhl_v1/Kconfig"
+source "drivers/video/msm/mhl_v2/Kconfig"
 
 config FB_MSM
 	tristate "MSM Framebuffer support"
@@ -107,14 +108,28 @@
 	bool
 	default n
 
+config CMC623_P5LTE
+	bool "Support for CMC623"
+	depends on FB && ARCH_MSM
+	default n
+
+config CMC624_P8LTE
+	bool "Support for CMC624"
+	depends on FB && ARCH_MSM
+	default n
+
 config FB_MSM_OVERLAY
 	depends on FB_MSM_MDP40 && ANDROID_PMEM
 	bool "MDP4 overlay support"
 	default n
 
+config FB_MSM_MDP_ADDITIONAL_BUS_SCALING
+	bool "MDP4 additional bus scaling"
+	default n
+
 config FB_MSM_DTV
 	depends on FB_MSM_OVERLAY
-	bool
+	bool "Support DTV"
 	default n
 
 config FB_MSM_EXTMDDI
@@ -199,6 +214,45 @@
 	  and up to WUXGA 1920x1200 18-bit
 	  using a dual LVDS link.
 
+config FB_MSM_MIPI_DSI_S6D6AA0_WXGA
+	bool
+	select FB_MSM_MIPI_DSI
+	default n
+
+config FB_MSM_MIPI_DSI_S6E8AA0_HD720
+	bool
+	select FB_MSM_MIPI_DSI
+	select FB_MSM_MDP_ADDITIONAL_BUS_SCALING
+	default n
+
+config FB_MSM_MIPI_DSI_S6E8AA0_WXGA
+	bool
+	select FB_MSM_MIPI_DSI
+	default n
+
+config FB_MSM_MIPI_DSI_S6E8AA0_WXGA_Q1
+	bool
+	select FB_MSM_MIPI_DSI
+	select FB_MSM_MIPI_DSI_ESD_REFRESH
+	select FB_MSM_MDP_ADDITIONAL_BUS_SCALING
+	default n
+
+config FB_MSM_MIPI_DSI_S6E8AB0_WXGA
+	bool
+	select FB_MSM_MIPI_DSI
+	select FB_MSM_MIPI_DSI_ESD_REFRESH
+	default n
+
+config FB_MSM_MIPI_DSI_ESD_REFRESH
+	bool
+	select FB_MSM_MIPI_DSI
+	default n
+
+config FB_MSM_MIPI_DSI_SAMSUNG
+	bool
+	select FB_MSM_MIPI_DSI
+	default n
+
 config FB_MSM_LCDC_ST15_WXGA
     bool
     select FB_MSM_LCDC_PANEL
@@ -211,6 +265,16 @@
     ---help---
       Support for ST1.5 WXGA (1366x768) panel
 
+config FB_MSM_LCDC_LD9040_WVGA
+	bool
+	select FB_MSM_LCDC_PANEL
+	default n
+
+config FB_MSM_LCDC_P5LTE_WXGA
+	bool
+	select FB_MSM_LCDC_PANEL
+	default n
+
 config FB_MSM_LCDC_PRISM_WVGA
 	bool
 	select FB_MSM_LCDC_PANEL
@@ -320,14 +384,25 @@
 	  The panel is connected to the host
 	  via Toshiba DSI-to-LVDS bridge.
 
-config FB_MSM_MIPI_CHIMEI_WUXGA
-	bool "LVDS Chimei WUXGA Panel using Toshiba MIPI DSI-to-LVDS bridge."
-	select FB_MSM_MIPI_DSI_TC358764_DSI2LVDS
-	---help---
-	  Support for Chimei WUXGA (1920x1200) panel.
-	  The panel is using a serial LVDS input.
-	  The panel is connected to the host
-	  via Toshiba DSI-to-LVDS bridge.
+config FB_MSM_MIPI_S6D6AA0_WXGA_PT
+	bool
+	select FB_MSM_MIPI_DSI_S6D6AA0_WXGA
+	default n
+
+config FB_MSM_MIPI_S6E8AA0_HD720_PT
+	bool
+	select FB_MSM_MIPI_DSI_S6E8AA0_HD720
+	default n
+
+config FB_MSM_MIPI_S6E8AA0_WXGA_Q1_PT
+	bool
+	select FB_MSM_MIPI_DSI_S6E8AA0_WXGA_Q1
+	default n
+
+config FB_MSM_MIPI_S6E8AB0_WXGA_PT
+	bool
+	select FB_MSM_MIPI_DSI_S6E8AB0_WXGA
+	default n
 
 config FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT
 	bool
@@ -369,6 +444,20 @@
 	prompt "LCD Panel"
 	default FB_MSM_MDDI_AUTO_DETECT
 
+config FB_MSM_LCDC_LD9040_WVGA_PANEL
+	depends on FB_MSM_LCDC_HW
+	bool "LCDC LD9040 WVGA Panel"
+	select FB_MSM_LCDC_LD9040_WVGA
+	---help---
+	  Support for LCDC LD9040 WVGA (480x800) panel
+
+config FB_MSM_LCDC_P5LTE_WXGA_PANEL
+	depends on FB_MSM_LCDC_HW
+	bool "P5LTE WXGA Panel"
+	select FB_MSM_LCDC_P5LTE_WXGA
+	---help---
+	  Support for P5LTE WXGA panel
+
 config FB_MSM_LCDC_PRISM_WVGA_PANEL
 	depends on FB_MSM_LCDC_HW
 	bool "LCDC Prism WVGA Panel"
@@ -470,7 +559,6 @@
 	select FB_MSM_MIPI_ORISE_CMD_720P_PT
 	select FB_MSM_MIPI_SIMULATOR_VIDEO
 	select FB_MSM_MIPI_CHIMEI_WXGA
-	select FB_MSM_MIPI_CHIMEI_WUXGA
 	---help---
 	  Support for MIPI panel auto detect
 
@@ -578,9 +666,29 @@
 	bool "MIPI Chimei WXGA PT Panel"
 	select FB_MSM_MIPI_CHIMEI_WXGA
 
-config FB_MSM_MIPI_CHIMEI_WUXGA_PANEL
-	bool "MIPI Chimei WUXGA Panel"
-	select FB_MSM_MIPI_CHIMEI_WUXGA
+config FB_MSM_MIPI_S6D6AA0_WXGA_PANEL
+	bool "MIPI S6D6AA0_WXGA Panel"
+	select FB_MSM_MIPI_S6D6AA0_WXGA_PT
+
+config FB_MSM_MIPI_S6E8AA0_HD720_PANEL
+	bool "MIPI S6E8AA0_HD720 Panel"
+	select FB_MSM_MIPI_S6E8AA0_HD720_PT
+	
+config FB_MSM_MIPI_S6E8AA0_WXGA_Q1_PANEL
+	bool "MIPI S6E8AA0)WXGA_Q1 Panel"
+	select FB_MSM_MIPI_S6E8AA0_WXGA_Q1_PT
+
+config FB_MSM_MIPI_S6E8AB0_WXGA_PANEL
+	bool "MIPI S6E8AB0) WXGA Panel"
+	select FB_MSM_MIPI_S6E8AB0_WXGA_PT
+	
+config FB_MSM_MIPI_NOVATEK_CMD_QHD_PT_PANEL
+	bool "MIPI NOVATEK CMD QHD PT Panel"
+	select FB_MSM_MIPI_NOVATEK_CMD_QHD_PT
+
+config FB_MSM_MIPI_SAMSUNG_VIDEO_WVGA_PT_PANEL
+	bool "MIPI SMASUNG_WVGA Panel"
+	select FB_MSM_MIPI_SAMSUNG_VIDEO_WVGA	
 
 config FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT_PANEL
 	bool "MIPI Truly Video WVGA PT Panel"
@@ -673,7 +781,6 @@
           Support for HDCP mode for ADV7520 HDMI 720p Panel
           Choose to enable HDCP
 
-
 config FB_MSM_HDMI_MSM_PANEL
 	depends on FB_MSM_MDP40
 	bool "MSM HDMI 1080p Panel"
@@ -711,7 +818,7 @@
 config FB_MSM_HDMI_MHL
 	depends on FB_MSM_HDMI_MSM_PANEL
 	bool 'HDMI to MHL support'
-	default n
+	default y
 	---help---
 	  Support the HDMI to MHL conversion.
 	  MHL (Mobile High-Definition Link) technology
Only in msm: lcdc_ea8868_seq.h
Only in msm: lcdc_ld9040.c
Only in msm: lcdc_ld9040_seq.h
Only in msm: lcdc_pxlte.c
Only in msm: lcdc_S6E63M0.c
Only in msm: lcdc_S6E63M0_seq.h
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/logo.c msm/logo.c
--- /home/shade/kernel-msm/drivers/video/msm/logo.c	2012-07-26 15:01:31.761832375 -0700
+++ msm/logo.c	2012-08-17 10:16:29.557174047 -0700
@@ -23,11 +23,193 @@
 
 #include <linux/irq.h>
 #include <asm/system.h>
+#include <asm/cacheflush.h>
 
 #define fb_width(fb)	((fb)->var.xres)
 #define fb_height(fb)	((fb)->var.yres)
 #define fb_size(fb)	((fb)->var.xres * (fb)->var.yres * 2)
 
+#define DISPLAY_BOOT_PROGRESS
+
+#ifdef DISPLAY_BOOT_PROGRESS
+static int progress_flag = 0;
+static int progress_pos;
+static struct timer_list progress_timer;
+
+#ifdef CONFIG_FB_MSM_MIPI_S6E8AA0_HD720_PANEL
+#define PROGRESS_BAR_WIDTH	4
+#define PROGRESS_BAR_HEIGHT	8
+#define PROGRESS_BAR_LEFT_POS	82
+#define PROGRESS_BAR_RIGHT_POS	637
+#define PROGRESS_BAR_START_Y	922
+#elif defined(CONFIG_FB_MSM_MIPI_S6E8AA0_WXGA_Q1_PANEL)
+#define PROGRESS_BAR_WIDTH	4
+#define PROGRESS_BAR_HEIGHT	8
+#define PROGRESS_BAR_LEFT_POS	82
+#define PROGRESS_BAR_RIGHT_POS	717
+#define PROGRESS_BAR_START_Y	922
+#else
+#define PROGRESS_BAR_WIDTH	4
+#define PROGRESS_BAR_HEIGHT	8
+#define PROGRESS_BAR_LEFT_POS	54
+#define PROGRESS_BAR_RIGHT_POS	425
+#define PROGRESS_BAR_START_Y	576
+#endif
+
+static unsigned char anycall_progress_bar_left[] =
+{	
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x2E, 0xB1, 0xDB, 0x00, 0x2E, 0xB1, 0xDB, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x2E, 0xB1, 0xDB, 0x00, 0x2E, 0xB1, 0xDB, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x2E, 0xB1, 0xDB, 0x00, 0x2E, 0xB1, 0xDB, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x2E, 0xB1, 0xDB, 0x00, 0x2E, 0xB1, 0xDB, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00
+};
+
+static unsigned char anycall_progress_bar_right[] =
+{	
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x2E, 0xB1, 0xDB, 0x00, 0x2E, 0xB1, 0xDB, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 
+	0x2E, 0xB1, 0xDB, 0x00, 0x2E, 0xB1, 0xDB, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 
+	0x2E, 0xB1, 0xDB, 0x00, 0x2E, 0xB1, 0xDB, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 
+	0x2E, 0xB1, 0xDB, 0x00, 0x2E, 0xB1, 0xDB, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00
+};
+
+static unsigned char anycall_progress_bar_center[] =
+{
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x2E, 0xB1, 0xDB, 0x00, 0x2E, 0xB1, 0xDB, 0x00,
+	0x2E, 0xB1, 0xDB, 0x00, 0x2E, 0xB1, 0xDB, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00
+};
+
+static unsigned char anycall_progress_bar[] =
+{
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00,
+	0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00, 0x33, 0x33, 0x33, 0x00
+};
+
+static void s3cfb_start_progress(struct fb_info *fb);
+static void s3cfb_stop_progress(void);
+static void progress_timer_handler(unsigned long data);
+
+static int show_progress = 1;
+module_param_named(progress, show_progress, bool, 0);
+extern unsigned int is_lpcharging_state(void);
+#endif
+
+extern unsigned int sec_debug_is_recovery_mode(void);
+
+#if 1
+/* convert RGB565 to RBG8888 */
+static void memset16_rgb8888(void *_ptr, unsigned short val, unsigned count)
+{
+	unsigned short *ptr = _ptr;
+	unsigned short red; 
+	unsigned short green;
+	unsigned short blue;
+	
+	red = ( val & 0xF800) >> 8;
+	green = (val & 0x7E0) >> 3;
+	blue = (val & 0x1F) << 3;
+
+	count >>= 1;
+	while (count--)
+	{
+		*ptr++ = (red<<8) | green;
+		*ptr++ = blue;
+	}
+}
+
+int load_565rle_image(char *filename, bool bf_supported)
+{
+	int fd, err = 0;
+	unsigned count, max;
+	unsigned short *data, *bits, *ptr;
+	struct fb_info *info;
+#ifndef CONFIG_FRAMEBUFFER_CONSOLE 
+	struct module *owner; 
+#endif 	
+	info = registered_fb[0];
+	
+	if (!info) {
+		printk(KERN_WARNING "%s: Can not access framebuffer\n",
+			__func__);
+		return -ENODEV;
+	}
+#ifndef CONFIG_FRAMEBUFFER_CONSOLE 
+	owner = info->fbops->owner; 
+	if (!try_module_get(owner)) 
+		return NULL; 
+	if (info->fbops->fb_open && info->fbops->fb_open(info, 0)) { 
+		module_put(owner); 
+		return NULL; 
+	}
+#endif
+	fd = sys_open(filename, O_RDONLY, 0);
+	if (fd < 0) {
+		printk(KERN_WARNING "%s: Can not open %s\n",
+			__func__, filename);
+		return -ENOENT;
+	}
+printk("%s: open OK! %s\n",__func__, filename);
+	count = (unsigned)sys_lseek(fd, (off_t)0, 2);
+	if (count == 0) {
+		sys_close(fd);
+		err = -EIO;
+		goto err_logo_close_file;
+	}
+printk("%s: count %d\n",__func__, count);    
+	sys_lseek(fd, (off_t)0, 0);
+	data = kmalloc(count, GFP_KERNEL);
+	if (!data) {
+		printk(KERN_WARNING "%s: Can not alloc data\n", __func__);
+		err = -ENOMEM;
+		goto err_logo_close_file;
+	}
+	if ((unsigned)sys_read(fd, (char *)data, count) != count) {
+		err = -EIO;
+		goto err_logo_free_data;
+	}
+
+	max = fb_width(info) * fb_height(info);
+
+	ptr = data;
+	bits = (unsigned short *)(info->screen_base);
+printk("%s: max %d, n %d 0x%x\n",__func__, max, ptr[0], (unsigned int)bits);
+	while (count > 3) {
+		unsigned n = ptr[0];
+		if (n > max)
+			break;
+
+		memset16_rgb8888(bits, ptr[1], n << 1);
+		bits += n*2; // for rgb8888
+		max -= n;
+		ptr += 2;
+		count -= 4;
+	}
+#if !defined (CONFIG_USA_OPERATOR_ATT) && !defined (CONFIG_JPN_MODEL_SC_03D) && !defined (CONFIG_CAN_OPERATOR_RWC)
+	if (!is_lpcharging_state() && !sec_debug_is_recovery_mode())
+		s3cfb_start_progress(info);
+#endif
+
+err_logo_free_data:
+	kfree(data);
+err_logo_close_file:
+	sys_close(fd);
+	return err;
+}
+#else
+
 static void memset16(void *_ptr, unsigned short val, unsigned count)
 {
 	unsigned short *ptr = _ptr;
@@ -100,4 +282,152 @@
 	sys_close(fd);
 	return err;
 }
+#endif
+
+#ifdef DISPLAY_BOOT_PROGRESS
+static void s3cfb_update_framebuffer(struct fb_info *fb,
+									int x, int y, void *buffer, 
+									int src_width, int src_height)
+{
+//	struct s3cfb_global *fbdev =
+//			platform_get_drvdata(to_platform_device(fb->device));
+//	struct s3c_platform_fb *pdata = to_fb_plat(fbdev->dev);
+	struct fb_fix_screeninfo *fix = &fb->fix;
+	struct fb_var_screeninfo *var = &fb->var;
+	int row;
+	int bytes_per_pixel = (var->bits_per_pixel / 8 );
+	
+	unsigned char *pSrc = buffer;
+	unsigned char *pDst = fb->screen_base;
+
+	if (x+src_width > var->xres || y+src_height > var->yres)
+	{
+		printk("invalid destination coordinate or source size (%d, %d) (%d %d) \n", x, y, src_width, src_height);
+		return;
+	}	
+
+	pDst += y * fix->line_length + x * bytes_per_pixel;	
+
+	for (row = 0; row < src_height ; row++)	
+	{		
+		memcpy(pDst, pSrc, src_width * bytes_per_pixel);
+		flush_cache_all();
+		pSrc += src_width * bytes_per_pixel;
+		pDst += fix->line_length;
+	}
+ }
+
+
+/*
+if Updated-pixel is overwrited by other color, progressbar-Update Stop.
+return value : TRUE(update), FALSE(STOP)
+*/
+static int s3cfb_check_progress(struct fb_info *fb, const int progress_pos, int width)
+{
+	unsigned char *pDst = fb->screen_base;
+	struct fb_fix_screeninfo *fix = &fb->fix;
+	struct fb_var_screeninfo *var = &fb->var;
+	int bytes_per_pixel = (var->bits_per_pixel / 8);
+	int x = PROGRESS_BAR_LEFT_POS;
+	int y = PROGRESS_BAR_START_Y;
+
+	if (progress_pos + width >= PROGRESS_BAR_RIGHT_POS)
+		return 0;
+
+	pDst += y * fix->line_length + x * bytes_per_pixel;
+	if (*pDst == anycall_progress_bar_left[0])
+		return 1;
+	else
+		return 0;
+}
+
+static void s3cfb_start_progress(struct fb_info *fb)
+{	
+	int x_pos;
+	init_timer(&progress_timer);	
+	
+	progress_timer.expires  = (get_jiffies_64() + (HZ/10));	
+	progress_timer.data     = (long)fb;	
+	progress_timer.function = progress_timer_handler;	
+	progress_pos = PROGRESS_BAR_LEFT_POS;	
+	
+	// draw progress background.
+	for (x_pos = PROGRESS_BAR_LEFT_POS ; x_pos <= PROGRESS_BAR_RIGHT_POS ; x_pos += PROGRESS_BAR_WIDTH)
+	{
+		s3cfb_update_framebuffer(fb,
+			x_pos,
+			PROGRESS_BAR_START_Y,
+			(void*)anycall_progress_bar,					
+			PROGRESS_BAR_WIDTH,
+			PROGRESS_BAR_HEIGHT);
+	}
+
+	s3cfb_update_framebuffer(fb,
+		PROGRESS_BAR_LEFT_POS,
+		PROGRESS_BAR_START_Y,
+		(void*)anycall_progress_bar_left,					
+		PROGRESS_BAR_WIDTH,
+		PROGRESS_BAR_HEIGHT);
+	
+	progress_pos += PROGRESS_BAR_WIDTH;	
+	
+	s3cfb_update_framebuffer(fb,		
+		progress_pos,
+		PROGRESS_BAR_START_Y,		
+		(void*)anycall_progress_bar_right,				
+		PROGRESS_BAR_WIDTH,
+		PROGRESS_BAR_HEIGHT);
+	
+	add_timer(&progress_timer);	
+	progress_flag = 1;
+
+}
+
+static void s3cfb_stop_progress(void)
+{	
+	if (progress_flag == 0)		
+		return;	
+	del_timer(&progress_timer);	
+	progress_flag = 0;
+}
+
+#ifdef CONFIG_FB_MSM_MIPI_S6E8AA0_HD720_PANEL
+#define CENTERBAR_WIDTH 12
+#elif defined(CONFIG_FB_MSM_MIPI_S6E8AA0_WXGA_Q1_PANEL)
+#define CENTERBAR_WIDTH 12
+#else
+#define CENTERBAR_WIDTH 10
+#endif
+static void progress_timer_handler(unsigned long data)
+{	
+	int i;	
+
+	if (s3cfb_check_progress((struct fb_info *)data, progress_pos, CENTERBAR_WIDTH)) {	
+		for(i = 0; i < CENTERBAR_WIDTH; i++)	
+		{		
+			s3cfb_update_framebuffer((struct fb_info *)data,
+				progress_pos++,
+				PROGRESS_BAR_START_Y,
+				(void*)anycall_progress_bar_center,					
+				1,
+				PROGRESS_BAR_HEIGHT);	
+		}	
+	
+		s3cfb_update_framebuffer((struct fb_info *)data,		
+			progress_pos,
+			PROGRESS_BAR_START_Y,
+			(void*)anycall_progress_bar_right,		
+			PROGRESS_BAR_WIDTH,
+			PROGRESS_BAR_HEIGHT);
+		
+			progress_timer.expires = (get_jiffies_64() + (HZ/14));         
+			progress_timer.function = progress_timer_handler;         
+			add_timer(&progress_timer);    
+	} else
+		s3cfb_stop_progress();
+
+}
+
+EXPORT_SYMBOL(s3cfb_start_progress);
+#endif
 EXPORT_SYMBOL(load_565rle_image);
Only in msm: logo_tablet.c
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/Makefile msm/Makefile
--- /home/shade/kernel-msm/drivers/video/msm/Makefile	2012-08-20 15:40:52.999119039 -0700
+++ msm/Makefile	2012-08-17 10:16:29.555174046 -0700
@@ -1,10 +1,12 @@
 obj-y := msm_fb.o
 
+ifeq ($(CONFIG_SAMSUNG_8X60_TABLET),y)
+obj-$(CONFIG_FB_MSM_LOGO) += logo_tablet.o
+else
 obj-$(CONFIG_FB_MSM_LOGO) += logo.o
+endif
 obj-$(CONFIG_FB_BACKLIGHT) += msm_fb_bl.o
 
-ifeq ($(CONFIG_FB_MSM_MDP_HW),y)
-
 # MDP
 obj-y += mdp.o
 
@@ -12,6 +14,9 @@
 
 ifeq ($(CONFIG_FB_MSM_MDP40),y)
 obj-y += mdp4_util.o
+ifneq ($(CONFIG_SAMSUNG_8X60_TABLET),y)
+obj-y += mdp4_video_enhance.o
+endif
 obj-y += mdp4_hsic.o
 else
 obj-y += mdp_hw_init.o
@@ -71,12 +76,27 @@
 obj-$(CONFIG_FB_MSM_MIPI_DSI) += msm_mipi.o
 
 # MIPI manufacture
+obj-$(CONFIG_FB_MSM_MIPI_DSI_SAMSUNG) += mipi_samsung.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_TOSHIBA) += mipi_toshiba.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_NOVATEK) += mipi_novatek.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_ORISE) += mipi_orise.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_RENESAS) += mipi_renesas.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_TRULY) += mipi_truly.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_SIMULATOR) += mipi_simulator.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_S6D6AA0_WXGA) += mipi_s6d6aa0_wxga.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_S6E8AA0_WXGA_Q1) += mipi_s6e8aa0_wxga_q1.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_S6E8AA0_WXGA_Q1) += smart_dimming.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_S6E8AA0_HD720) += mipi_s6e8aa0_hd720.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_S6E8AA0_HD720) += smart_dimming.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_S6E8AA0_WXGA) += mipi_s6e8aa0_wxga.o
+ifeq ($(CONFIG_CMC624_P8LTE),y)
+obj-$(CONFIG_FB_MSM_MIPI_DSI_ESD_REFRESH) += sec_mipi_lcd_esd_refresh_p8.o sec_cmc_esd_refresh_p8.o
+else
+obj-$(CONFIG_FB_MSM_MIPI_DSI_ESD_REFRESH) += sec_mipi_lcd_esd_refresh.o
+endif
+obj-$(CONFIG_FB_MSM_MIPI_DSI_S6E8AB0_WXGA) += mipi_s6e8ab0_wxga.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_S6E8AB0_WXGA) += smart_dimming_s6e8ab0.o
+
 
 # MIPI Bridge
 obj-$(CONFIG_FB_MSM_MIPI_DSI_TC358764_DSI2LVDS) += mipi_tc358764_dsi2lvds.o
@@ -118,9 +138,9 @@
 obj-y += mipi_orise_video_720p_pt.o mipi_orise_cmd_720p_pt.o
 obj-y += mipi_renesas_video_fwvga_pt.o mipi_renesas_cmd_fwvga_pt.o
 obj-y += mipi_chimei_wxga_pt.o
-obj-y += mipi_chimei_wuxga.o
 obj-y += mipi_truly_video_wvga_pt.o
 else
+obj-$(CONFIG_FB_MSM_MIPI_SAMSUNG_VIDEO_WVGA) += mipi_samsung_video_wvga.o
 obj-$(CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT) += mipi_toshiba_video_wvga_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT) += mipi_toshiba_video_wsvga_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WUXGA) += mipi_toshiba_video_wuxga.o
@@ -133,10 +153,21 @@
 obj-$(CONFIG_FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT) += mipi_truly_video_wvga_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_SIMULATOR_VIDEO) += mipi_simulator_video.o
 obj-$(CONFIG_FB_MSM_MIPI_CHIMEI_WXGA) += mipi_chimei_wxga_pt.o
-obj-$(CONFIG_FB_MSM_MIPI_CHIMEI_WUXGA) += mipi_chimei_wuxga.o
+obj-$(CONFIG_FB_MSM_MIPI_S6D6AA0_WXGA_PT) += mipi_s6d6aa0_wxga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_S6E8AA0_HD720_PT) += mipi_s6e8aa0_hd720_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_S6E8AA0_WXGA_Q1_PT) += mipi_s6e8aa0_wxga_q1_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_S6E8AB0_WXGA_PT) += mipi_s6e8ab0_wxga_pt.o
 endif
 
 obj-$(CONFIG_FB_MSM_LCDC_PANEL) += lcdc_panel.o
+obj-$(CONFIG_FB_MSM_LCDC_P5LTE_WXGA) += lcdc_pxlte.o
+obj-$(CONFIG_CMC623_P5LTE) += pxlte_cmc623.o cmc623_sysfs.o
+obj-$(CONFIG_CMC624_P8LTE) += pxlte_cmc624.o cmc624_sysfs.o 
+obj-$(CONFIG_FB_MSM_LCDC_LD9040_WVGA) += lcdc_ld9040.o
+obj-$(CONFIG_FB_MSM_LCDC_LD9040_WVGA) += smart_dimming_ea8868.o
+obj-$(CONFIG_FB_MSM_LCDC_S6E63M0_WVGA) += lcdc_S6E63M0.o
+obj-$(CONFIG_USA_MODEL_SGH_T769) += smart_mtp_s6e63m0.o
+obj-$(CONFIG_USA_MODEL_SGH_I577) += smart_mtp_s6e63m0.o
 obj-$(CONFIG_FB_MSM_LCDC_PRISM_WVGA) += lcdc_prism.o
 obj-$(CONFIG_FB_MSM_LCDC_SAMSUNG_WSVGA) += lcdc_samsung_wsvga.o
 obj-$(CONFIG_FB_MSM_LCDC_CHIMEI_WXGA) += lcdc_chimei_wxga.o
@@ -165,12 +196,8 @@
 
 obj-$(CONFIG_MSM_VIDC_1080P) += vidc/
 obj-$(CONFIG_MSM_VIDC_720P) += vidc/
-else
-obj-$(CONFIG_FB_MSM_EBI2) += ebi2_host.o
-obj-$(CONFIG_FB_MSM_EBI2) += ebi2_lcd.o
-obj-y += msm_fb_panel.o
-obj-$(CONFIG_FB_MSM_EBI2_EPSON_S1D_QVGA_PANEL) += ebi2_epson_s1d_qvga.o
-endif
+obj-$(CONFIG_VIDEO_MHL_V1) += mhl_v1/
+obj-$(CONFIG_VIDEO_MHL_V2) += mhl_v2/
 
 clean:
 	rm *.o .*cmd
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mdp4.h msm/mdp4.h
--- /home/shade/kernel-msm/drivers/video/msm/mdp4.h	2012-08-20 15:40:53.032119037 -0700
+++ msm/mdp4.h	2012-08-20 15:29:28.127165872 -0700
@@ -459,6 +459,8 @@
 void mdp4_clear_lcdc(void);
 void mdp4_mixer_blend_init(int mixer_num);
 void mdp4_vg_qseed_init(int vg_num);
+void mdp4_vg_qseed_init_DMB(int vg_num);
+void mdp4_vg_qseed_init_VideoPlay(int vg_num);
 void mdp4_vg_csc_setup(int vp_num);
 void mdp4_mixer_csc_setup(uint32 mixer);
 void mdp4_dmap_csc_setup(void);
@@ -709,6 +711,12 @@
 static inline void mdp4_dsi_video_blt_stop(struct msm_fb_data_type *mfd)
 {
 }
+static inline void mdp4_dsi_cmd_blt_start(struct msm_fb_data_type *mfd)
+{
+}
+static inline void mdp4_dsi_cmd_blt_stop(struct msm_fb_data_type *mfd)
+{
+}
 static inline void mdp4_dsi_overlay_blt(
 	struct msm_fb_data_type *mfd, struct msmfb_overlay_blt *req)
 {
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mdp4_overlay.c msm/mdp4_overlay.c
--- /home/shade/kernel-msm/drivers/video/msm/mdp4_overlay.c	2012-08-20 15:41:33.594116263 -0700
+++ msm/mdp4_overlay.c	2012-08-20 13:48:45.526579065 -0700
@@ -344,6 +344,10 @@
 	return ctrl->panel_mode;
 }
 
+#ifdef HDMI_VIDEO_QUANTIZATION_ISSUE
+extern void video_quantization_setting(void);
+#endif
+
 void mdp4_overlay_cfg_init(void)
 {
 	if (ctrl->hw_version == 0) {
@@ -402,10 +406,16 @@
 		MDP_OUTP(MDP_BASE + 0xb3014, 0x1000080);
 		MDP_OUTP(MDP_BASE + 0xb4004, 0x67686970);
 	} else {
+#ifdef CONFIG_FB_MSM_EXT_INTERFACE_COMMON
 		mdp_vid_quant_set();
+#endif
+#ifdef HDMI_VIDEO_QUANTIZATION_ISSUE
+		video_quantization_setting();
+#else
 		MDP_OUTP(MDP_BASE + 0xb0070, 0xff0000);
 		MDP_OUTP(MDP_BASE + 0xb0074, 0xff0000);
 		MDP_OUTP(MDP_BASE + 0xb0078, 0xff0000);
+#endif
 	}
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
@@ -1860,7 +1870,13 @@
 		op_mode &= ~(MDP4_OP_FLIP_UD + MDP4_OP_SCALEY_EN);
 		outpdw(base + 0x0058, op_mode);
 		outpdw(base + 0x1008, 0);	/* black */
+		/*
+		 * Set src size and dst size same to avoid underruns
+		 */
+		outpdw(base + 0x0000, inpdw(base + 0x0008));
 	} else {
+		u32 src_size = ((pipe->src_h << 16) | pipe->src_w);
+		outpdw(base + 0x0000, src_size);
 		format &= ~MDP4_FORMAT_SOLID_FILL;
 		blend->solidfill_pipe = NULL;
 	}
Only in /home/shade/kernel-msm/drivers/video/msm: .mdp4_overlay.c.swp
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mdp4_overlay_dsi_video.c msm/mdp4_overlay_dsi_video.c
--- /home/shade/kernel-msm/drivers/video/msm/mdp4_overlay_dsi_video.c	2012-08-20 15:41:33.594116263 -0700
+++ msm/mdp4_overlay_dsi_video.c	2012-08-20 13:48:45.520579065 -0700
@@ -534,6 +534,8 @@
 	pipe->src_w = fbi->var.xres;
 	pipe->src_y = 0;
 	pipe->src_x = 0;
+	pipe->dst_h = fbi->var.yres;
+	pipe->dst_w = fbi->var.xres;
 	pipe->srcp0_ystride = fbi->fix.line_length;
 	pipe->bpp = bpp;
 
Only in /home/shade/kernel-msm/drivers/video/msm: .mdp4_overlay_dsi_video.c.swp
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mdp4_overlay_lcdc.c msm/mdp4_overlay_lcdc.c
--- /home/shade/kernel-msm/drivers/video/msm/mdp4_overlay_lcdc.c	2012-08-20 15:41:33.595116264 -0700
+++ msm/mdp4_overlay_lcdc.c	2012-08-20 13:49:18.469576812 -0700
@@ -32,6 +32,8 @@
 #include "mdp.h"
 #include "msm_fb.h"
 #include "mdp4.h"
+#include <mach/sec_debug.h>
+#include <asm/cacheflush.h>
 
 #ifdef CONFIG_FB_MSM_MDP40
 #define LCDC_BASE	0xC0000
@@ -548,6 +550,12 @@
 	lcdc_underflow_clr = mfd->panel_info.lcdc.underflow_clr;
 	lcdc_hsync_skew = mfd->panel_info.lcdc.hsync_skew;
 
+	pr_info("%s: <ID=%d %dx%d (%d,%d,%d), (%d,%d,%d) %dMHz>\n", __func__,
+		var->reserved[3], var->xres, var->yres,
+		var->right_margin, var->hsync_len, var->left_margin,
+		var->lower_margin, var->vsync_len, var->upper_margin,
+		var->pixclock/1000/1000);
+
 	lcdc_width = var->xres + mfd->panel_info.lcdc.xres_pad;
 	lcdc_height = var->yres + mfd->panel_info.lcdc.yres_pad;
 	lcdc_bpp = mfd->panel_info.bpp;
@@ -595,7 +603,11 @@
 	hsync_polarity = 0;
 	vsync_polarity = 0;
 #endif
+#ifdef CONFIG_SAMSUNG_8X60_TABLET
 	data_en_polarity = 0;
+#else
+	data_en_polarity = 1;
+#endif
 
 	ctrl_polarity =
 	    (data_en_polarity << 2) | (vsync_polarity << 1) | (hsync_polarity);
@@ -804,6 +816,7 @@
 
 static void mdp4_lcdc_do_blt(struct msm_fb_data_type *mfd, int enable)
 {
+	static int porch_value_read = 0;
 	unsigned long flag;
 	int cndx = 0;
 	struct vsycn_ctrl *vctrl;
Only in /home/shade/kernel-msm/drivers/video/msm: .mdp4_overlay_lcdc.c.swp
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mdp4_overlay_mddi.c msm/mdp4_overlay_mddi.c
--- /home/shade/kernel-msm/drivers/video/msm/mdp4_overlay_mddi.c	2012-08-20 15:40:53.057119036 -0700
+++ msm/mdp4_overlay_mddi.c	2012-08-17 10:16:29.660174039 -0700
@@ -163,7 +163,8 @@
 
 		MDP_OUTP(MDP_BASE + 0x00098, 0x01);
 		mdp4_init_writeback_buf(mfd, MDP4_MIXER0);
-		pipe->blt_addr = 0;
+		pipe->ov_blt_addr = 0;
+		pipe->dma_blt_addr = 0;
 	} else {
 		pipe = mddi_pipe;
 	}
@@ -254,23 +255,25 @@
 	unsigned long flag;
 
 	pr_debug("%s: blt_end=%d blt_addr=%x pid=%d\n",
-	__func__, mddi_pipe->blt_end, (int)mddi_pipe->blt_addr, current->pid);
+		__func__, mddi_pipe->blt_end,
+		(int)mddi_pipe->ov_blt_addr, current->pid);
 
 	mdp4_allocate_writeback_buf(mfd, MDP4_MIXER0);
 
-	if (mfd->ov0_wb_buf->phys_addr == 0) {
+	if (mfd->ov0_wb_buf->write_addr == 0) {
 		pr_info("%s: no blt_base assigned\n", __func__);
 		return -EBUSY;
 	}
 
-	if (mddi_pipe->blt_addr == 0) {
+	if (mddi_pipe->ov_blt_addr == 0) {
 		mdp4_mddi_dma_busy_wait(mfd);
 		spin_lock_irqsave(&mdp_spin_lock, flag);
 		mddi_pipe->blt_end = 0;
 		mddi_pipe->blt_cnt = 0;
 		mddi_pipe->ov_cnt = 0;
 		mddi_pipe->dmap_cnt = 0;
-		mddi_pipe->blt_addr = mfd->ov0_wb_buf->phys_addr;
+		mddi_pipe->ov_blt_addr = mfd->ov0_wb_buf->write_addr;
+		mddi_pipe->dma_blt_addr = mfd->ov0_wb_buf->write_addr;
 		mdp4_stat.blt_mddi++;
 		spin_unlock_irqrestore(&mdp_spin_lock, flag);
 	return 0;
@@ -284,9 +287,9 @@
 	unsigned long flag;
 
 	pr_debug("%s: blt_end=%d blt_addr=%x\n",
-		 __func__, mddi_pipe->blt_end, (int)mddi_pipe->blt_addr);
+		 __func__, mddi_pipe->blt_end, (int)mddi_pipe->ov_blt_addr);
 
-	if ((mddi_pipe->blt_end == 0) && mddi_pipe->blt_addr) {
+	if ((mddi_pipe->blt_end == 0) && mddi_pipe->ov_blt_addr) {
 		spin_lock_irqsave(&mdp_spin_lock, flag);
 		mddi_pipe->blt_end = 1;	/* mark as end */
 		spin_unlock_irqrestore(&mdp_spin_lock, flag);
@@ -323,7 +326,7 @@
 	int bpp;
 	char *overlay_base;
 
-	if (pipe->blt_addr == 0)
+	if (pipe->ov_blt_addr == 0)
 		return;
 
 
@@ -336,7 +339,7 @@
 	if (pipe->dmap_cnt & 0x01)
 		off = pipe->src_height * pipe->src_width * bpp;
 
-	addr = pipe->blt_addr + off;
+	addr = pipe->ov_blt_addr + off;
 
 	/* dmap */
 	MDP_OUTP(MDP_BASE + 0x90008, addr);
@@ -344,7 +347,7 @@
 	off = 0;
 	if (pipe->ov_cnt & 0x01)
 		off = pipe->src_height * pipe->src_width * bpp;
-	addr2 = pipe->blt_addr + off;
+	addr2 = pipe->ov_blt_addr + off;
 	/* overlay 0 */
 	overlay_base = MDP_BASE + MDP4_OVERLAYPROC0_BASE;/* 0x10000 */
 	outpdw(overlay_base + 0x000c, addr2);
@@ -375,7 +378,8 @@
 
 		if (mddi_pipe->blt_end) {
 			mddi_pipe->blt_end = 0;
-			mddi_pipe->blt_addr = 0;
+			mddi_pipe->ov_blt_addr = 0;
+			mddi_pipe->dma_blt_addr = 0;
 			pr_debug("%s: END, ov_cnt=%d dmap_cnt=%d\n", __func__,
 				mddi_pipe->ov_cnt, mddi_pipe->dmap_cnt);
 			mdp_intr_mask &= ~INTR_DMA_P_DONE;
@@ -410,7 +414,7 @@
 {
 	int diff;
 
-	if (mddi_pipe->blt_addr == 0) {
+	if (mddi_pipe->ov_blt_addr == 0) {
 		mdp_pipe_ctrl(MDP_OVERLAY0_BLOCK, MDP_BLOCK_POWER_OFF, TRUE);
 		spin_lock(&mdp_spin_lock);
 		dma->busy = FALSE;
@@ -477,7 +481,7 @@
 		mdp4_mddi_dma_busy_wait(mddi_mfd);
 		mdp4_overlay_update_lcd(mddi_mfd);
 
-		if (mddi_pipe->blt_addr)
+		if (mddi_pipe->ov_blt_addr)
 			mdp4_mddi_blt_dmap_busy_wait(mddi_mfd);
 		mdp4_mddi_overlay_kickoff(mddi_mfd, mddi_pipe);
 		mddi_mfd->dma_update_flag = 1;
@@ -543,17 +547,17 @@
 	 * to be called before kickoff.
 	 * vice versa for blt disabled.
 	 */
-	if (mddi_pipe->blt_addr && mddi_pipe->blt_cnt == 0)
+	if (mddi_pipe->ov_blt_addr && mddi_pipe->blt_cnt == 0)
 		mdp4_overlay_update_lcd(mfd); /* first time */
-	else if (mddi_pipe->blt_addr == 0  && mddi_pipe->blt_cnt) {
+	else if (mddi_pipe->ov_blt_addr == 0  && mddi_pipe->blt_cnt) {
 		mdp4_overlay_update_lcd(mfd); /* last time */
 		mddi_pipe->blt_cnt = 0;
 	}
 
 	pr_debug("%s: blt_addr=%d blt_cnt=%d\n",
-		__func__, (int)mddi_pipe->blt_addr, mddi_pipe->blt_cnt);
+		__func__, (int)mddi_pipe->ov_blt_addr, mddi_pipe->blt_cnt);
 
-	if (mddi_pipe->blt_addr)
+	if (mddi_pipe->ov_blt_addr)
 		mdp4_mddi_blt_dmap_busy_wait(mddi_mfd);
 	mdp4_mddi_overlay_kickoff(mfd, pipe);
 }
@@ -571,31 +575,10 @@
 {
 	unsigned long flag;
 
-	if (mdp_hw_revision == MDP4_REVISION_V2_1) {
-		if (mdp4_overlay_status_read(MDP4_OVERLAY_TYPE_UNSET)) {
-			uint32  data;
-			data = inpdw(MDP_BASE + 0x0028);
-			data &= ~0x0300;        /* bit 8, 9, MASTER4 */
-			if (mfd->fbi->var.xres == 540) /* qHD, 540x960 */
-				data |= 0x0200;
-			else
-				data |= 0x0100;
-			MDP_OUTP(MDP_BASE + 0x00028, data);
-			mdp4_overlay_status_write(MDP4_OVERLAY_TYPE_UNSET,
-				false);
-		}
-		if (mdp4_overlay_status_read(MDP4_OVERLAY_TYPE_SET)) {
-			uint32  data;
-			data = inpdw(MDP_BASE + 0x0028);
-			data &= ~0x0300;        /* bit 8, 9, MASTER4 */
-			MDP_OUTP(MDP_BASE + 0x00028, data);
-			mdp4_overlay_status_write(MDP4_OVERLAY_TYPE_SET, false);
-		}
-	}
 	mdp_enable_irq(MDP_OVERLAY0_TERM);
 	spin_lock_irqsave(&mdp_spin_lock, flag);
 	mfd->dma->busy = TRUE;
-	if (mddi_pipe->blt_addr)
+	if (mddi_pipe->ov_blt_addr)
 		mfd->dma->dmap_busy = TRUE;
 	spin_unlock_irqrestore(&mdp_spin_lock, flag);
 	/* start OVERLAY pipe */
@@ -677,7 +660,7 @@
 {
 	mdp_enable_irq(MDP_DMA_S_TERM);
 
-	if (mddi_pipe->blt_addr == 0)
+	if (mddi_pipe->ov_blt_addr == 0)
 		mfd->dma->busy = TRUE;
 
 	mfd->ibuf_flushed = TRUE;
@@ -708,7 +691,7 @@
 	if (mfd && mfd->panel_power_on) {
 		mdp4_mddi_dma_busy_wait(mfd);
 
-		if (mddi_pipe && mddi_pipe->blt_addr)
+		if (mddi_pipe && mddi_pipe->ov_blt_addr)
 			mdp4_mddi_blt_dmap_busy_wait(mfd);
 		mdp4_overlay_mdp_perf_upd(mfd, 0);
 		mdp4_overlay_update_lcd(mfd);
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mdp4_util.c msm/mdp4_util.c
--- /home/shade/kernel-msm/drivers/video/msm/mdp4_util.c	2012-08-20 15:40:53.058119036 -0700
+++ msm/mdp4_util.c	2012-08-17 10:16:29.698174037 -0700
@@ -33,6 +33,12 @@
 #include "msm_fb.h"
 #include "mdp4.h"
 
+#ifdef CONFIG_FB_MSM_MIPI_DSI_ESD_REFRESH
+#include "mipi_dsi.h" // for 
+extern int	use_vsyncLPmode;
+uint32 dsi_lane_ctrl;
+#endif 
+
 struct mdp4_statistic mdp4_stat;
 
 unsigned is_mdp4_hw_reset(void)
@@ -213,6 +219,10 @@
 	/* MDP cmd block enable */
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 
+#if defined (CONFIG_FB_MSM_MIPI_S6E8AA0_HD720_PANEL) // kyNam_110920_ Fix Problem : sometimes flicking while Camera-preview 
+	dmap_data = 0x47; /* 16 bytes-burst x 8 req */ 
+	vg_data = 0x47; /* 16 bytes-burs x 8 req */ 
+#else // src
 	if (mdp_rev >= MDP_REV_41 || core_clk >= 90000000) { /* 90 Mhz */
 		dmap_data = 0x47; /* 16 bytes-burst x 8 req */
 		vg_data = 0x47; /* 16 bytes-burs x 8 req */
@@ -220,6 +230,8 @@
 		dmap_data = 0x27; /* 8 bytes-burst x 8 req */
 		vg_data = 0x43; /* 16 bytes-burst x 4 req */
 	}
+#endif 
+
 
 	MSM_FB_DEBUG("mdp4_fetch_cfg: dmap=%x vg=%x\n",
 			dmap_data, vg_data);
@@ -437,6 +449,22 @@
 			complete(&dma->comp);
 		}
 #endif
+
+#ifdef CONFIG_FB_MSM_MIPI_DSI_ESD_REFRESH
+		// It make LP-mode between frame-to-frame.
+		// When LCD lost mipi-clock-signal because of ESD, LPmode make LCD to refresh clock.
+		// It is from SMD-recommand.
+		// but, while it is activated, system became slow.
+		if( use_vsyncLPmode )
+		{
+			dsi_lane_ctrl = MIPI_INP(MIPI_DSI_BASE + 0x00A8);
+			MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x14000000); // lp
+			MIPI_OUTP( MIPI_DSI_BASE + 0x00A8, dsi_lane_ctrl &0x0FFFFFFF );
+			// usleep(3); // spec : under 10us 
+			MIPI_OUTP( MIPI_DSI_BASE + 0x00A8, dsi_lane_ctrl );
+			MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x10000000); // hs
+		}
+#endif 	
 	}
 	if (isr & INTR_DMA_S_DONE) {
 		mdp4_stat.intr_dma_s++;
@@ -576,6 +604,521 @@
 };
 
 static uint32 vg_qseed_table2[] = {
+	0x02000000, 0x00000000, 0x02060ff2, 0x00000008,
+	0x02090fe4, 0x00000013, 0x020a0fd9, 0x0ffc0021,
+	0x02080fce, 0x0ffa0030, 0x02030fc5, 0x0ff60042,
+	0x01fd0fbe, 0x0ff10054, 0x01f50fb6, 0x0fed0068,
+	0x01e90fb1, 0x0fe60080, 0x01dc0fae, 0x0fe10095,
+	0x01ca0fae, 0x0fda00ae, 0x01b70fad, 0x0fd600c6,
+	0x01a40fad, 0x0fcf00e0, 0x018f0faf, 0x0fc800fa,
+	0x01780fb1, 0x0fc30114, 0x015f0fb5, 0x0fbf012d,
+	0x01490fb7, 0x0fb70149, 0x012d0fbf, 0x0fb5015f,
+	0x01140fc3, 0x0fb10178, 0x00fa0fc8, 0x0faf018f,
+	0x00e00fcf, 0x0fad01a4, 0x00c60fd6, 0x0fad01b7,
+	0x00ae0fda, 0x0fae01ca, 0x00950fe1, 0x0fae01dc,
+	0x00800fe6, 0x0fb101e9, 0x00680fed, 0x0fb601f5,
+	0x00540ff1, 0x0fbe01fd, 0x00420ff6, 0x0fc50203,
+	0x00300ffa, 0x0fce0208, 0x00210ffc, 0x0fd9020a,
+	0x00130000, 0x0fe40209, 0x00080000, 0x0ff20206,
+	0x02000000, 0x00000000, 0x02040ff2, 0x0000000a,
+	0x02040fe4, 0x00000018, 0x02010fda, 0x0ffc0029,
+	0x01fc0fcf, 0x0ffa003b, 0x01f30fc7, 0x0ff60050,
+	0x01e90fc0, 0x0ff20065, 0x01dc0fba, 0x0fee007c,
+	0x01cc0fb6, 0x0fe80096, 0x01ba0fb4, 0x0fe400ae,
+	0x01a70fb4, 0x0fdd00c8, 0x018f0fb5, 0x0fda00e2,
+	0x017a0fb5, 0x0fd400fd, 0x01630fb8, 0x0fce0117,
+	0x014c0fba, 0x0fca0130, 0x01320fbf, 0x0fc70148,
+	0x011b0fc1, 0x0fc10163, 0x01010fc8, 0x0fc00177,
+	0x00e90fcd, 0x0fbd018d, 0x00d10fd1, 0x0fbc01a2,
+	0x00ba0fd7, 0x0fbb01b4, 0x00a30fdd, 0x0fbc01c4,
+	0x008e0fe1, 0x0fbd01d4, 0x00790fe7, 0x0fbe01e2,
+	0x00670feb, 0x0fc001ee, 0x00540ff1, 0x0fc501f6,
+	0x00430ff4, 0x0fcb01fe, 0x00340ff8, 0x0fd10203,
+	0x00260ffb, 0x0fd80207, 0x001a0ffd, 0x0fe10208,
+	0x000f0000, 0x0fea0207, 0x00060000, 0x0ff50205,
+	0x02000000, 0x00000000, 0x02020ff2, 0x0000000c,
+	0x02000fe4, 0x0000001c, 0x01fa0fda, 0x0ffc0030,
+	0x01f10fd0, 0x0ffa0045, 0x01e50fc8, 0x0ff6005d,
+	0x01d60fc3, 0x0ff30074, 0x01c60fbd, 0x0fef008e,
+	0x01b30fba, 0x0fe900aa, 0x019e0fb9, 0x0fe500c4,
+	0x01870fba, 0x0fe000df, 0x016f0fbb, 0x0fdd00f9,
+	0x01580fbc, 0x0fd80114, 0x01400fbf, 0x0fd3012e,
+	0x01280fc2, 0x0fd00146, 0x010f0fc6, 0x0fce015d,
+	0x00f90fc9, 0x0fc90175, 0x00e00fcf, 0x0fc90188,
+	0x00ca0fd4, 0x0fc6019c, 0x00b40fd8, 0x0fc601ae,
+	0x009f0fdd, 0x0fc501bf, 0x008b0fe3, 0x0fc601cc,
+	0x00780fe6, 0x0fc701db, 0x00660feb, 0x0fc801e7,
+	0x00560fef, 0x0fcb01f0, 0x00460ff3, 0x0fcf01f8,
+	0x00380ff6, 0x0fd401fe, 0x002c0ff9, 0x0fd90202,
+	0x00200ffc, 0x0fdf0205, 0x00160ffe, 0x0fe60206,
+	0x000c0000, 0x0fed0207, 0x00050000, 0x0ff70204,
+	0x02000000, 0x00000000, 0x01fe0ff3, 0x0000000f,
+	0x01f60fe5, 0x00000025, 0x01ea0fdb, 0x0ffd003e,
+	0x01db0fd2, 0x0ffb0058, 0x01c80fcc, 0x0ff70075,
+	0x01b50fc7, 0x0ff40090, 0x01a00fc3, 0x0ff000ad,
+	0x01880fc1, 0x0feb00cc, 0x01700fc1, 0x0fe800e7,
+	0x01550fc3, 0x0fe40104, 0x013b0fc5, 0x0fe2011e,
+	0x01240fc6, 0x0fde0138, 0x010c0fca, 0x0fda0150,
+	0x00f40fcd, 0x0fd90166, 0x00dd0fd1, 0x0fd7017b,
+	0x00c80fd4, 0x0fd40190, 0x00b20fd9, 0x0fd401a1,
+	0x009f0fdd, 0x0fd301b1, 0x008c0fe1, 0x0fd301c0,
+	0x007b0fe5, 0x0fd301cd, 0x006a0fea, 0x0fd401d8,
+	0x005c0fec, 0x0fd501e3, 0x004d0ff0, 0x0fd601ed,
+	0x00410ff3, 0x0fd801f4, 0x00340ff7, 0x0fdb01fa,
+	0x002a0ff9, 0x0fdf01fe, 0x00200ffb, 0x0fe30202,
+	0x00180ffd, 0x0fe70204, 0x00100ffe, 0x0fed0205,
+	0x00090000, 0x0ff20205, 0x00040000, 0x0ff90203,
+	0x02000000, 0x00000000, 0x02050ff5, 0x00000006,
+	0x02070fea, 0x0000000f, 0x02080fe1, 0x0ffd001a,
+	0x02070fd8, 0x0ffb0026, 0x02030fd1, 0x0ff80034,
+	0x01fe0fcb, 0x0ff40043, 0x01f60fc5, 0x0ff10054,
+	0x01ee0fc0, 0x0feb0067, 0x01e20fbe, 0x0fe70079,
+	0x01d40fbd, 0x0fe1008e, 0x01c40fbc, 0x0fdd00a3,
+	0x01b40fbb, 0x0fd700ba, 0x01a20fbc, 0x0fd100d1,
+	0x018d0fbd, 0x0fcd00e9, 0x01770fc0, 0x0fc80101,
+	0x01630fc1, 0x0fc1011b, 0x01480fc7, 0x0fbf0132,
+	0x01300fca, 0x0fba014c, 0x01170fce, 0x0fb80163,
+	0x00fd0fd4, 0x0fb5017a, 0x00e20fda, 0x0fb5018f,
+	0x00c80fdd, 0x0fb401a7, 0x00ae0fe4, 0x0fb401ba,
+	0x00960fe8, 0x0fb601cc, 0x007c0fee, 0x0fba01dc,
+	0x00650ff2, 0x0fc001e9, 0x00500ff6, 0x0fc701f3,
+	0x003b0ffa, 0x0fcf01fc, 0x00290ffc, 0x0fda0201,
+	0x00180000, 0x0fe40204, 0x000a0000, 0x0ff20204,
+	0x02000000, 0x00000000, 0x02030ff5, 0x00000008,
+	0x02030fea, 0x00000013, 0x02020fe1, 0x0ffd0020,
+	0x01fc0fd9, 0x0ffc002f, 0x01f60fd2, 0x0ff80040,
+	0x01ed0fcd, 0x0ff50051, 0x01e30fc7, 0x0ff10065,
+	0x01d70fc3, 0x0fec007a, 0x01c60fc2, 0x0fe9008f,
+	0x01b60fc1, 0x0fe300a6, 0x01a20fc1, 0x0fe000bd,
+	0x018f0fc1, 0x0fdb00d5, 0x017b0fc2, 0x0fd500ee,
+	0x01640fc4, 0x0fd20106, 0x014d0fc8, 0x0fce011d,
+	0x01370fc9, 0x0fc90137, 0x011d0fce, 0x0fc8014d,
+	0x01060fd2, 0x0fc40164, 0x00ee0fd5, 0x0fc2017b,
+	0x00d50fdb, 0x0fc1018f, 0x00bd0fe0, 0x0fc101a2,
+	0x00a60fe3, 0x0fc101b6, 0x008f0fe9, 0x0fc201c6,
+	0x007a0fec, 0x0fc301d7, 0x00650ff1, 0x0fc701e3,
+	0x00510ff5, 0x0fcd01ed, 0x00400ff8, 0x0fd201f6,
+	0x002f0ffc, 0x0fd901fc, 0x00200ffd, 0x0fe10202,
+	0x00130000, 0x0fea0203, 0x00080000, 0x0ff50203,
+	0x02000000, 0x00000000, 0x02020ff5, 0x00000009,
+	0x01ff0fea, 0x00000017, 0x01fb0fe2, 0x0ffd0026,
+	0x01f30fda, 0x0ffc0037, 0x01ea0fd3, 0x0ff8004b,
+	0x01df0fce, 0x0ff5005e, 0x01d10fc9, 0x0ff20074,
+	0x01c10fc6, 0x0fed008c, 0x01ae0fc5, 0x0fea00a3,
+	0x019b0fc5, 0x0fe500bb, 0x01850fc6, 0x0fe200d3,
+	0x01700fc6, 0x0fde00ec, 0x015a0fc8, 0x0fd90105,
+	0x01430fca, 0x0fd6011d, 0x012b0fcd, 0x0fd30135,
+	0x01150fcf, 0x0fcf014d, 0x00fc0fd4, 0x0fce0162,
+	0x00e50fd8, 0x0fcc0177, 0x00cf0fdb, 0x0fca018c,
+	0x00b80fe0, 0x0fc9019f, 0x00a20fe5, 0x0fca01af,
+	0x008e0fe8, 0x0fcb01bf, 0x00790fec, 0x0fcb01d0,
+	0x00670fef, 0x0fcd01dd, 0x00550ff4, 0x0fd001e7,
+	0x00440ff7, 0x0fd501f0, 0x00350ffa, 0x0fda01f7,
+	0x00270ffc, 0x0fdf01fe, 0x001b0ffe, 0x0fe70200,
+	0x00100000, 0x0fee0202, 0x00060000, 0x0ff70203,
+	0x02000000, 0x00000000, 0x01ff0ff5, 0x0000000c,
+	0x01f80fea, 0x0000001e, 0x01ef0fe2, 0x0ffd0032,
+	0x01e20fdb, 0x0ffc0047, 0x01d30fd5, 0x0ff9005f,
+	0x01c20fd1, 0x0ff60077, 0x01b00fcd, 0x0ff30090,
+	0x019b0fcb, 0x0fef00ab, 0x01850fcb, 0x0fec00c4,
+	0x016e0fcc, 0x0fe800de, 0x01550fcd, 0x0fe600f8,
+	0x013f0fce, 0x0fe20111, 0x01280fd0, 0x0fdf0129,
+	0x01110fd2, 0x0fdd0140, 0x00f90fd6, 0x0fdb0156,
+	0x00e40fd8, 0x0fd8016c, 0x00cd0fdd, 0x0fd8017e,
+	0x00b80fe0, 0x0fd60192, 0x00a40fe3, 0x0fd601a3,
+	0x00910fe7, 0x0fd501b3, 0x007f0feb, 0x0fd601c0,
+	0x006e0fed, 0x0fd701ce, 0x005d0ff1, 0x0fd701db,
+	0x004f0ff3, 0x0fd901e5, 0x00400ff7, 0x0fdc01ed,
+	0x00330ff9, 0x0fe001f4, 0x00280ffb, 0x0fe301fa,
+	0x001d0ffd, 0x0fe801fe, 0x00140ffe, 0x0fed0201,
+	0x000c0000, 0x0ff20202, 0x00050000, 0x0ff90202,
+	0x02000000, 0x00000000, 0x02040ff7, 0x00000005,
+	0x02070fed, 0x0000000c, 0x02060fe6, 0x0ffe0016,
+	0x02050fdf, 0x0ffc0020, 0x02020fd9, 0x0ff9002c,
+	0x01fe0fd4, 0x0ff60038, 0x01f80fcf, 0x0ff30046,
+	0x01f00fcb, 0x0fef0056, 0x01e70fc8, 0x0feb0066,
+	0x01db0fc7, 0x0fe60078, 0x01cc0fc6, 0x0fe3008b,
+	0x01bf0fc5, 0x0fdd009f, 0x01ae0fc6, 0x0fd800b4,
+	0x019c0fc6, 0x0fd400ca, 0x01880fc9, 0x0fcf00e0,
+	0x01750fc9, 0x0fc900f9, 0x015d0fce, 0x0fc6010f,
+	0x01460fd0, 0x0fc20128, 0x012e0fd3, 0x0fbf0140,
+	0x01140fd8, 0x0fbc0158, 0x00f90fdd, 0x0fbb016f,
+	0x00df0fe0, 0x0fba0187, 0x00c40fe5, 0x0fb9019e,
+	0x00aa0fe9, 0x0fba01b3, 0x008e0fef, 0x0fbd01c6,
+	0x00740ff3, 0x0fc301d6, 0x005d0ff6, 0x0fc801e5,
+	0x00450ffa, 0x0fd001f1, 0x00300ffc, 0x0fda01fa,
+	0x001c0000, 0x0fe40200, 0x000c0000, 0x0ff20202,
+	0x02000000, 0x00000000, 0x02030ff7, 0x00000006,
+	0x02020fee, 0x00000010, 0x02000fe7, 0x0ffe001b,
+	0x01fe0fdf, 0x0ffc0027, 0x01f70fda, 0x0ffa0035,
+	0x01f00fd5, 0x0ff70044, 0x01e70fd0, 0x0ff40055,
+	0x01dd0fcd, 0x0fef0067, 0x01d00fcb, 0x0fec0079,
+	0x01bf0fcb, 0x0fe8008e, 0x01af0fca, 0x0fe500a2,
+	0x019f0fc9, 0x0fe000b8, 0x018c0fca, 0x0fdb00cf,
+	0x01770fcc, 0x0fd800e5, 0x01620fce, 0x0fd400fc,
+	0x014d0fcf, 0x0fcf0115, 0x01350fd3, 0x0fcd012b,
+	0x011d0fd6, 0x0fca0143, 0x01050fd9, 0x0fc8015a,
+	0x00ec0fde, 0x0fc60170, 0x00d30fe2, 0x0fc60185,
+	0x00bb0fe5, 0x0fc5019b, 0x00a30fea, 0x0fc501ae,
+	0x008c0fed, 0x0fc601c1, 0x00740ff2, 0x0fc901d1,
+	0x005e0ff5, 0x0fce01df, 0x004b0ff8, 0x0fd301ea,
+	0x00370ffc, 0x0fda01f3, 0x00260ffd, 0x0fe201fb,
+	0x00170000, 0x0fea01ff, 0x00090000, 0x0ff50202,
+	0x02000000, 0x00000000, 0x02010ff7, 0x00000008,
+	0x01ff0fee, 0x00000013, 0x01fb0fe7, 0x0ffe0020,
+	0x01f60fe0, 0x0ffc002e, 0x01ed0fda, 0x0ffa003f,
+	0x01e40fd6, 0x0ff7004f, 0x01d80fd2, 0x0ff40062,
+	0x01ca0fcf, 0x0ff00077, 0x01bb0fcd, 0x0fed008b,
+	0x01a90fcd, 0x0fe900a1, 0x01960fcd, 0x0fe600b7,
+	0x01830fcd, 0x0fe200ce, 0x016d0fcf, 0x0fde00e6,
+	0x01580fd0, 0x0fdb00fd, 0x01410fd3, 0x0fd80114,
+	0x012c0fd4, 0x0fd4012c, 0x01140fd8, 0x0fd30141,
+	0x00fd0fdb, 0x0fd00158, 0x00e60fde, 0x0fcf016d,
+	0x00ce0fe2, 0x0fcd0183, 0x00b70fe6, 0x0fcd0196,
+	0x00a10fe9, 0x0fcd01a9, 0x008b0fed, 0x0fcd01bb,
+	0x00770ff0, 0x0fcf01ca, 0x00620ff4, 0x0fd201d8,
+	0x004f0ff7, 0x0fd601e4, 0x003f0ffa, 0x0fda01ed,
+	0x002e0ffc, 0x0fe001f6, 0x00200ffe, 0x0fe701fb,
+	0x00130000, 0x0fee01ff, 0x00080000, 0x0ff70201,
+	0x02000000, 0x00000000, 0x01ff0ff7, 0x0000000a,
+	0x01f90fee, 0x00000019, 0x01f10fe7, 0x0ffe002a,
+	0x01e60fe1, 0x0ffd003c, 0x01d90fdc, 0x0ffa0051,
+	0x01cc0fd8, 0x0ff70065, 0x01bb0fd5, 0x0ff5007b,
+	0x01a80fd3, 0x0ff10094, 0x01950fd2, 0x0fef00aa,
+	0x01800fd2, 0x0feb00c3, 0x016a0fd3, 0x0fe900da,
+	0x01540fd3, 0x0fe600f3, 0x013f0fd5, 0x0fe2010a,
+	0x01280fd7, 0x0fe00121, 0x01100fda, 0x0fde0138,
+	0x00fb0fdb, 0x0fdb014f, 0x00e40fdf, 0x0fdb0162,
+	0x00ce0fe2, 0x0fd90177, 0x00b90fe4, 0x0fd8018b,
+	0x00a50fe8, 0x0fd8019b, 0x00910fec, 0x0fd801ab,
+	0x007e0fee, 0x0fd801bc, 0x006c0ff2, 0x0fd901c9,
+	0x005c0ff4, 0x0fda01d6, 0x004b0ff7, 0x0fdd01e1,
+	0x003c0ff9, 0x0fe001eb, 0x002f0ffb, 0x0fe401f2,
+	0x00230ffd, 0x0fe801f8, 0x00180ffe, 0x0fed01fd,
+	0x000e0000, 0x0ff20200, 0x00060000, 0x0ff90201,
+	0x02000000, 0x00000000, 0x02030ff9, 0x00000004,
+	0x02050ff2, 0x00000009, 0x02050fed, 0x0ffe0010,
+	0x02040fe7, 0x0ffd0018, 0x02020fe3, 0x0ffb0020,
+	0x01fe0fdf, 0x0ff9002a, 0x01fa0fdb, 0x0ff70034,
+	0x01f40fd8, 0x0ff30041, 0x01ed0fd6, 0x0ff0004d,
+	0x01e30fd5, 0x0fec005c, 0x01d80fd4, 0x0fea006a,
+	0x01cd0fd3, 0x0fe5007b, 0x01c00fd3, 0x0fe1008c,
+	0x01b10fd3, 0x0fdd009f, 0x01a10fd4, 0x0fd900b2,
+	0x01900fd4, 0x0fd400c8, 0x017b0fd7, 0x0fd100dd,
+	0x01660fd9, 0x0fcd00f4, 0x01500fda, 0x0fca010c,
+	0x01380fde, 0x0fc60124, 0x011e0fe2, 0x0fc5013b,
+	0x01040fe4, 0x0fc30155, 0x00e70fe8, 0x0fc10170,
+	0x00cc0feb, 0x0fc10188, 0x00ad0ff0, 0x0fc301a0,
+	0x00900ff4, 0x0fc701b5, 0x00750ff7, 0x0fcc01c8,
+	0x00580ffb, 0x0fd201db, 0x003e0ffd, 0x0fdb01ea,
+	0x00250000, 0x0fe501f6, 0x000f0000, 0x0ff301fe,
+	0x02000000, 0x00000000, 0x02020ff9, 0x00000005,
+	0x02020ff2, 0x0000000c, 0x02010fed, 0x0ffe0014,
+	0x01fe0fe8, 0x0ffd001d, 0x01fa0fe3, 0x0ffb0028,
+	0x01f40fe0, 0x0ff90033, 0x01ed0fdc, 0x0ff70040,
+	0x01e50fd9, 0x0ff3004f, 0x01db0fd7, 0x0ff1005d,
+	0x01ce0fd7, 0x0fed006e, 0x01c00fd6, 0x0feb007f,
+	0x01b30fd5, 0x0fe70091, 0x01a30fd6, 0x0fe300a4,
+	0x01920fd6, 0x0fe000b8, 0x017e0fd8, 0x0fdd00cd,
+	0x016c0fd8, 0x0fd800e4, 0x01560fdb, 0x0fd600f9,
+	0x01400fdd, 0x0fd20111, 0x01290fdf, 0x0fd00128,
+	0x01110fe2, 0x0fce013f, 0x00f80fe6, 0x0fcd0155,
+	0x00de0fe8, 0x0fcc016e, 0x00c40fec, 0x0fcb0185,
+	0x00ab0fef, 0x0fcb019b, 0x00900ff3, 0x0fcd01b0,
+	0x00770ff6, 0x0fd101c2, 0x005f0ff9, 0x0fd501d3,
+	0x00470ffc, 0x0fdb01e2, 0x00320ffd, 0x0fe201ef,
+	0x001e0000, 0x0fea01f8, 0x000c0000, 0x0ff501ff,
+	0x02000000, 0x00000000, 0x02010ff9, 0x00000006,
+	0x02000ff2, 0x0000000e, 0x01fd0fed, 0x0ffe0018,
+	0x01f80fe8, 0x0ffd0023, 0x01f20fe4, 0x0ffb002f,
+	0x01eb0fe0, 0x0ff9003c, 0x01e10fdd, 0x0ff7004b,
+	0x01d60fda, 0x0ff4005c, 0x01c90fd9, 0x0ff2006c,
+	0x01bc0fd8, 0x0fee007e, 0x01ab0fd8, 0x0fec0091,
+	0x019b0fd8, 0x0fe800a5, 0x018b0fd8, 0x0fe400b9,
+	0x01770fd9, 0x0fe200ce, 0x01620fdb, 0x0fdf00e4,
+	0x014f0fdb, 0x0fdb00fb, 0x01380fde, 0x0fda0110,
+	0x01210fe0, 0x0fd70128, 0x010a0fe2, 0x0fd5013f,
+	0x00f30fe6, 0x0fd30154, 0x00da0fe9, 0x0fd3016a,
+	0x00c30feb, 0x0fd20180, 0x00aa0fef, 0x0fd20195,
+	0x00940ff1, 0x0fd301a8, 0x007b0ff5, 0x0fd501bb,
+	0x00650ff7, 0x0fd801cc, 0x00510ffa, 0x0fdc01d9,
+	0x003c0ffd, 0x0fe101e6, 0x002a0ffe, 0x0fe701f1,
+	0x00190000, 0x0fee01f9, 0x000a0000, 0x0ff701ff,
+	0x02000000, 0x00000000, 0x01ff0ff9, 0x00000008,
+	0x01fb0ff2, 0x00000013, 0x01f50fed, 0x0ffe0020,
+	0x01ed0fe8, 0x0ffd002e, 0x01e30fe4, 0x0ffb003e,
+	0x01d80fe1, 0x0ff9004e, 0x01cb0fde, 0x0ff70060,
+	0x01bc0fdc, 0x0ff40074, 0x01ac0fdb, 0x0ff20087,
+	0x019a0fdb, 0x0fef009c, 0x01870fdb, 0x0fed00b1,
+	0x01740fdb, 0x0fea00c7, 0x01600fdc, 0x0fe700dd,
+	0x014b0fdd, 0x0fe500f3, 0x01350fdf, 0x0fe30109,
+	0x01200fe0, 0x0fe00120, 0x01090fe3, 0x0fdf0135,
+	0x00f30fe5, 0x0fdd014b, 0x00dd0fe7, 0x0fdc0160,
+	0x00c70fea, 0x0fdb0174, 0x00b10fed, 0x0fdb0187,
+	0x009c0fef, 0x0fdb019a, 0x00870ff2, 0x0fdb01ac,
+	0x00740ff4, 0x0fdc01bc, 0x00600ff7, 0x0fde01cb,
+	0x004e0ff9, 0x0fe101d8, 0x003e0ffb, 0x0fe401e3,
+	0x002e0ffd, 0x0fe801ed, 0x00200ffe, 0x0fed01f5,
+	0x00130000, 0x0ff201fb, 0x00080000, 0x0ff901ff,
+	0x02000000, 0x00000000, 0x02060ff2, 0x00000008,
+	0x02090fe4, 0x00000013, 0x020a0fd9, 0x0ffc0021,
+	0x02080fce, 0x0ffa0030, 0x02030fc5, 0x0ff60042,
+	0x01fd0fbe, 0x0ff10054, 0x01f50fb6, 0x0fed0068,
+	0x01e90fb1, 0x0fe60080, 0x01dc0fae, 0x0fe10095,
+	0x01ca0fae, 0x0fda00ae, 0x01b70fad, 0x0fd600c6,
+	0x01a40fad, 0x0fcf00e0, 0x018f0faf, 0x0fc800fa,
+	0x01780fb1, 0x0fc30114, 0x015f0fb5, 0x0fbf012d,
+	0x01490fb7, 0x0fb70149, 0x012d0fbf, 0x0fb5015f,
+	0x01140fc3, 0x0fb10178, 0x00fa0fc8, 0x0faf018f,
+	0x00e00fcf, 0x0fad01a4, 0x00c60fd6, 0x0fad01b7,
+	0x00ae0fda, 0x0fae01ca, 0x00950fe1, 0x0fae01dc,
+	0x00800fe6, 0x0fb101e9, 0x00680fed, 0x0fb601f5,
+	0x00540ff1, 0x0fbe01fd, 0x00420ff6, 0x0fc50203,
+	0x00300ffa, 0x0fce0208, 0x00210ffc, 0x0fd9020a,
+	0x00130000, 0x0fe40209, 0x00080000, 0x0ff20206,
+	0x02000000, 0x00000000, 0x02040ff2, 0x0000000a,
+	0x02040fe4, 0x00000018, 0x02010fda, 0x0ffc0029,
+	0x01fc0fcf, 0x0ffa003b, 0x01f30fc7, 0x0ff60050,
+	0x01e90fc0, 0x0ff20065, 0x01dc0fba, 0x0fee007c,
+	0x01cc0fb6, 0x0fe80096, 0x01ba0fb4, 0x0fe400ae,
+	0x01a70fb4, 0x0fdd00c8, 0x018f0fb5, 0x0fda00e2,
+	0x017a0fb5, 0x0fd400fd, 0x01630fb8, 0x0fce0117,
+	0x014c0fba, 0x0fca0130, 0x01320fbf, 0x0fc70148,
+	0x011b0fc1, 0x0fc10163, 0x01010fc8, 0x0fc00177,
+	0x00e90fcd, 0x0fbd018d, 0x00d10fd1, 0x0fbc01a2,
+	0x00ba0fd7, 0x0fbb01b4, 0x00a30fdd, 0x0fbc01c4,
+	0x008e0fe1, 0x0fbd01d4, 0x00790fe7, 0x0fbe01e2,
+	0x00670feb, 0x0fc001ee, 0x00540ff1, 0x0fc501f6,
+	0x00430ff4, 0x0fcb01fe, 0x00340ff8, 0x0fd10203,
+	0x00260ffb, 0x0fd80207, 0x001a0ffd, 0x0fe10208,
+	0x000f0000, 0x0fea0207, 0x00060000, 0x0ff50205,
+	0x02000000, 0x00000000, 0x02020ff2, 0x0000000c,
+	0x02000fe4, 0x0000001c, 0x01fa0fda, 0x0ffc0030,
+	0x01f10fd0, 0x0ffa0045, 0x01e50fc8, 0x0ff6005d,
+	0x01d60fc3, 0x0ff30074, 0x01c60fbd, 0x0fef008e,
+	0x01b30fba, 0x0fe900aa, 0x019e0fb9, 0x0fe500c4,
+	0x01870fba, 0x0fe000df, 0x016f0fbb, 0x0fdd00f9,
+	0x01580fbc, 0x0fd80114, 0x01400fbf, 0x0fd3012e,
+	0x01280fc2, 0x0fd00146, 0x010f0fc6, 0x0fce015d,
+	0x00f90fc9, 0x0fc90175, 0x00e00fcf, 0x0fc90188,
+	0x00ca0fd4, 0x0fc6019c, 0x00b40fd8, 0x0fc601ae,
+	0x009f0fdd, 0x0fc501bf, 0x008b0fe3, 0x0fc601cc,
+	0x00780fe6, 0x0fc701db, 0x00660feb, 0x0fc801e7,
+	0x00560fef, 0x0fcb01f0, 0x00460ff3, 0x0fcf01f8,
+	0x00380ff6, 0x0fd401fe, 0x002c0ff9, 0x0fd90202,
+	0x00200ffc, 0x0fdf0205, 0x00160ffe, 0x0fe60206,
+	0x000c0000, 0x0fed0207, 0x00050000, 0x0ff70204,
+	0x02000000, 0x00000000, 0x01fe0ff3, 0x0000000f,
+	0x01f60fe5, 0x00000025, 0x01ea0fdb, 0x0ffd003e,
+	0x01db0fd2, 0x0ffb0058, 0x01c80fcc, 0x0ff70075,
+	0x01b50fc7, 0x0ff40090, 0x01a00fc3, 0x0ff000ad,
+	0x01880fc1, 0x0feb00cc, 0x01700fc1, 0x0fe800e7,
+	0x01550fc3, 0x0fe40104, 0x013b0fc5, 0x0fe2011e,
+	0x01240fc6, 0x0fde0138, 0x010c0fca, 0x0fda0150,
+	0x00f40fcd, 0x0fd90166, 0x00dd0fd1, 0x0fd7017b,
+	0x00c80fd4, 0x0fd40190, 0x00b20fd9, 0x0fd401a1,
+	0x009f0fdd, 0x0fd301b1, 0x008c0fe1, 0x0fd301c0,
+	0x007b0fe5, 0x0fd301cd, 0x006a0fea, 0x0fd401d8,
+	0x005c0fec, 0x0fd501e3, 0x004d0ff0, 0x0fd601ed,
+	0x00410ff3, 0x0fd801f4, 0x00340ff7, 0x0fdb01fa,
+	0x002a0ff9, 0x0fdf01fe, 0x00200ffb, 0x0fe30202,
+	0x00180ffd, 0x0fe70204, 0x00100ffe, 0x0fed0205,
+	0x00090000, 0x0ff20205, 0x00040000, 0x0ff90203,
+	0x02000000, 0x00000000, 0x02050ff5, 0x00000006,
+	0x02070fea, 0x0000000f, 0x02080fe1, 0x0ffd001a,
+	0x02070fd8, 0x0ffb0026, 0x02030fd1, 0x0ff80034,
+	0x01fe0fcb, 0x0ff40043, 0x01f60fc5, 0x0ff10054,
+	0x01ee0fc0, 0x0feb0067, 0x01e20fbe, 0x0fe70079,
+	0x01d40fbd, 0x0fe1008e, 0x01c40fbc, 0x0fdd00a3,
+	0x01b40fbb, 0x0fd700ba, 0x01a20fbc, 0x0fd100d1,
+	0x018d0fbd, 0x0fcd00e9, 0x01770fc0, 0x0fc80101,
+	0x01630fc1, 0x0fc1011b, 0x01480fc7, 0x0fbf0132,
+	0x01300fca, 0x0fba014c, 0x01170fce, 0x0fb80163,
+	0x00fd0fd4, 0x0fb5017a, 0x00e20fda, 0x0fb5018f,
+	0x00c80fdd, 0x0fb401a7, 0x00ae0fe4, 0x0fb401ba,
+	0x00960fe8, 0x0fb601cc, 0x007c0fee, 0x0fba01dc,
+	0x00650ff2, 0x0fc001e9, 0x00500ff6, 0x0fc701f3,
+	0x003b0ffa, 0x0fcf01fc, 0x00290ffc, 0x0fda0201,
+	0x00180000, 0x0fe40204, 0x000a0000, 0x0ff20204,
+	0x02000000, 0x00000000, 0x02030ff5, 0x00000008,
+	0x02030fea, 0x00000013, 0x02020fe1, 0x0ffd0020,
+	0x01fc0fd9, 0x0ffc002f, 0x01f60fd2, 0x0ff80040,
+	0x01ed0fcd, 0x0ff50051, 0x01e30fc7, 0x0ff10065,
+	0x01d70fc3, 0x0fec007a, 0x01c60fc2, 0x0fe9008f,
+	0x01b60fc1, 0x0fe300a6, 0x01a20fc1, 0x0fe000bd,
+	0x018f0fc1, 0x0fdb00d5, 0x017b0fc2, 0x0fd500ee,
+	0x01640fc4, 0x0fd20106, 0x014d0fc8, 0x0fce011d,
+	0x01370fc9, 0x0fc90137, 0x011d0fce, 0x0fc8014d,
+	0x01060fd2, 0x0fc40164, 0x00ee0fd5, 0x0fc2017b,
+	0x00d50fdb, 0x0fc1018f, 0x00bd0fe0, 0x0fc101a2,
+	0x00a60fe3, 0x0fc101b6, 0x008f0fe9, 0x0fc201c6,
+	0x007a0fec, 0x0fc301d7, 0x00650ff1, 0x0fc701e3,
+	0x00510ff5, 0x0fcd01ed, 0x00400ff8, 0x0fd201f6,
+	0x002f0ffc, 0x0fd901fc, 0x00200ffd, 0x0fe10202,
+	0x00130000, 0x0fea0203, 0x00080000, 0x0ff50203,
+	0x02000000, 0x00000000, 0x02020ff5, 0x00000009,
+	0x01ff0fea, 0x00000017, 0x01fb0fe2, 0x0ffd0026,
+	0x01f30fda, 0x0ffc0037, 0x01ea0fd3, 0x0ff8004b,
+	0x01df0fce, 0x0ff5005e, 0x01d10fc9, 0x0ff20074,
+	0x01c10fc6, 0x0fed008c, 0x01ae0fc5, 0x0fea00a3,
+	0x019b0fc5, 0x0fe500bb, 0x01850fc6, 0x0fe200d3,
+	0x01700fc6, 0x0fde00ec, 0x015a0fc8, 0x0fd90105,
+	0x01430fca, 0x0fd6011d, 0x012b0fcd, 0x0fd30135,
+	0x01150fcf, 0x0fcf014d, 0x00fc0fd4, 0x0fce0162,
+	0x00e50fd8, 0x0fcc0177, 0x00cf0fdb, 0x0fca018c,
+	0x00b80fe0, 0x0fc9019f, 0x00a20fe5, 0x0fca01af,
+	0x008e0fe8, 0x0fcb01bf, 0x00790fec, 0x0fcb01d0,
+	0x00670fef, 0x0fcd01dd, 0x00550ff4, 0x0fd001e7,
+	0x00440ff7, 0x0fd501f0, 0x00350ffa, 0x0fda01f7,
+	0x00270ffc, 0x0fdf01fe, 0x001b0ffe, 0x0fe70200,
+	0x00100000, 0x0fee0202, 0x00060000, 0x0ff70203,
+	0x02000000, 0x00000000, 0x01ff0ff5, 0x0000000c,
+	0x01f80fea, 0x0000001e, 0x01ef0fe2, 0x0ffd0032,
+	0x01e20fdb, 0x0ffc0047, 0x01d30fd5, 0x0ff9005f,
+	0x01c20fd1, 0x0ff60077, 0x01b00fcd, 0x0ff30090,
+	0x019b0fcb, 0x0fef00ab, 0x01850fcb, 0x0fec00c4,
+	0x016e0fcc, 0x0fe800de, 0x01550fcd, 0x0fe600f8,
+	0x013f0fce, 0x0fe20111, 0x01280fd0, 0x0fdf0129,
+	0x01110fd2, 0x0fdd0140, 0x00f90fd6, 0x0fdb0156,
+	0x00e40fd8, 0x0fd8016c, 0x00cd0fdd, 0x0fd8017e,
+	0x00b80fe0, 0x0fd60192, 0x00a40fe3, 0x0fd601a3,
+	0x00910fe7, 0x0fd501b3, 0x007f0feb, 0x0fd601c0,
+	0x006e0fed, 0x0fd701ce, 0x005d0ff1, 0x0fd701db,
+	0x004f0ff3, 0x0fd901e5, 0x00400ff7, 0x0fdc01ed,
+	0x00330ff9, 0x0fe001f4, 0x00280ffb, 0x0fe301fa,
+	0x001d0ffd, 0x0fe801fe, 0x00140ffe, 0x0fed0201,
+	0x000c0000, 0x0ff20202, 0x00050000, 0x0ff90202,
+	0x02000000, 0x00000000, 0x02040ff7, 0x00000005,
+	0x02070fed, 0x0000000c, 0x02060fe6, 0x0ffe0016,
+	0x02050fdf, 0x0ffc0020, 0x02020fd9, 0x0ff9002c,
+	0x01fe0fd4, 0x0ff60038, 0x01f80fcf, 0x0ff30046,
+	0x01f00fcb, 0x0fef0056, 0x01e70fc8, 0x0feb0066,
+	0x01db0fc7, 0x0fe60078, 0x01cc0fc6, 0x0fe3008b,
+	0x01bf0fc5, 0x0fdd009f, 0x01ae0fc6, 0x0fd800b4,
+	0x019c0fc6, 0x0fd400ca, 0x01880fc9, 0x0fcf00e0,
+	0x01750fc9, 0x0fc900f9, 0x015d0fce, 0x0fc6010f,
+	0x01460fd0, 0x0fc20128, 0x012e0fd3, 0x0fbf0140,
+	0x01140fd8, 0x0fbc0158, 0x00f90fdd, 0x0fbb016f,
+	0x00df0fe0, 0x0fba0187, 0x00c40fe5, 0x0fb9019e,
+	0x00aa0fe9, 0x0fba01b3, 0x008e0fef, 0x0fbd01c6,
+	0x00740ff3, 0x0fc301d6, 0x005d0ff6, 0x0fc801e5,
+	0x00450ffa, 0x0fd001f1, 0x00300ffc, 0x0fda01fa,
+	0x001c0000, 0x0fe40200, 0x000c0000, 0x0ff20202,
+	0x02000000, 0x00000000, 0x02030ff7, 0x00000006,
+	0x02020fee, 0x00000010, 0x02000fe7, 0x0ffe001b,
+	0x01fe0fdf, 0x0ffc0027, 0x01f70fda, 0x0ffa0035,
+	0x01f00fd5, 0x0ff70044, 0x01e70fd0, 0x0ff40055,
+	0x01dd0fcd, 0x0fef0067, 0x01d00fcb, 0x0fec0079,
+	0x01bf0fcb, 0x0fe8008e, 0x01af0fca, 0x0fe500a2,
+	0x019f0fc9, 0x0fe000b8, 0x018c0fca, 0x0fdb00cf,
+	0x01770fcc, 0x0fd800e5, 0x01620fce, 0x0fd400fc,
+	0x014d0fcf, 0x0fcf0115, 0x01350fd3, 0x0fcd012b,
+	0x011d0fd6, 0x0fca0143, 0x01050fd9, 0x0fc8015a,
+	0x00ec0fde, 0x0fc60170, 0x00d30fe2, 0x0fc60185,
+	0x00bb0fe5, 0x0fc5019b, 0x00a30fea, 0x0fc501ae,
+	0x008c0fed, 0x0fc601c1, 0x00740ff2, 0x0fc901d1,
+	0x005e0ff5, 0x0fce01df, 0x004b0ff8, 0x0fd301ea,
+	0x00370ffc, 0x0fda01f3, 0x00260ffd, 0x0fe201fb,
+	0x00170000, 0x0fea01ff, 0x00090000, 0x0ff50202,
+	0x02000000, 0x00000000, 0x02010ff7, 0x00000008,
+	0x01ff0fee, 0x00000013, 0x01fb0fe7, 0x0ffe0020,
+	0x01f60fe0, 0x0ffc002e, 0x01ed0fda, 0x0ffa003f,
+	0x01e40fd6, 0x0ff7004f, 0x01d80fd2, 0x0ff40062,
+	0x01ca0fcf, 0x0ff00077, 0x01bb0fcd, 0x0fed008b,
+	0x01a90fcd, 0x0fe900a1, 0x01960fcd, 0x0fe600b7,
+	0x01830fcd, 0x0fe200ce, 0x016d0fcf, 0x0fde00e6,
+	0x01580fd0, 0x0fdb00fd, 0x01410fd3, 0x0fd80114,
+	0x012c0fd4, 0x0fd4012c, 0x01140fd8, 0x0fd30141,
+	0x00fd0fdb, 0x0fd00158, 0x00e60fde, 0x0fcf016d,
+	0x00ce0fe2, 0x0fcd0183, 0x00b70fe6, 0x0fcd0196,
+	0x00a10fe9, 0x0fcd01a9, 0x008b0fed, 0x0fcd01bb,
+	0x00770ff0, 0x0fcf01ca, 0x00620ff4, 0x0fd201d8,
+	0x004f0ff7, 0x0fd601e4, 0x003f0ffa, 0x0fda01ed,
+	0x002e0ffc, 0x0fe001f6, 0x00200ffe, 0x0fe701fb,
+	0x00130000, 0x0fee01ff, 0x00080000, 0x0ff70201,
+	0x02000000, 0x00000000, 0x01ff0ff7, 0x0000000a,
+	0x01f90fee, 0x00000019, 0x01f10fe7, 0x0ffe002a,
+	0x01e60fe1, 0x0ffd003c, 0x01d90fdc, 0x0ffa0051,
+	0x01cc0fd8, 0x0ff70065, 0x01bb0fd5, 0x0ff5007b,
+	0x01a80fd3, 0x0ff10094, 0x01950fd2, 0x0fef00aa,
+	0x01800fd2, 0x0feb00c3, 0x016a0fd3, 0x0fe900da,
+	0x01540fd3, 0x0fe600f3, 0x013f0fd5, 0x0fe2010a,
+	0x01280fd7, 0x0fe00121, 0x01100fda, 0x0fde0138,
+	0x00fb0fdb, 0x0fdb014f, 0x00e40fdf, 0x0fdb0162,
+	0x00ce0fe2, 0x0fd90177, 0x00b90fe4, 0x0fd8018b,
+	0x00a50fe8, 0x0fd8019b, 0x00910fec, 0x0fd801ab,
+	0x007e0fee, 0x0fd801bc, 0x006c0ff2, 0x0fd901c9,
+	0x005c0ff4, 0x0fda01d6, 0x004b0ff7, 0x0fdd01e1,
+	0x003c0ff9, 0x0fe001eb, 0x002f0ffb, 0x0fe401f2,
+	0x00230ffd, 0x0fe801f8, 0x00180ffe, 0x0fed01fd,
+	0x000e0000, 0x0ff20200, 0x00060000, 0x0ff90201,
+	0x02000000, 0x00000000, 0x02030ff9, 0x00000004,
+	0x02050ff2, 0x00000009, 0x02050fed, 0x0ffe0010,
+	0x02040fe7, 0x0ffd0018, 0x02020fe3, 0x0ffb0020,
+	0x01fe0fdf, 0x0ff9002a, 0x01fa0fdb, 0x0ff70034,
+	0x01f40fd8, 0x0ff30041, 0x01ed0fd6, 0x0ff0004d,
+	0x01e30fd5, 0x0fec005c, 0x01d80fd4, 0x0fea006a,
+	0x01cd0fd3, 0x0fe5007b, 0x01c00fd3, 0x0fe1008c,
+	0x01b10fd3, 0x0fdd009f, 0x01a10fd4, 0x0fd900b2,
+	0x01900fd4, 0x0fd400c8, 0x017b0fd7, 0x0fd100dd,
+	0x01660fd9, 0x0fcd00f4, 0x01500fda, 0x0fca010c,
+	0x01380fde, 0x0fc60124, 0x011e0fe2, 0x0fc5013b,
+	0x01040fe4, 0x0fc30155, 0x00e70fe8, 0x0fc10170,
+	0x00cc0feb, 0x0fc10188, 0x00ad0ff0, 0x0fc301a0,
+	0x00900ff4, 0x0fc701b5, 0x00750ff7, 0x0fcc01c8,
+	0x00580ffb, 0x0fd201db, 0x003e0ffd, 0x0fdb01ea,
+	0x00250000, 0x0fe501f6, 0x000f0000, 0x0ff301fe,
+	0x02000000, 0x00000000, 0x02020ff9, 0x00000005,
+	0x02020ff2, 0x0000000c, 0x02010fed, 0x0ffe0014,
+	0x01fe0fe8, 0x0ffd001d, 0x01fa0fe3, 0x0ffb0028,
+	0x01f40fe0, 0x0ff90033, 0x01ed0fdc, 0x0ff70040,
+	0x01e50fd9, 0x0ff3004f, 0x01db0fd7, 0x0ff1005d,
+	0x01ce0fd7, 0x0fed006e, 0x01c00fd6, 0x0feb007f,
+	0x01b30fd5, 0x0fe70091, 0x01a30fd6, 0x0fe300a4,
+	0x01920fd6, 0x0fe000b8, 0x017e0fd8, 0x0fdd00cd,
+	0x016c0fd8, 0x0fd800e4, 0x01560fdb, 0x0fd600f9,
+	0x01400fdd, 0x0fd20111, 0x01290fdf, 0x0fd00128,
+	0x01110fe2, 0x0fce013f, 0x00f80fe6, 0x0fcd0155,
+	0x00de0fe8, 0x0fcc016e, 0x00c40fec, 0x0fcb0185,
+	0x00ab0fef, 0x0fcb019b, 0x00900ff3, 0x0fcd01b0,
+	0x00770ff6, 0x0fd101c2, 0x005f0ff9, 0x0fd501d3,
+	0x00470ffc, 0x0fdb01e2, 0x00320ffd, 0x0fe201ef,
+	0x001e0000, 0x0fea01f8, 0x000c0000, 0x0ff501ff,
+	0x02000000, 0x00000000, 0x02010ff9, 0x00000006,
+	0x02000ff2, 0x0000000e, 0x01fd0fed, 0x0ffe0018,
+	0x01f80fe8, 0x0ffd0023, 0x01f20fe4, 0x0ffb002f,
+	0x01eb0fe0, 0x0ff9003c, 0x01e10fdd, 0x0ff7004b,
+	0x01d60fda, 0x0ff4005c, 0x01c90fd9, 0x0ff2006c,
+	0x01bc0fd8, 0x0fee007e, 0x01ab0fd8, 0x0fec0091,
+	0x019b0fd8, 0x0fe800a5, 0x018b0fd8, 0x0fe400b9,
+	0x01770fd9, 0x0fe200ce, 0x01620fdb, 0x0fdf00e4,
+	0x014f0fdb, 0x0fdb00fb, 0x01380fde, 0x0fda0110,
+	0x01210fe0, 0x0fd70128, 0x010a0fe2, 0x0fd5013f,
+	0x00f30fe6, 0x0fd30154, 0x00da0fe9, 0x0fd3016a,
+	0x00c30feb, 0x0fd20180, 0x00aa0fef, 0x0fd20195,
+	0x00940ff1, 0x0fd301a8, 0x007b0ff5, 0x0fd501bb,
+	0x00650ff7, 0x0fd801cc, 0x00510ffa, 0x0fdc01d9,
+	0x003c0ffd, 0x0fe101e6, 0x002a0ffe, 0x0fe701f1,
+	0x00190000, 0x0fee01f9, 0x000a0000, 0x0ff701ff,
+	0x02000000, 0x00000000, 0x01ff0ff9, 0x00000008,
+	0x01fb0ff2, 0x00000013, 0x01f50fed, 0x0ffe0020,
+	0x01ed0fe8, 0x0ffd002e, 0x01e30fe4, 0x0ffb003e,
+	0x01d80fe1, 0x0ff9004e, 0x01cb0fde, 0x0ff70060,
+	0x01bc0fdc, 0x0ff40074, 0x01ac0fdb, 0x0ff20087,
+	0x019a0fdb, 0x0fef009c, 0x01870fdb, 0x0fed00b1,
+	0x01740fdb, 0x0fea00c7, 0x01600fdc, 0x0fe700dd,
+	0x014b0fdd, 0x0fe500f3, 0x01350fdf, 0x0fe30109,
+	0x01200fe0, 0x0fe00120, 0x01090fe3, 0x0fdf0135,
+	0x00f30fe5, 0x0fdd014b, 0x00dd0fe7, 0x0fdc0160,
+	0x00c70fea, 0x0fdb0174, 0x00b10fed, 0x0fdb0187,
+	0x009c0fef, 0x0fdb019a, 0x00870ff2, 0x0fdb01ac,
+	0x00740ff4, 0x0fdc01bc, 0x00600ff7, 0x0fde01cb,
+	0x004e0ff9, 0x0fe101d8, 0x003e0ffb, 0x0fe401e3,
+	0x002e0ffd, 0x0fe801ed, 0x00200ffe, 0x0fed01f5,
+	0x00130000, 0x0ff201fb, 0x00080000, 0x0ff901ff
+};
+
+static uint32 vg_qseed_table2_DMB[] = {
 	0x02000000, 0x00000000, 0x01ff0ff9, 0x00000008,
 	0x01fb0ff2, 0x00000013, 0x01f50fed, 0x0ffe0020,
 	0x01ed0fe8, 0x0ffd002e, 0x01e30fe4, 0x0ffb003e,
@@ -1121,7 +1664,6 @@
 	0x0f800ffa, 0x0f4f0337, 0x0f6d0ffe, 0x0f57033e
 };
 
-
 #define MDP4_QSEED_TABLE0_OFF 0x8100
 #define MDP4_QSEED_TABLE1_OFF 0x8200
 #define MDP4_QSEED_TABLE2_OFF 0x9000
@@ -1170,6 +1712,68 @@
 		off++;
 		if (!((uint32)off & 0x3FF))
 			wmb();
+	}
+
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+
+}
+
+void mdp4_vg_qseed_init_VideoPlay(int vp_num)
+{
+	uint32 *off;
+	int i, voff;
+
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+
+	voff = MDP4_VIDEO_OFF * vp_num;
+
+	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
+						MDP4_QSEED_TABLE1_OFF);
+	for (i = 0; i < (sizeof(vg_qseed_table1) / sizeof(uint32)); i++) {
+		outpdw(off, vg_qseed_table1[i]);
+		off++;
+		if (!((uint32)off & 0x3FF))
+			wmb();
+	}
+
+	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
+						MDP4_QSEED_TABLE2_OFF);
+	for (i = 0; i < (sizeof(vg_qseed_table2) / sizeof(uint32)); i++) {
+		outpdw(off, vg_qseed_table2[i]);
+		off++;
+		if (!((uint32)off & 0x3FF))
+			wmb();
+	}
+
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+
+}
+
+void mdp4_vg_qseed_init_DMB(int vp_num)
+{
+	uint32 *off;
+	int i, voff;
+
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+
+	voff = MDP4_VIDEO_OFF * vp_num;
+
+	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
+						MDP4_QSEED_TABLE1_OFF);
+	for (i = 0; i < (sizeof(vg_qseed_table1) / sizeof(uint32)); i++) {
+		outpdw(off, vg_qseed_table1[i]);
+		off++;
+		if (!((uint32)off & 0x3FF))
+			wmb();
+	}
+
+	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
+						MDP4_QSEED_TABLE2_OFF);
+	for (i = 0; i < (sizeof(vg_qseed_table2_DMB) / sizeof(uint32)); i++) {
+		outpdw(off, vg_qseed_table2_DMB[i]);
+		off++;
+		if (!((uint32)off & 0x3FF))
+			wmb();
 	}
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
Only in msm: mdp4_video_enhance.c
Only in msm: mdp4_video_enhance.h
Only in msm: mdp4_video_tuning.h
Only in msm: mdp4_video_tuning_HD720.h
Only in msm: mdp4_video_tuning_Q1.h
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mdp4_wfd_writeback_panel.c msm/mdp4_wfd_writeback_panel.c
--- /home/shade/kernel-msm/drivers/video/msm/mdp4_wfd_writeback_panel.c	2012-05-19 18:38:37.632909378 -0700
+++ msm/mdp4_wfd_writeback_panel.c	2012-08-10 12:10:27.379062703 -0700
@@ -37,8 +37,8 @@
 static struct msm_fb_panel_data writeback_msm_panel_data = {
 	.panel_info = {
 		.type = WRITEBACK_PANEL,
-		.xres = 1280,
-		.yres = 720,
+		.xres = 1920,
+		.yres = 1080,
 		.pdest = DISPLAY_3,
 		.wait_cycle = 0,
 		.bpp = 24,
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mdp.c msm/mdp.c
--- /home/shade/kernel-msm/drivers/video/msm/mdp.c	2012-08-20 15:41:33.593116262 -0700
+++ msm/mdp.c	2012-08-20 11:19:05.825193096 -0700
@@ -1986,6 +1986,7 @@
 static int mdp_off(struct platform_device *pdev)
 {
 	int ret = 0;
+
 	struct msm_fb_data_type *mfd = platform_get_drvdata(pdev);
 
 	mdp_histogram_ctrl_all(FALSE);
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mdp.h msm/mdp.h
--- /home/shade/kernel-msm/drivers/video/msm/mdp.h	2012-08-20 15:41:33.593116262 -0700
+++ msm/mdp.h	2012-08-20 11:19:05.812193097 -0700
@@ -766,7 +766,7 @@
 int mdp_dsi_video_on(struct platform_device *pdev);
 int mdp_dsi_video_off(struct platform_device *pdev);
 void mdp_dsi_video_update(struct msm_fb_data_type *mfd);
-void mdp3_dsi_cmd_dma_busy_wait(struct msm_fb_data_type *mfd);
+void mdp3_dsi_cmd_dma_busy_wait(struct msm_fb_data_type *mfd)
 static inline int mdp4_dsi_cmd_off(struct platform_device *pdev)
 {
 	return 0;
Only in msm: mhl_v1
Only in msm: mhl_v2
Only in msm: .mipi_chimei_wxga_pt.c.swp
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mipi_dsi.c msm/mipi_dsi.c
--- /home/shade/kernel-msm/drivers/video/msm/mipi_dsi.c	2012-08-20 15:40:53.076119034 -0700
+++ msm/mipi_dsi.c	2012-08-17 15:28:18.612894721 -0700
@@ -43,8 +43,13 @@
 static int mipi_dsi_probe(struct platform_device *pdev);
 static int mipi_dsi_remove(struct platform_device *pdev);
 
-static int mipi_dsi_off(struct platform_device *pdev);
-static int mipi_dsi_on(struct platform_device *pdev);
+ int mipi_dsi_off(struct platform_device *pdev);
+ int mipi_dsi_on(struct platform_device *pdev);
+
+#if defined(CONFIG_USA_MODEL_SGH_I717) || defined (CONFIG_JPN_MODEL_SC_05D)
+static int mipi_dsi_shutdown(struct platform_device *pdev);
+#endif
+
 
 static struct platform_device *pdev_list[MSM_FB_MAX_DEV_LIST];
 static int pdev_list_cnt;
@@ -55,7 +60,11 @@
 static struct platform_driver mipi_dsi_driver = {
 	.probe = mipi_dsi_probe,
 	.remove = mipi_dsi_remove,
+#if defined(CONFIG_USA_MODEL_SGH_I717) || defined (CONFIG_JPN_MODEL_SC_05D)
+	.shutdown = mipi_dsi_shutdown,
+#else
 	.shutdown = NULL,
+#endif
 	.driver = {
 		   .name = "mipi_dsi",
 		   },
@@ -63,7 +72,7 @@
 
 struct device dsi_dev;
 
-static int mipi_dsi_off(struct platform_device *pdev)
+int mipi_dsi_off(struct platform_device *pdev)
 {
 	int ret = 0;
 	struct msm_fb_data_type *mfd;
@@ -101,6 +110,12 @@
 	mdp_bus_scale_update_request(0);
 #endif
 
+#if defined(CONFIG_FB_MSM_MIPI_S6E8AA0_HD720_PANEL) || \
+	defined(CONFIG_FB_MSM_MIPI_S6E8AA0_WXGA_Q1_PANEL)
+
+	MIPI_OUTP(MIPI_DSI_BASE + 0xA8, 0x00000000); // for LCD-on when wakeup
+#endif
+
 	spin_lock_bh(&dsi_clk_lock);
 	mipi_dsi_clk_disable();
 
@@ -125,8 +140,8 @@
 
 	return ret;
 }
-
-static int mipi_dsi_on(struct platform_device *pdev)
+struct platform_device *pdev_temp = NULL;
+int mipi_dsi_on(struct platform_device *pdev)
 {
 	int ret = 0;
 	u32 clk_rate;
@@ -140,6 +155,7 @@
 	u32 dummy_xres, dummy_yres;
 	int target_type = 0;
 
+	pdev_temp = pdev;
 	mfd = platform_get_drvdata(pdev);
 	fbi = mfd->fbi;
 	var = &fbi->var;
@@ -317,6 +333,21 @@
 	return ret;
 }
 
+#if defined(CONFIG_USA_MODEL_SGH_I717) || defined (CONFIG_JPN_MODEL_SC_05D)
+static int mipi_dsi_shutdown(struct platform_device *pdev)
+{
+	int ret = 0;
+	printk("%s:+\n", __func__);
+
+	msleep(200);
+	if (mipi_dsi_pdata && mipi_dsi_pdata->dsi_power_save)
+		mipi_dsi_pdata->dsi_power_save(0x10);
+
+	printk("%s:-\n", __func__);
+
+	return ret;
+}
+#endif
 
 static int mipi_dsi_resource_initialized;
 
@@ -572,6 +603,26 @@
 
 	pdev_list[pdev_list_cnt++] = pdev;
 
+#if 1 // Debug Information
+	printk(KERN_ERR "mipi_dsi_probe: H.Period=%d, width=%d, BPorch=%d, xrex=%d,FPorch=%d\n",
+			h_period,
+			(mfd->panel_info.lcdc.h_pulse_width),
+			(mfd->panel_info.lcdc.h_back_porch),
+			(mfd->panel_info.xres),
+			(mfd->panel_info.lcdc.h_front_porch)	);
+	printk(KERN_ERR "mipi_dsi_probe: V.Period=%d, width=%d, BPorch=%d, xrex=%d,FPorch=%d\n",
+			v_period,
+			(mfd->panel_info.lcdc.v_pulse_width),
+			(mfd->panel_info.lcdc.v_back_porch),
+			(mfd->panel_info.yres),
+			(mfd->panel_info.lcdc.v_front_porch)	);
+	printk(KERN_ERR "mipi_dsi_probe: mipi->frame_rate = %d\n", mipi->frame_rate );	
+	printk(KERN_ERR "mipi_dsi_probe: Lanes = %d\n", lanes );	
+	printk(KERN_ERR "mipi_dsi_probe: pll_divider_config.clk_rate = %u\n", pll_divider_config.clk_rate );
+	printk(KERN_ERR "mipi_dsi_probe: dsi_pclk_rate = %u\n", dsi_pclk_rate );
+	printk(KERN_ERR "mipi_dsi_probe: mipi->dsi_pclk_rate = %u\n", mipi->dsi_pclk_rate );
+#endif 
+
 return 0;
 
 mipi_dsi_probe_err:
@@ -611,4 +662,6 @@
 	return ret;
 }
 
+EXPORT_SYMBOL(mipi_dsi_on);
+EXPORT_SYMBOL(mipi_dsi_off);
 module_init(mipi_dsi_driver_init);
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mipi_dsi_host.c msm/mipi_dsi_host.c
--- /home/shade/kernel-msm/drivers/video/msm/mipi_dsi_host.c	2012-08-20 15:40:53.076119034 -0700
+++ msm/mipi_dsi_host.c	2012-08-20 15:29:28.128165871 -0700
@@ -85,6 +85,8 @@
 }
 #endif
 
+#define MIPI_DSI_TX_TIMEOUT_ms	(HZ *40/1000) // 40ms
+
 void mipi_dsi_init(void)
 {
 	init_completion(&dsi_dma_comp);
@@ -879,7 +881,14 @@
 
 	/* from frame buffer, low power mode */
 	/* DSI_COMMAND_MODE_DMA_CTRL */
-	MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x14000000);
+#if !defined (CONFIG_FB_MSM_MIPI_S6E8AA0_HD720_PANEL) && \
+	!defined (CONFIG_FB_MSM_MIPI_S6E8AA0_WXGA_Q1_PANEL) && \
+	!defined (CONFIG_FB_MSM_MIPI_S6E8AB0_WXGA_PANEL)
+
+	MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x14000000); // lp
+#else
+	MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x10000000); // hs
+#endif
 
 	data = 0;
 	if (pinfo->te_sel)
@@ -918,6 +927,11 @@
 	else
 		MIPI_OUTP(MIPI_DSI_BASE + 0x118, 0x33f); /* DSI_CLK_CTRL */
 
+#if defined(CONFIG_FB_MSM_MIPI_S6E8AA0_HD720_PANEL) || \
+defined(CONFIG_FB_MSM_MIPI_S6E8AA0_WXGA_Q1_PANEL)
+	// add following line.
+	MIPI_OUTP(MIPI_DSI_BASE + 0xA8, 0x10000000);
+#endif
 	dsi_ctrl |= BIT(0);	/* enable dsi */
 	MIPI_OUTP(MIPI_DSI_BASE + 0x0000, dsi_ctrl);
 
@@ -1373,6 +1387,8 @@
 
 int mipi_dsi_cmd_dma_tx(struct dsi_buf *tp)
 {
+	unsigned long ret_completion;
+	int ret = 0;
 
 	unsigned long flags;
 
@@ -1382,7 +1398,7 @@
 
 	bp = tp->data;
 
-	pr_debug("%s: ", __func__);
+	pr_debug("%s: (len=%d) ", __func__, tp->len );
 	for (i = 0; i < tp->len; i++)
 		pr_debug("%x ", *bp++);
 
@@ -1406,11 +1422,25 @@
 	wmb();
 	spin_unlock_irqrestore(&dsi_mdp_lock, flags);
 
+#if 0 // If LCD disconnected, this code cannot be pass. wait unlimited time.
 	wait_for_completion(&dsi_dma_comp);
+	ret = tp->len;
+#else // wait, and return error when Timeout.
+	ret_completion = wait_for_completion_timeout( &dsi_dma_comp, MIPI_DSI_TX_TIMEOUT_ms );
+	if( ret_completion == 0 )	{
+		pr_err("mipi_dsi_cmd_dma_tx FAILED : return = %lu (%x %x %x %x)\n", 
+			ret_completion, tp->data[0], tp->data[1], tp->data[2], tp->data[3] );
+		ret = -1; // return error code;
+	}
+	else {
+		ret = tp->len;
+	}
+#endif 
 
 	dma_unmap_single(&dsi_dev, tp->dmap, tp->len, DMA_TO_DEVICE);
 	tp->dmap = 0;
-	return tp->len;
+
+	return ret;
 }
 
 int mipi_dsi_cmd_dma_rx(struct dsi_buf *rp, int rlen)
Only in msm: mipi_s6e8aa0_hd720.c
Only in msm: mipi_s6e8aa0_hd720.h
Only in msm: mipi_s6e8aa0_hd720_pt.c
Only in msm: mipi_s6e8aa0_hd720_seq.h
Only in msm: mipi_s6e8aa0_wxga_q1.c
Only in msm: mipi_s6e8aa0_wxga_q1.h
Only in msm: mipi_s6e8aa0_wxga_q1_pt.c
Only in msm: mipi_s6e8aa0_wxga_q1_seq.h
Only in msm: mipi_s6e8ab0_wxga.c
Only in msm: mipi_s6e8ab0_wxga.h
Only in msm: mipi_s6e8ab0_wxga_pt.c
Only in msm: mipi_s6e8ab0_wxga_seq.h
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/mipi_tc358764_dsi2lvds.c msm/mipi_tc358764_dsi2lvds.c
--- /home/shade/kernel-msm/drivers/video/msm/mipi_tc358764_dsi2lvds.c	2012-08-20 15:40:53.077119034 -0700
+++ msm/mipi_tc358764_dsi2lvds.c	2012-08-17 10:16:29.791174031 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -68,9 +68,7 @@
 #include <linux/i2c.h>
 #include <linux/delay.h>
 #include <linux/pwm.h>
-#include <linux/gpio.h>
 #include "msm_fb.h"
-#include "mdp4.h"
 #include "mipi_dsi.h"
 #include "mipi_tc358764_dsi2lvds.h"
 
@@ -188,11 +186,7 @@
 #define DEBUG01		0x05A4	/* LVDS Data */
 
 /* PWM */
-static u32 d2l_pwm_freq_hz = (66*1000);
-
-/* 1366x768 uses pwm at 66 KHZ */
-/* 1200x1920 uses pwm at 25 KHZ */
-#define PWM_FREQ_HZ	(d2l_pwm_freq_hz)
+#define PWM_FREQ_HZ	(66*1000)	/* 66 KHZ */
 #define PWM_LEVEL 15
 #define PWM_PERIOD_USEC (USEC_PER_SEC / PWM_FREQ_HZ)
 #define PWM_DUTY_LEVEL (PWM_PERIOD_USEC / PWM_LEVEL)
@@ -219,21 +213,10 @@
 static struct dsi_buf d2l_rx_buf;
 static int led_pwm;
 static struct pwm_device *bl_pwm;
-static struct pwm_device *tn_pwm;
 static int bl_level;
 static u32 d2l_gpio_out_mask;
 static u32 d2l_gpio_out_val;
-static u32 d2l_3d_gpio_enable;
-static u32 d2l_3d_gpio_mode;
-static int d2l_enable_3d;
-static struct i2c_client *d2l_i2c_client;
-static struct i2c_driver d2l_i2c_slave_driver;
-
 static int mipi_d2l_init(void);
-static int mipi_d2l_enable_3d(struct msm_fb_data_type *mfd,
-			      bool enable, bool mode);
-static u32 d2l_i2c_read_reg(struct i2c_client *client, u16 reg);
-static u32 d2l_i2c_write_reg(struct i2c_client *client, u16 reg, u32 val);
 
 /**
  * Read a bridge register
@@ -253,7 +236,7 @@
 	mipi_dsi_buf_init(&d2l_tx_buf);
 	mipi_dsi_buf_init(&d2l_rx_buf);
 
-	/* mutex had been acquired at mipi_dsi_on */
+	/* mutex had been acquried at dsi_on */
 	len = mipi_dsi_cmds_rx(mfd, &d2l_tx_buf, &d2l_rx_buf,
 			       &cmd_read_reg, len);
 
@@ -264,6 +247,7 @@
 
 	pr_debug("%s: reg=0x%x.data=0x%08x.\n", __func__, reg, data);
 
+
 	return data;
 }
 
@@ -272,9 +256,9 @@
  *
  * @param mfd
  *
- * @return int
+ * @return register data value
  */
-static int mipi_d2l_write_reg(struct msm_fb_data_type *mfd, u16 reg, u32 data)
+static u32 mipi_d2l_write_reg(struct msm_fb_data_type *mfd, u16 reg, u32 data)
 {
 	struct wr_cmd_payload payload;
 	struct dsi_cmd_desc cmd_write_reg = {
@@ -289,34 +273,30 @@
 
 	pr_debug("%s: reg=0x%x. data=0x%x.\n", __func__, reg, data);
 
-	return 0;
-}
-
-static void mipi_d2l_read_status(struct msm_fb_data_type *mfd)
-{
-	mipi_d2l_read_reg(mfd, DSI_LANESTATUS0);	/* 0x214 */
-	mipi_d2l_read_reg(mfd, DSI_LANESTATUS1);	/* 0x218 */
-	mipi_d2l_read_reg(mfd, DSI_INTSTATUS);		/* 0x220 */
-	mipi_d2l_read_reg(mfd, SYSSTAT);		/* 0x500 */
+	return data;
 }
 
-static void mipi_d2l_read_status_via_i2c(struct i2c_client *client)
-{
-	u32 tmp = 0;
-
-	tmp = d2l_i2c_read_reg(client, DSIERRCNT);
-	d2l_i2c_write_reg(client, DSIERRCNT, 0xFFFF0000);
-
-	d2l_i2c_read_reg(client, DSI_LANESTATUS0);	/* 0x214 */
-	d2l_i2c_read_reg(client, DSI_LANESTATUS1);	/* 0x218 */
-	d2l_i2c_read_reg(client, DSI_INTSTATUS);	/* 0x220 */
-	d2l_i2c_read_reg(client, SYSSTAT);		/* 0x500 */
-
-	d2l_i2c_write_reg(client, DSIERRCNT, tmp);
-}
-/**
+/*
  * Init the D2L bridge via the DSI interface for Video.
  *
+ *	Register		Addr	Value
+ *  ===================================================
+ *  PPI_TX_RX_TA		0x013C	0x00040004
+ *  PPI_LPTXTIMECNT	        0x0114	0x00000004
+ *  PPI_D0S_CLRSIPOCOUNT	0x0164	0x00000003
+ *  PPI_D1S_CLRSIPOCOUNT	0x0168	0x00000003
+ *  PPI_D2S_CLRSIPOCOUNT	0x016C	0x00000003
+ *  PPI_D3S_CLRSIPOCOUNT	0x0170	0x00000003
+ *  PPI_LANEENABLE	        0x0134	0x0000001F
+ *  DSI_LANEENABLE	        0x0210	0x0000001F
+ *  PPI_STARTPPI	        0x0104	0x00000001
+ *  DSI_STARTDSI	        0x0204	0x00000001
+ *  VPCTRL			0x0450	0x01000120
+ *  HTIM1			0x0454	0x002C0028
+ *  VTIM1			0x045C	0x001E0008
+ *  VFUEN			0x0464	0x00000001
+ *  LVCFG			0x049C	0x00000001
+ *
  * VPCTRL.EVTMODE (0x20) configuration bit is needed to determine whether
  * video timing information is delivered in pulse mode or event mode.
  * In pulse mode, both Sync Start and End packets are required.
@@ -324,29 +304,15 @@
  *
  * @param mfd
  *
- * @return int
+ * @return register data value
  */
 static int mipi_d2l_dsi_init_sequence(struct msm_fb_data_type *mfd)
 {
 	struct mipi_panel_info *mipi = &mfd->panel_info.mipi;
 	u32 lanes_enable;
 	u32 vpctrl;
-	u32 htime1;
-	u32 vtime1;
-	u32 htime2;
-	u32 vtime2;
-	u32 ppi_tx_rx_ta; /* BTA Bus-Turn-Around */
-	u32 lvcfg;
-	u32 hbpr;	/* Horizontal Back Porch */
-	u32 hpw;	/* Horizontal Pulse Width */
-	u32 vbpr;	/* Vertical Back Porch */
-	u32 vpw;	/* Vertical Pulse Width */
-
-	u32 hfpr;	/* Horizontal Front Porch */
-	u32 hsize;	/* Horizontal Active size */
-	u32 vfpr;	/* Vertical Front Porch */
-	u32 vsize;	/* Vertical Active size */
-	bool vesa_rgb888 = false;
+	u32 htime1 = 0x002C0028;
+	u32 vtime1 = 0x001E0008;
 
 	lanes_enable = 0x01; /* clock-lane enable */
 	lanes_enable |= (mipi->data_lane0 << 1);
@@ -364,70 +330,25 @@
 		return -EINVAL;
 	}
 
-	if (mfd->panel_info.clk_rate > 800*1000*1000) {
-		pr_err("%s.unsupported clk_rate %d.\n",
-		       __func__, mfd->panel_info.clk_rate);
-		return -EINVAL;
-	}
-
-	pr_debug("%s.xres=%d.yres=%d.fps=%d.dst_format=%d.\n",
-		__func__,
-		 mfd->panel_info.xres,
-		 mfd->panel_info.yres,
-		 mfd->panel_info.mipi.frame_rate,
-		 mfd->panel_info.mipi.dst_format);
-
-	hbpr = mfd->panel_info.lcdc.h_back_porch;
-	hpw	= mfd->panel_info.lcdc.h_pulse_width;
-	vbpr = mfd->panel_info.lcdc.v_back_porch;
-	vpw	= mfd->panel_info.lcdc.v_pulse_width;
-
-	htime1 = (hbpr << 16) + hpw;
-	vtime1 = (vbpr << 16) + vpw;
-
-	hfpr = mfd->panel_info.lcdc.h_front_porch;
-	hsize = mfd->panel_info.xres;
-	vfpr = mfd->panel_info.lcdc.v_front_porch;
-	vsize = mfd->panel_info.yres;
-
-	htime2 = (hfpr << 16) + hsize;
-	vtime2 = (vfpr << 16) + vsize;
-
-	lvcfg = 0x0003; /* PCLK=DCLK/3, Dual Link, LVEN */
-	vpctrl = 0x01000120; /* Output RGB888 , Event-Mode , */
-	ppi_tx_rx_ta = 0x00040004;
-
-	if (mfd->panel_info.xres == 1366) {
-		ppi_tx_rx_ta = 0x00040004;
-		lvcfg = 0x01; /* LVEN */
-		vesa_rgb888 = true;
-	}
-
-	if (mfd->panel_info.xres == 1200) {
-		lvcfg = 0x0103; /* PCLK=DCLK/4, Dual Link, LVEN */
-		vesa_rgb888 = true;
-	}
-
 	pr_debug("%s.htime1=0x%x.\n", __func__, htime1);
 	pr_debug("%s.vtime1=0x%x.\n", __func__, vtime1);
 	pr_debug("%s.vpctrl=0x%x.\n", __func__, vpctrl);
-	pr_debug("%s.lvcfg=0x%x.\n", __func__, lvcfg);
+	pr_debug("%s.lanes_enable=0x%x.\n", __func__, lanes_enable);
+
 
 	mipi_d2l_write_reg(mfd, SYSRST, 0xFF);
 	msleep(30);
 
-	if (vesa_rgb888) {
-		/* VESA format instead of JEIDA format for RGB888 */
-		mipi_d2l_write_reg(mfd, LVMX0003, 0x03020100);
-		mipi_d2l_write_reg(mfd, LVMX0407, 0x08050704);
-		mipi_d2l_write_reg(mfd, LVMX0811, 0x0F0E0A09);
-		mipi_d2l_write_reg(mfd, LVMX1215, 0x100D0C0B);
-		mipi_d2l_write_reg(mfd, LVMX1619, 0x12111716);
-		mipi_d2l_write_reg(mfd, LVMX2023, 0x1B151413);
-		mipi_d2l_write_reg(mfd, LVMX2427, 0x061A1918);
-	}
+	/* VESA format instead of JEIDA format for RGB888 */
+	mipi_d2l_write_reg(mfd, LVMX0003, 0x03020100);
+	mipi_d2l_write_reg(mfd, LVMX0407, 0x08050704);
+	mipi_d2l_write_reg(mfd, LVMX0811, 0x0F0E0A09);
+	mipi_d2l_write_reg(mfd, LVMX1215, 0x100D0C0B);
+	mipi_d2l_write_reg(mfd, LVMX1619, 0x12111716);
+	mipi_d2l_write_reg(mfd, LVMX2023, 0x1B151413);
+	mipi_d2l_write_reg(mfd, LVMX2427, 0x061A1918);
 
-	mipi_d2l_write_reg(mfd, PPI_TX_RX_TA, ppi_tx_rx_ta); /* BTA */
+	mipi_d2l_write_reg(mfd, PPI_TX_RX_TA, 0x00040004); /* BTA */
 	mipi_d2l_write_reg(mfd, PPI_LPTXTIMECNT, 0x00000004);
 	mipi_d2l_write_reg(mfd, PPI_D0S_CLRSIPOCOUNT, 0x00000003);
 	mipi_d2l_write_reg(mfd, PPI_D1S_CLRSIPOCOUNT, 0x00000003);
@@ -441,10 +362,8 @@
 	mipi_d2l_write_reg(mfd, VPCTRL, vpctrl); /* RGB888 + Event mode */
 	mipi_d2l_write_reg(mfd, HTIM1, htime1);
 	mipi_d2l_write_reg(mfd, VTIM1, vtime1);
-	mipi_d2l_write_reg(mfd, HTIM2, htime2);
-	mipi_d2l_write_reg(mfd, VTIM2, vtime2);
 	mipi_d2l_write_reg(mfd, VFUEN, 0x00000001);
-	mipi_d2l_write_reg(mfd, LVCFG, lvcfg); /* Enables LVDS tx */
+	mipi_d2l_write_reg(mfd, LVCFG, 0x00000001); /* Enables LVDS tx */
 
 	return 0;
 }
@@ -481,35 +400,6 @@
 		return ret;
 	}
 
-	return 0;
-}
-
-/**
- * Set TN CLK.
- *
- * @param pwm
- * @param level
- *
- * @return int
- */
-static int mipi_d2l_set_tn_clk(struct pwm_device *pwm, u32 usec)
-{
-	int ret = 0;
-
-	pr_debug("%s: usec=%d.\n", __func__, usec);
-
-	ret = pwm_config(pwm, usec/2 , usec);
-	if (ret) {
-		pr_err("%s: pwm_config() failed err=%d.\n", __func__, ret);
-		return ret;
-	}
-
-	ret = pwm_enable(pwm);
-	if (ret) {
-		pr_err("%s: pwm_enable() failed err=%d\n",
-		       __func__, ret);
-		return ret;
-	}
 
 	return 0;
 }
@@ -556,14 +446,9 @@
 		return ret;
 
 	mipi_d2l_write_reg(mfd, GPIOC, d2l_gpio_out_mask);
-	/* Set gpio#4=U/D=0, gpio#3=L/R=1 , gpio#2,1=CABC=0, gpio#0=NA. */
+	/* Set GPIOs: gpio#4=U/D=0 , gpio#3=L/R=1 , gpio#2,1=CABC=0. */
 	mipi_d2l_write_reg(mfd, GPIOO, d2l_gpio_out_val);
 
-	if (mfd->panel_info.xres == 1366)
-		d2l_pwm_freq_hz = (66*1000);
-	else
-		d2l_pwm_freq_hz = (25*1000);
-
 	if (bl_level == 0)
 		bl_level = PWM_LEVEL * 2 / 3 ; /* Default ON value */
 
@@ -575,14 +460,6 @@
 			       __func__, ret);
 	}
 
-	mipi_d2l_read_status(mfd);
-
-	mipi_d2l_enable_3d(mfd, false, false);
-
-	/* Add I2C driver only after DSI-CLK is running */
-	if (d2l_i2c_client == NULL)
-		i2c_add_driver(&d2l_i2c_slave_driver);
-
 	pr_info("%s.ret=%d.\n", __func__, ret);
 
 	return ret;
@@ -633,197 +510,6 @@
 	.set_backlight = mipi_d2l_set_backlight,
 };
 
-static u32 d2l_i2c_read_reg(struct i2c_client *client, u16 reg)
-{
-	int rc;
-	u32 val = 0;
-	u8 buf[6];
-
-	if (client == NULL) {
-		pr_err("%s.invalid i2c client.\n", __func__);
-		return -EINVAL;
-	}
-
-	buf[0] = reg >> 8;
-	buf[1] = reg & 0xFF;
-
-	rc = i2c_master_send(client, buf, sizeof(reg));
-	rc = i2c_master_recv(client, buf, 4);
-
-	if (rc >= 0) {
-		val = buf[0] + (buf[1] << 8) + (buf[2] << 16) + (buf[3] << 24);
-		pr_debug("%s.reg=0x%x.val=0x%x.\n", __func__, reg, val);
-	} else
-		pr_err("%s.fail.reg=0x%x.\n", __func__, reg);
-
-	return val;
-}
-
-static u32 d2l_i2c_write_reg(struct i2c_client *client, u16 reg, u32 val)
-{
-	int rc;
-	u8 buf[6];
-
-	if (client == NULL) {
-		pr_err("%s.invalid i2c client.\n", __func__);
-		return -EINVAL;
-	}
-
-	buf[0] = reg >> 8;
-	buf[1] = reg & 0xFF;
-
-	buf[2] = (val >> 0) & 0xFF;
-	buf[3] = (val >> 8) & 0xFF;
-	buf[4] = (val >> 16) & 0xFF;
-	buf[5] = (val >> 24) & 0xFF;
-
-	rc = i2c_master_send(client, buf, sizeof(buf));
-
-	if (rc >= 0)
-		pr_debug("%s.reg=0x%x.val=0x%x.\n", __func__, reg, val);
-	else
-		pr_err("%s.fail.reg=0x%x.\n", __func__, reg);
-
-	return val;
-}
-
-static int __devinit d2l_i2c_slave_probe(struct i2c_client *client,
-					 const struct i2c_device_id *id)
-{
-	static const u32 i2c_funcs = I2C_FUNC_I2C;
-
-	d2l_i2c_client = client;
-
-	if (!i2c_check_functionality(client->adapter, i2c_funcs)) {
-		pr_err("%s.i2c_check_functionality failed.\n", __func__);
-		return -ENOSYS;
-	} else {
-		pr_debug("%s.i2c_check_functionality OK.\n", __func__);
-	}
-
-	d2l_i2c_read_reg(client, IDREG);
-
-	mipi_d2l_read_status_via_i2c(d2l_i2c_client);
-
-	return 0;
-}
-
-static __devexit int d2l_i2c_slave_remove(struct i2c_client *client)
-{
-	d2l_i2c_client = NULL;
-
-	return 0;
-}
-
-static const struct i2c_device_id d2l_i2c_id[] = {
-	{"tc358764-i2c", 0},
-	{}
-};
-
-static struct i2c_driver d2l_i2c_slave_driver = {
-	.driver = {
-		.name = "tc358764-i2c",
-		.owner = THIS_MODULE
-	},
-	.probe    = d2l_i2c_slave_probe,
-	.remove   = __devexit_p(d2l_i2c_slave_remove),
-	.id_table = d2l_i2c_id,
-};
-
-static int mipi_d2l_enable_3d(struct msm_fb_data_type *mfd,
-			      bool enable, bool mode)
-{
-	u32 tn_usec = 1000000 / 66; /* 66 HZ */
-
-	pr_debug("%s.enable=%d.mode=%d.\n", __func__, enable, mode);
-
-	gpio_direction_output(d2l_3d_gpio_enable, enable);
-	gpio_direction_output(d2l_3d_gpio_mode, mode);
-
-	mipi_d2l_set_tn_clk(tn_pwm, tn_usec);
-
-	return 0;
-}
-
-static ssize_t mipi_d2l_enable_3d_read(struct device *dev,
-				struct device_attribute *attr,
-				char *buf)
-{
-	return snprintf((char *)buf, sizeof(buf), "%u\n", d2l_enable_3d);
-}
-
-static ssize_t mipi_d2l_enable_3d_write(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf,
-				size_t count)
-{
-	int ret = -1;
-	u32 data = 0;
-
-	if (sscanf((char *)buf, "%u", &data) != 1) {
-		dev_err(dev, "%s. Invalid input.\n", __func__);
-		ret = -EINVAL;
-	} else {
-		d2l_enable_3d = data;
-		if (data == 1) /* LANDSCAPE */
-			mipi_d2l_enable_3d(d2l_mfd, true, true);
-		else if (data == 2) /* PORTRAIT */
-			mipi_d2l_enable_3d(d2l_mfd, true, false);
-		else if (data == 0)
-			mipi_d2l_enable_3d(d2l_mfd, false, false);
-		else if (data == 9)
-			mipi_d2l_read_status_via_i2c(d2l_i2c_client);
-		else
-			pr_err("%s.Invalid value=%d.\n", __func__, data);
-	}
-
-	return count;
-}
-
-static struct device_attribute mipi_d2l_3d_barrier_attributes[] = {
-	__ATTR(enable_3d_barrier, 0666,
-	       mipi_d2l_enable_3d_read,
-	       mipi_d2l_enable_3d_write),
-};
-
-static int mipi_dsi_3d_barrier_sysfs_register(struct device *dev)
-{
-	int ret;
-
-	pr_debug("%s.d2l_3d_gpio_enable=%d.\n", __func__, d2l_3d_gpio_enable);
-	pr_debug("%s.d2l_3d_gpio_mode=%d.\n", __func__, d2l_3d_gpio_mode);
-
-	ret  = device_create_file(dev, mipi_d2l_3d_barrier_attributes);
-	if (ret) {
-		pr_err("%s.failed to create 3D sysfs.\n", __func__);
-		goto err_device_create_file;
-	}
-
-	ret = gpio_request(d2l_3d_gpio_enable, "d2l_3d_gpio_enable");
-	if (ret) {
-		pr_err("%s.failed to get d2l_3d_gpio_enable=%d.\n",
-		       __func__, d2l_3d_gpio_enable);
-		goto err_d2l_3d_gpio_enable;
-	}
-
-	ret = gpio_request(d2l_3d_gpio_mode, "d2l_3d_gpio_mode");
-	if (ret) {
-		pr_err("%s.failed to get d2l_3d_gpio_mode=%d.\n",
-		       __func__, d2l_3d_gpio_mode);
-		goto err_d2l_3d_gpio_mode;
-	}
-
-	return 0;
-
-err_d2l_3d_gpio_mode:
-	gpio_free(d2l_3d_gpio_enable);
-err_d2l_3d_gpio_enable:
-	device_remove_file(dev, mipi_d2l_3d_barrier_attributes);
-err_device_create_file:
-
-	return ret;
-}
-
 /**
  * Probe for device.
  *
@@ -844,6 +530,7 @@
 	pr_debug("%s.id=%d.\n", __func__, pdev->id);
 
 	if (pdev->id == 0) {
+		/* d2l_common_pdata = platform_get_drvdata(pdev); */
 		d2l_common_pdata = pdev->dev.platform_data;
 
 		if (d2l_common_pdata == NULL) {
@@ -854,8 +541,6 @@
 		led_pwm = d2l_common_pdata->gpio_num[0];
 		d2l_gpio_out_mask = d2l_common_pdata->gpio_num[1] >> 8;
 		d2l_gpio_out_val = d2l_common_pdata->gpio_num[1] & 0xFF;
-		d2l_3d_gpio_enable = d2l_common_pdata->gpio_num[2];
-		d2l_3d_gpio_mode = d2l_common_pdata->gpio_num[3];
 
 		mipi_dsi_buf_alloc(&d2l_tx_buf, DSI_BUF_SIZE);
 		mipi_dsi_buf_alloc(&d2l_rx_buf, DSI_BUF_SIZE);
@@ -882,20 +567,10 @@
 
 		}
 	} else {
-		pr_err("%s. led_pwm is invalid.\n", __func__);
-	}
-
-	tn_pwm = pwm_request(1, "3D_TN_clk");
-	if (tn_pwm == NULL || IS_ERR(tn_pwm)) {
-		pr_err("%s pwm_request() failed.id=%d.tn_pwm=%d.\n",
-		       __func__, 1, (int) tn_pwm);
-		tn_pwm = NULL;
-		return -EIO;
-	} else {
-		pr_debug("%s.pwm_request() ok.pwm-id=%d.\n", __func__, 1);
-
+		pr_info("%s. led_pwm is invalid.\n", __func__);
 	}
 
+	/* pinfo = platform_get_drvdata(pdev); */
 	pinfo = pdev->dev.platform_data;
 
 	if (pinfo == NULL) {
@@ -909,9 +584,6 @@
 
 	msm_fb_add_device(pdev);
 
-	if (pinfo->is_3d_panel)
-		mipi_dsi_3d_barrier_sysfs_register(&(pdev->dev));
-
 	return ret;
 }
 
@@ -995,9 +667,6 @@
 static int mipi_d2l_init(void)
 {
 	pr_debug("%s.\n", __func__);
-
-	d2l_i2c_client = NULL;
-
 	return platform_driver_register(&d2l_driver);
 }
 
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/msm_dss_io_8x60.c msm/msm_dss_io_8x60.c
--- /home/shade/kernel-msm/drivers/video/msm/msm_dss_io_8x60.c	2012-08-20 15:40:53.090119031 -0700
+++ msm/msm_dss_io_8x60.c	2012-08-17 10:16:29.792174031 -0700
@@ -638,18 +638,20 @@
 
 void hdmi_msm_powerdown_phy(void)
 {
-	/* Assert RESET PHY from controller */
-	HDMI_OUTP_ND(0x02D4, 0x4);
-	udelay(10);
-	/* De-assert RESET PHY from controller */
-	HDMI_OUTP_ND(0x02D4, 0x0);
-	/* Turn off Driver */
-	HDMI_OUTP_ND(0x0308, 0x1F);
-	udelay(10);
 	/* Disable PLL */
 	HDMI_OUTP_ND(0x030C, 0x00);
+
+#ifdef WORKAROUND_FOR_HDMI_CURRENT_LEAKAGE_FIX
+	HDMI_OUTP_ND(0x02D4, 0x4);	//Assert RESET PHY from controller
+	udelay(10);
+	HDMI_OUTP_ND(0x02D4, 0x0);	//De-assert RESET PHY from controller
+	HDMI_OUTP_ND(0x0308, 0x1F); //Turn off Driver
+	udelay(10);
+#endif
+
 	/* Power down PHY */
-	HDMI_OUTP_ND(0x0308, 0x7F); /*0b01111111*/
+	//HDMI_OUTP_ND(0x0308, 0x7F); /*0b01111111*/
+	HDMI_OUTP_ND(0x0308, 0xFF); /*0b11111111*/
 }
 
 void hdmi_frame_ctrl_cfg(const struct hdmi_disp_mode_timing_type *timing)
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/msm_fb.c msm/msm_fb.c
--- /home/shade/kernel-msm/drivers/video/msm/msm_fb.c	2012-08-20 15:41:33.596116264 -0700
+++ msm/msm_fb.c	2012-08-20 11:19:05.809193098 -0700
@@ -48,6 +48,16 @@
 #include "mdp.h"
 #include "mdp4.h"
 
+#ifdef CONFIG_FB_MSM_LOGO
+#define INIT_IMAGE_FILE "/initlogo.rle"
+extern int load_565rle_image(char *filename, bool bf_supported);
+#define LPM_INIT_IMAGE_FILE "/lpminitlogo.rle"
+#if (defined(CONFIG_TARGET_SERIES_P5LTE) || defined(CONFIG_TARGET_SERIES_P8LTE)) && defined(CONFIG_TARGET_LOCALE_KOR)
+#define CHARGING_IMAGE_FILE "/charging_image.rle"
+#endif
+extern unsigned int is_lpcharging_state(void);
+#endif
+
 #ifdef CONFIG_FB_MSM_TRIPLE_BUFFER
 #define MSM_FB_NUM	3
 #endif
@@ -415,11 +425,11 @@
 
 	msm_fb_remove_sysfs(pdev);
 
-	pm_runtime_disable(mfd->fbi->dev);
-
 	if (!mfd)
 		return -ENODEV;
 
+	pm_runtime_disable(mfd->fbi->dev);
+
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
@@ -763,11 +773,36 @@
 	(*bl_lvl) = temp;
 }
 
+#ifdef CONFIG_BATTERY_SEC
+extern unsigned int is_lpcharging_state(void);
+#endif
+
 void msm_fb_set_backlight(struct msm_fb_data_type *mfd, __u32 bkl_lvl)
 {
 	struct msm_fb_panel_data *pdata;
 	__u32 temp = bkl_lvl;
+
+#ifdef CONFIG_BATTERY_SEC
+	if(is_lpcharging_state() == 1)
+	{
+		printk("msm_fb_set_backlight : lpm mode!\n");
+		pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
+
+		if ((pdata) && (pdata->set_backlight)) {
+			down(&mfd->sem);
+			mfd->bl_level = bkl_lvl;
+			pdata->set_backlight(mfd);
+			up(&mfd->sem);
+		}
+	}
+#endif	
+
+
+#ifdef CONFIG_TARGET_SERIES_P8LTE
+	if (!mfd->panel_power_on) {
+#else
 	if (!mfd->panel_power_on || !bl_updated) {
+#endif
 		unset_bl_level = bkl_lvl;
 		return;
 	} else {
@@ -1064,6 +1099,7 @@
 	struct fb_var_screeninfo *var;
 	int *id;
 	int fbram_offset;
+	char *logofilename = NULL;
 	int remainder, remainder_mode2;
 	static int subsys_id[2] = {MSM_SUBSYSTEM_DISPLAY,
 		MSM_SUBSYSTEM_ROTATOR};
@@ -1087,8 +1123,16 @@
 	var->grayscale = 0,	/* No graylevels */
 	var->nonstd = 0,	/* standard pixel format */
 	var->activate = FB_ACTIVATE_VBL,	/* activate it at vsync */
+#ifdef CONFIG_FB_MSM_MIPI_S6E8AA0_HD720_PANEL
+	var->height = 103,	/* height of picture in mm */
+	var->width = 58,	/* width of picture in mm */
+#elif defined(CONFIG_FB_MSM_MIPI_S6D6AA0_WXGA_PANEL) || defined(CONFIG_FB_MSM_MIPI_S6E8AA0_WXGA_Q1_PANEL)
+	var->height = 114,	/* height of picture in mm */
+	var->width = 71,	/* width of picture in mm */
+#else
 	var->height = -1,	/* height of picture in mm */
 	var->width = -1,	/* width of picture in mm */
+#endif
 	var->accel_flags = 0,	/* acceleration flags */
 	var->sync = 0,	/* see FB_SYNC_* */
 	var->rotate = 0,	/* angle we rotate counter clockwise */
@@ -1404,9 +1448,23 @@
 	     mfd->index, fbi->var.xres, fbi->var.yres, fbi->fix.smem_len);
 
 #ifdef CONFIG_FB_MSM_LOGO
-	/* Flip buffer */
-	if (!load_565rle_image(INIT_IMAGE_FILE, bf_supported))
-		;
+	if(mfd->index == 0)
+    {
+		if (is_lpcharging_state() == 1) {
+#if (defined(CONFIG_TARGET_SERIES_P5LTE) || defined(CONFIG_TARGET_SERIES_P8LTE)) && defined(CONFIG_TARGET_LOCALE_KOR)
+			logofilename = CHARGING_IMAGE_FILE;
+#else
+			//logofilename = LPM_INIT_IMAGE_FILE;
+			logofilename = NULL;
+			MSM_FB_INFO ("[lpm-mode] skip init logo!\n");
+#endif
+		} else {
+			logofilename = INIT_IMAGE_FILE;
+		}
+
+		if (logofilename != NULL)
+			load_565rle_image(logofilename, bf_supported);
+	}
 #endif
 	ret = 0;
 
@@ -1573,9 +1631,13 @@
 			pr_debug("%s:%d no mdp_set_dma_pan_info %d\n",
 				__func__, __LINE__, info->node);
 
-		if (msm_fb_blank_sub(FB_BLANK_UNBLANK, info, mfd->op_enable)) {
-			printk(KERN_ERR "msm_fb_open: can't turn on display!\n");
-			return -1;
+		if (mfd->panel_info.type != DTV_PANEL) {
+			if (msm_fb_blank_sub(FB_BLANK_UNBLANK, info,
+							mfd->op_enable)) {
+				printk(KERN_ERR "msm_fb_open: "
+						"can't turn on display!\n");
+				return -1;
+			}
 		}
 	}
 
@@ -1684,8 +1746,7 @@
 	if (mfd->msmfb_no_update_notify_timer.function)
 		del_timer(&mfd->msmfb_no_update_notify_timer);
 
-	mfd->msmfb_no_update_notify_timer.expires =
-				jiffies + ((1000 * HZ) / 1000);
+	mfd->msmfb_no_update_notify_timer.expires = jiffies + (2 * HZ);
 	add_timer(&mfd->msmfb_no_update_notify_timer);
 	mutex_unlock(&msm_fb_notify_update_sem);
 
@@ -2303,6 +2364,8 @@
 
 		/* blit first region */
 		if (((splitreq.flags & 0x07) == 0x07) ||
+			((splitreq.flags & 0x07) == 0x05) ||
+			((splitreq.flags & 0x07) == 0x02) ||
 			((splitreq.flags & 0x07) == 0x0)) {
 
 			if (splitreq.flags & MDP_ROT_90) {
@@ -2383,6 +2446,8 @@
 
 		/* blit second region */
 		if (((splitreq.flags & 0x07) == 0x07) ||
+			((splitreq.flags & 0x07) == 0x05) ||
+			((splitreq.flags & 0x07) == 0x02) ||
 			((splitreq.flags & 0x07) == 0x0)) {
 			splitreq.src_rect.h = s_h_1;
 			splitreq.src_rect.y = s_y_1;
@@ -2869,8 +2934,7 @@
 	if (mfd->msmfb_no_update_notify_timer.function)
 		del_timer(&mfd->msmfb_no_update_notify_timer);
 
-	mfd->msmfb_no_update_notify_timer.expires =
-				jiffies + ((1000 * HZ) / 1000);
+	mfd->msmfb_no_update_notify_timer.expires = jiffies + (2 * HZ);
 	add_timer(&mfd->msmfb_no_update_notify_timer);
 	mutex_unlock(&msm_fb_notify_update_sem);
 
@@ -3599,6 +3663,8 @@
 EXPORT_SYMBOL(msm_fb_writeback_terminate);
 #endif
 
+extern void sec_getlog_supply_fbinfo(void *p_fb, u32 xres, u32 yres, u32 bpp, u32 frames);
+
 struct platform_device *msm_fb_add_device(struct platform_device *pdev)
 {
 	struct msm_fb_panel_data *pdata;
@@ -3692,6 +3758,15 @@
 		fbi_list_index--;
 		return NULL;
 	}
+
+#ifdef CONFIG_SEC_DEBUG
+	if (fbi_list_index == 1) {
+		sec_getlog_supply_fbinfo((void *)(fbi->fix.smem_start - 0x400000),
+					 fbi->var.xres,
+					 fbi->var.yres,
+					 fbi->var.bits_per_pixel, 2);
+	}
+#endif
 	return this_dev;
 }
 EXPORT_SYMBOL(msm_fb_add_device);
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/msm_fb.h msm/msm_fb.h
--- /home/shade/kernel-msm/drivers/video/msm/msm_fb.h	2012-08-20 15:41:33.597116264 -0700
+++ msm/msm_fb.h	2012-08-20 11:19:05.801193096 -0700
@@ -47,6 +47,9 @@
 #include "msm_fb_panel.h"
 #include "mdp.h"
 
+#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL
+#define HDMI_VIDEO_QUANTIZATION_ISSUE
+#endif
 #define MSM_FB_DEFAULT_PAGE_SIZE 2
 #define MFD_KEY  0x11161126
 #define MSM_FB_MAX_DEV_LIST 32
Only in msm: p5lte_cmc623_tune.h
Only in msm: p8lte_cmc624_tune.h
Only in msm: pxlte_cmc623.c
Only in msm: pxlte_cmc623.h
Only in msm: pxlte_cmc624.c
Only in msm: pxlte_cmc624.h
Only in msm: s6e8aa0_volt_tbl.h
Only in msm: s6e8ab0_volt_tbl.h
Only in msm: s6ea8868_volt_tbl.h
Only in msm: sec_cmc_esd_refresh.c
Only in msm: sec_cmc_esd_refresh_p8.c
Only in msm: sec_mipi_lcd_esd_refresh.c
Only in msm: sec_mipi_lcd_esd_refresh_p8.c
Only in msm: smart_dimming.c
Only in msm: smart_dimming_ea8868.c
Only in msm: smart_dimming_ea8868.h
Only in msm: smart_dimming.h
Only in msm: smart_dimming_s6e8ab0.c
Only in msm: smart_dimming_s6e8ab0.h
Only in msm: smart_mtp_2p2_gamma.h
Only in msm: smart_mtp_s6e63m0.c
Only in msm: smart_mtp_s6e63m0.h
Only in /home/shade/kernel-msm/drivers/video/msm/vidc/1080p/ddl: .vcd_ddl_interrupt_handler.c.swp
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c msm/vidc/1080p/ddl/vcd_ddl_properties.c
--- /home/shade/kernel-msm/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c	2012-08-20 15:40:53.093119033 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_properties.c	2012-08-17 10:16:29.797174031 -0700
@@ -1594,6 +1594,7 @@
 			vcd_status = VCD_S_SUCCESS;
 		}
 	}
+	break;
 	case VCD_I_INTRA_REFRESH:
 	{
 		struct vcd_property_intra_refresh_mb_number
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c
--- /home/shade/kernel-msm/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c	2012-08-20 15:40:53.094119033 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c	2012-08-17 10:16:29.797174031 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -229,15 +229,6 @@
 #define VIDC_SM_CHROMA_ADDR_CHANGE_BMASK  0x00000001
 #define VIDC_SM_CHROMA_ADDR_CHANGE_SHFT   0
 
-#define VIDC_SM_ERROR_CONCEALMENT_CONFIG_ADDR   0x0154
-
-#define VIDC_SM_ERROR_CONCEALMENT_CONFIG_INTER_SLICE_BMSK  0x0c
-#define VIDC_SM_ERROR_CONCEALMENT_CONFIG_INTER_SLICE_SHFT 2
-#define VIDC_SM_ERROR_CONCEALMENT_CONFIG_INTRA_SLICE_BMSK 0X02
-#define VIDC_SM_ERROR_CONCEALMENT_CONFIG_INTRA_SLICE_SHFT 1
-#define VIDC_SM_ERROR_CONCEALMENT_CONFIG_CONCEAL_ENABLE_BMSK  0x01
-#define VIDC_SM_ERROR_CONCEALMENT_CONFIG_CONCEAL_ENABLE_SHFT   0
-
 #define VIDC_SM_SEI_ENABLE_ADDR                     0x0180
 #define VIDC_SM_SEI_ENABLE_RECOVERY_POINT_SEI_BMSK  0x00000001
 #define VIDC_SM_SEI_ENABLE_RECOVERY_POINT_SEI_SHFT  0
@@ -773,40 +764,12 @@
 	*sei_enable = DDL_MEM_READ_32(shared_mem, VIDC_SM_SEI_ENABLE_ADDR);
 }
 
-void vidc_sm_set_error_concealment_config(struct ddl_buf_addr *shared_mem,
-	u32 inter_slice, u32 intra_slice, u32 conceal_config_enable)
-{
-	u32 error_conceal_config = 0;
-
-	error_conceal_config = VIDC_SETFIELD(inter_slice,
-			VIDC_SM_ERROR_CONCEALMENT_CONFIG_INTER_SLICE_SHFT,
-			VIDC_SM_ERROR_CONCEALMENT_CONFIG_INTER_SLICE_BMSK);
-
-	error_conceal_config |= VIDC_SETFIELD(intra_slice,
-			VIDC_SM_ERROR_CONCEALMENT_CONFIG_INTRA_SLICE_SHFT,
-			VIDC_SM_ERROR_CONCEALMENT_CONFIG_INTRA_SLICE_BMSK);
-
-	error_conceal_config |= VIDC_SETFIELD(conceal_config_enable,
-			VIDC_SM_ERROR_CONCEALMENT_CONFIG_CONCEAL_ENABLE_SHFT,
-			VIDC_SM_ERROR_CONCEALMENT_CONFIG_CONCEAL_ENABLE_BMSK);
-
-	DDL_MEM_WRITE_32(shared_mem, VIDC_SM_ERROR_CONCEALMENT_CONFIG_ADDR,
-			error_conceal_config);
-}
-
 void vidc_sm_set_decoder_stuff_bytes_consumption(
 	struct ddl_buf_addr *shared_mem,
 	enum vidc_sm_num_stuff_bytes_consume_info consume_info)
 {
 	DDL_MEM_WRITE_32(shared_mem, VIDC_SM_NUM_STUFF_BYTES_CONSUME_ADDR,
-	consume_info);
-}
-
-void vidc_sm_set_video_core_timeout_value(struct ddl_buf_addr *shared_mem,
-        u32 timeout)
-{
-    DDL_MEM_WRITE_32(shared_mem, VIDC_SM_TIMEOUT_VALUE_ADDR,
-        timeout);
+			consume_info);
 }
 
 void vidc_sm_get_aspect_ratio_info(struct ddl_buf_addr *shared_mem,
@@ -849,6 +812,13 @@
             VIDC_SM_ENC_NUM_OF_SLICE_COMP_ADDR);
 }
 
+void vidc_sm_set_video_core_timeout_value(struct ddl_buf_addr *shared_mem,
+	u32 timeout)
+{
+	DDL_MEM_WRITE_32(shared_mem, VIDC_SM_TIMEOUT_VALUE_ADDR,
+			timeout);
+}
+
 void vidc_sm_set_encoder_batch_config(struct ddl_buf_addr *shared_mem,
         u32 num_slices,
         u32 input_addr, u32 output_addr,
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h
--- /home/shade/kernel-msm/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h	2012-08-20 15:40:53.094119033 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h	2012-08-17 10:16:29.797174031 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -174,15 +174,13 @@
 	u32 sei_enable);
 void vidc_sm_get_decoder_sei_enable(struct ddl_buf_addr *shared_mem,
 	u32 *sei_enable);
-void vidc_sm_set_error_concealment_config(struct ddl_buf_addr *shared_mem,
-	u32 inter_slice, u32 intra_slice, u32 conceal_config_enable);
 void vidc_sm_set_decoder_stuff_bytes_consumption(
 	struct ddl_buf_addr *shared_mem,
 	enum vidc_sm_num_stuff_bytes_consume_info consume_info);
-void vidc_sm_set_video_core_timeout_value(struct ddl_buf_addr *shared_mem,
-    u32 timeout);
 void vidc_sm_get_aspect_ratio_info(struct ddl_buf_addr *shared_mem,
 	struct vcd_aspect_ratio *aspect_ratio_info);
+void vidc_sm_set_video_core_timeout_value(struct ddl_buf_addr *shared_mem,
+        u32 timeout);
 void vidc_sm_set_encoder_slice_batch_int_ctrl(struct ddl_buf_addr *shared_mem,
     u32 slice_batch_int_enable);
 void vidc_sm_get_num_slices_comp(struct ddl_buf_addr *shared_mem,
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c msm/vidc/1080p/ddl/vcd_ddl_vidc.c
--- /home/shade/kernel-msm/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c	2012-08-20 15:40:53.094119033 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_vidc.c	2012-08-17 10:16:29.798174030 -0700
@@ -23,6 +23,10 @@
 #endif
 static unsigned int run_cnt;
 
+/* MMRND_AVRC. Start */
+#define QCIF_WIDTH   176
+#define QCIF_HEIGHT  144
+/* MMRND_AVRC. End */
 void ddl_vidc_core_init(struct ddl_context *ddl_context)
 {
 	struct vidc_1080P_pix_cache_config pixel_cache_config;
@@ -570,6 +574,13 @@
 		(DDL_FRAMERATE_SCALE(DDL_INITIAL_FRAME_RATE)
 		 != scaled_frame_rate))
 		h263_cpfc_enable = true;
+/* MMRND_AVRC. Start */
+	/* added for MMS plus header issue */
+	if ((encoder->codec.codec == VCD_CODEC_H263) &&
+			(encoder->frame_size.width == QCIF_WIDTH) &&
+			(encoder->frame_size.height == QCIF_HEIGHT))
+		h263_cpfc_enable = false;
+/* MMRND_AVRC. End */
 	vidc_sm_set_extended_encoder_control(&ddl->shared_mem
 		[ddl->command_channel], hdr_ext_control,
 		r_cframe_skip, false, 0,
diff --unified -r /home/shade/kernel-msm/drivers/video/msm/vidc/common/vcd/vcd_client_sm.c msm/vidc/common/vcd/vcd_client_sm.c
--- /home/shade/kernel-msm/drivers/video/msm/vidc/common/vcd/vcd_client_sm.c	2012-08-20 15:40:53.191119025 -0700
+++ msm/vidc/common/vcd/vcd_client_sm.c	2012-08-17 10:16:29.800174030 -0700
@@ -1616,6 +1616,7 @@
 	if (!cctxt || to_state >= VCD_CLIENT_STATE_MAX) {
 		VCD_MSG_ERROR("Bad parameters. cctxt=%p, to_state=%d",
 			      cctxt, to_state);
+        return ;
 	}
 
 	state_ctxt = &cctxt->clnt_state;
