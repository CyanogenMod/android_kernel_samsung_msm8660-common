diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/adv7520.c msm/adv7520.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/adv7520.c	2012-08-08 09:32:42.755525958 -0700
+++ msm/adv7520.c	2012-08-14 12:32:39.474339485 -0700
@@ -18,7 +18,12 @@
 #include <linux/completion.h>
 #include <linux/wakelock.h>
 #include <linux/clk.h>
+#include <linux/pm_qos.h>
+
 #include <asm/atomic.h>
+
+#include <mach/cpuidle.h>
+
 #include "msm_fb.h"
 
 #define DEBUG
@@ -64,7 +69,7 @@
 static unsigned int monitor_sense;
 static boolean hpd_cable_chg_detected;
 
-struct wake_lock wlock;
+static struct pm_qos_request pm_qos_req;
 
 /* Change HDMI state */
 static void change_hdmi_state(int online)
@@ -366,7 +371,7 @@
 	} else
 		DEV_INFO("power_on: cable NOT detected\n");
 	adv7520_comm_power(0, 1);
-	wake_lock(&wlock);
+	pm_qos_update_request(&pm_qos_req, msm_cpuidle_get_deep_idle_latency());
 
 	return 0;
 }
@@ -376,7 +381,7 @@
 	DEV_INFO("power_off\n");
 	adv7520_comm_power(1, 1);
 	adv7520_chip_off();
-	wake_unlock(&wlock);
+	pm_qos_update_request(&pm_qos_req, PM_QOS_DEFAULT_VALUE);
 	adv7520_comm_power(0, 1);
 	clk_disable_unprepare(tv_enc_clk);
 	return 0;
@@ -899,7 +904,7 @@
 		return -ENODEV;
 	}
 	switch_dev_unregister(&external_common_state->sdev);
-	wake_lock_destroy(&wlock);
+	pm_qos_remove_request(&pm_qos_req);
 	kfree(dd);
 	dd = NULL;
 	return 0;
@@ -1006,7 +1011,8 @@
 		*hdtv_mux = 0x8000;
 		iounmap(hdtv_mux);
 	}
-	wake_lock_init(&wlock, WAKE_LOCK_IDLE, "hdmi_active");
+	pm_qos_add_request(&pm_qos_req, PM_QOS_CPU_DMA_LATENCY,
+				PM_QOS_DEFAULT_VALUE);
 
 	return 0;
 
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: cmc624.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: cmc624_sysfs.c
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/external_common.c msm/external_common.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/external_common.c	2012-08-08 09:32:42.781525952 -0700
+++ msm/external_common.c	2012-08-14 12:32:39.475339485 -0700
@@ -18,6 +18,9 @@
 /* #define DEBUG */
 #define DEV_DBG_PREFIX "EXT_COMMON: "
 
+/* The start of the data block collection within the CEA Extension Version 3 */
+#define DBC_START_OFFSET 4
+
 #include "msm_fb.h"
 #include "hdmi_msm.h"
 #include "external_common.h"
@@ -76,7 +79,6 @@
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDF};
 #endif /* DEBUG_EDID */
 
-#ifdef CONFIG_FB_MSM_HDMI_MHL
 #define DMA_E_BASE 0xB0000
 void mdp_vid_quant_set(void)
 {
@@ -93,15 +95,6 @@
 		MDP_OUTP(MDP_BASE + DMA_E_BASE + 0x78, 0x00FF0000);
 	}
 }
-#else
-void mdp_vid_quant_set(void)
-{
-	/*
-	 * Support for quantization to be added
-	 * only when MHL support is included.
-	 */
-}
-#endif
 
 const char *video_format_2string(uint32 format)
 {
@@ -346,6 +339,143 @@
 	return ret;
 }
 
+static ssize_t hdmi_common_rda_edid_physical_address(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = snprintf(buf, PAGE_SIZE, "%d\n",
+		external_common_state->physical_address);
+
+	DEV_DBG("%s: '%d'\n", __func__,
+			external_common_state->physical_address);
+	return ret;
+}
+
+
+static ssize_t hdmi_common_rda_edid_scan_info(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = snprintf(buf, PAGE_SIZE, "%d, %d, %d\n",
+		external_common_state->pt_scan_info,
+		external_common_state->it_scan_info,
+		external_common_state->ce_scan_info);
+	DEV_DBG("%s: '%s'\n", __func__, buf);
+	return ret;
+}
+
+static ssize_t hdmi_common_wta_vendor_name(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint8 *s = (uint8 *) buf;
+	uint8 *d = external_common_state->spd_vendor_name;
+	ssize_t ret = strnlen(buf, PAGE_SIZE);
+	ret = (ret > 8) ? 8 : ret;
+
+	memset(external_common_state->spd_vendor_name, 0, 8);
+	while (*s) {
+		if (*s & 0x60 && *s ^ 0x7f) {
+			*d = *s;
+		} else {
+			/* stop copying if control character found */
+			break;
+		}
+
+		if (++s > (uint8 *) (buf + ret))
+			break;
+
+		d++;
+	}
+
+	DEV_DBG("%s: '%s'\n", __func__,
+			external_common_state->spd_vendor_name);
+
+	return ret;
+}
+
+static ssize_t hdmi_common_rda_vendor_name(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = snprintf(buf, PAGE_SIZE, "%s\n",
+		external_common_state->spd_vendor_name);
+	DEV_DBG("%s: '%s'\n", __func__,
+			external_common_state->spd_vendor_name);
+
+	return ret;
+}
+
+static ssize_t hdmi_common_wta_product_description(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint8 *s = (uint8 *) buf;
+	uint8 *d = external_common_state->spd_product_description;
+	ssize_t ret = strnlen(buf, PAGE_SIZE);
+	ret = (ret > 16) ? 16 : ret;
+
+	memset(external_common_state->spd_product_description, 0, 16);
+	while (*s) {
+		if (*s & 0x60 && *s ^ 0x7f) {
+			*d = *s;
+		} else {
+			/* stop copying if control character found */
+			break;
+		}
+
+		if (++s > (uint8 *) (buf + ret))
+			break;
+
+		d++;
+	}
+
+	DEV_DBG("%s: '%s'\n", __func__,
+			external_common_state->spd_product_description);
+
+	return ret;
+}
+
+static ssize_t hdmi_common_rda_product_description(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = snprintf(buf, PAGE_SIZE, "%s\n",
+		external_common_state->spd_product_description);
+	DEV_DBG("%s: '%s'\n", __func__,
+			external_common_state->spd_product_description);
+
+	return ret;
+}
+
+static ssize_t hdmi_common_rda_edid_3d_modes(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	int i;
+	char buff_3d[128];
+
+	buf[0] = 0;
+	if (external_common_state->disp_mode_list.num_of_elements) {
+		uint32 *video_mode = external_common_state->disp_mode_list
+			.disp_mode_list;
+		uint32 *video_3d_mode = external_common_state->disp_mode_list
+			.disp_3d_mode_list;
+		for (i = 0; i < external_common_state->disp_mode_list
+			.num_of_elements; ++i) {
+			video_3d_format_2string(*video_3d_mode++, buff_3d);
+			if (ret > 0)
+				ret += snprintf(buf+ret, PAGE_SIZE-ret,
+					",%d=%s",
+					*video_mode++ + 1, buff_3d);
+			else
+				ret += snprintf(buf+ret, PAGE_SIZE-ret,
+					"%d=%s",
+					*video_mode++ + 1, buff_3d);
+		}
+	} else
+		ret += snprintf(buf+ret, PAGE_SIZE-ret, "%d",
+			external_common_state->video_resolution+1);
+
+	DEV_DBG("%s: '%s'\n", __func__, buf);
+	ret += snprintf(buf+ret, PAGE_SIZE-ret, "\n");
+	return ret;
+}
+
 static ssize_t hdmi_common_rda_hdcp(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
@@ -429,6 +559,14 @@
 		mutex_lock(&hdmi_msm_state_mutex);
 		hdmi_msm_state->cec_enabled = true;
 		hdmi_msm_state->cec_logical_addr = 4;
+
+		/* flush CEC queue */
+		hdmi_msm_state->cec_queue_wr = hdmi_msm_state->cec_queue_start;
+		hdmi_msm_state->cec_queue_rd = hdmi_msm_state->cec_queue_start;
+		hdmi_msm_state->cec_queue_full = false;
+		memset(hdmi_msm_state->cec_queue_rd, 0,
+			sizeof(struct hdmi_msm_cec_msg)*CEC_QUEUE_SIZE);
+
 		mutex_unlock(&hdmi_msm_state_mutex);
 		hdmi_msm_cec_init();
 		hdmi_msm_cec_write_logical_addr(
@@ -521,7 +659,7 @@
 			if (hdmi_msm_state->fsm_reset_done)
 				retry++;
 			mutex_unlock(&hdmi_msm_state_mutex);
-			msleep(360);
+			msleep(20);
 		} else
 			break;
 	}
@@ -702,6 +840,17 @@
 static DEVICE_ATTR(hpd, S_IRUGO | S_IWUGO, hdmi_common_rda_hpd,
 	hdmi_common_wta_hpd);
 static DEVICE_ATTR(hdcp, S_IRUGO, hdmi_common_rda_hdcp, NULL);
+static DEVICE_ATTR(pa, S_IRUGO,
+	hdmi_common_rda_edid_physical_address, NULL);
+static DEVICE_ATTR(scan_info, S_IRUGO,
+	hdmi_common_rda_edid_scan_info, NULL);
+static DEVICE_ATTR(vendor_name, S_IRUGO | S_IWUSR, hdmi_common_rda_vendor_name,
+	hdmi_common_wta_vendor_name);
+static DEVICE_ATTR(product_description, S_IRUGO | S_IWUSR,
+	hdmi_common_rda_product_description,
+	hdmi_common_wta_product_description);
+static DEVICE_ATTR(edid_3d_modes, S_IRUGO,
+	hdmi_common_rda_edid_3d_modes, NULL);
 static DEVICE_ATTR(3d_present, S_IRUGO, hdmi_common_rda_3d_present, NULL);
 static DEVICE_ATTR(hdcp_present, S_IRUGO, hdmi_common_rda_hdcp_present, NULL);
 #endif
@@ -720,6 +869,11 @@
 	&dev_attr_edid_modes.attr,
 	&dev_attr_hdcp.attr,
 	&dev_attr_hpd.attr,
+	&dev_attr_pa.attr,
+	&dev_attr_scan_info.attr,
+	&dev_attr_vendor_name.attr,
+	&dev_attr_product_description.attr,
+	&dev_attr_edid_3d_modes.attr,
 	&dev_attr_3d_present.attr,
 	&dev_attr_hdcp_present.attr,
 #endif
@@ -947,28 +1101,24 @@
 	 31500, 60000, 108108, 60000, TRUE},
 };
 
-static const uint8 *hdmi_edid_find_block(const uint8 *in_buf, uint8 type,
-	uint8 *len)
+static const uint8 *hdmi_edid_find_block(const uint8 *in_buf,
+		uint32 start_offset, uint8 type, uint8 *len)
 {
 	/* the start of data block collection, start of Video Data Block */
-	uint32 offset = 4;
-	uint16 start_DTD = 0;
+	uint32 offset = start_offset;
+	uint32 end_dbc_offset = in_buf[2];
+
 	*len = 0;
 
 	/*edid buffer 1, byte 2 being 4 means no non-DTD/Data block collection
 	  present.
 	  edid buffer 1, byte 2 being 0 menas no non-DTD/DATA block collection
 	  present and no DTD data present.*/
-	if ((in_buf[2] == 0) || (in_buf[2] == 4)) {
+	if ((end_dbc_offset == 0) || (end_dbc_offset == 4)) {
 		DEV_WARN("EDID: no DTD or non-DTD data present\n");
 		return NULL;
 	}
-	start_DTD = in_buf[2];
-	while (offset < 0x80) {
-		/* some block_data is optional in CEA EDID*/
-		if (start_DTD <= offset)
-			break;
-
+	while (offset < end_dbc_offset) {
 		uint8 block_len = in_buf[offset] & 0x1F;
 		if ((in_buf[offset] >> 5) == type) {
 			*len = block_len;
@@ -996,20 +1146,27 @@
 static uint32 hdmi_edid_extract_ieee_reg_id(const uint8 *in_buf)
 {
 	uint8 len;
-	const uint8 *vsd = hdmi_edid_find_block(in_buf, 3, &len);
+	const uint8 *vsd = hdmi_edid_find_block(in_buf, DBC_START_OFFSET, 3,
+			&len);
 
 	if (vsd == NULL)
 		return 0;
 
 	DEV_DBG("EDID: VSD PhyAddr=%04x, MaxTMDS=%dMHz\n",
-		((uint32)vsd[6] << 8) + (uint32)vsd[5], (uint32)vsd[7] * 5);
+		((uint32)vsd[4] << 8) + (uint32)vsd[5], (uint32)vsd[7] * 5);
+	external_common_state->physical_address =
+		((uint16)vsd[4] << 8) + (uint16)vsd[5];
 	return ((uint32)vsd[3] << 16) + ((uint32)vsd[2] << 8) + (uint32)vsd[1];
 }
 
+#define HDMI_VSDB_3D_DATA_OFFSET(vsd) \
+	(!((vsd)[8] & BIT(7)) ? 9 : (!((vsd)[8] & BIT(6)) ? 11 : 13))
+
 static void hdmi_edid_extract_3d_present(const uint8 *in_buf)
 {
 	uint8 len, offset;
-	const uint8 *vsd = hdmi_edid_find_block(in_buf, 3, &len);
+	const uint8 *vsd = hdmi_edid_find_block(in_buf, DBC_START_OFFSET, 3,
+			&len);
 
 	external_common_state->present_3d = 0;
 	if (vsd == NULL || len < 9) {
@@ -1017,7 +1174,7 @@
 		return;
 	}
 
-	offset = !(vsd[8] & BIT(7)) ? 9 : 13;
+	offset = HDMI_VSDB_3D_DATA_OFFSET(vsd);
 	DEV_DBG("EDID: 3D present @ %d = %02x\n", offset, vsd[offset]);
 	if (vsd[offset] >> 7) { /* 3D format indication present */
 		DEV_INFO("EDID: 3D present, 3D-len=%d\n", vsd[offset+1] & 0x1F);
@@ -1029,7 +1186,8 @@
 static void hdmi_edid_extract_latency_fields(const uint8 *in_buf)
 {
 	uint8 len;
-	const uint8 *vsd = hdmi_edid_find_block(in_buf, 3, &len);
+	const uint8 *vsd = hdmi_edid_find_block(in_buf, DBC_START_OFFSET, 3,
+			&len);
 
 	if (vsd == NULL || len < 12 || !(vsd[8] & BIT(7))) {
 		external_common_state->video_latency = (uint16)-1;
@@ -1047,14 +1205,13 @@
 static void hdmi_edid_extract_speaker_allocation_data(const uint8 *in_buf)
 {
 	uint8 len;
-	uint16 speaker_allocation = 0;
-	const uint8 *sad = hdmi_edid_find_block(in_buf, 4, &len);
+	const uint8 *sad = hdmi_edid_find_block(in_buf, DBC_START_OFFSET, 4,
+			&len);
 
 	if (sad == NULL)
 		return;
 
 	external_common_state->speaker_allocation_block = sad[1];
-	speaker_allocation |= (sad[1] & 0x7F);
 	DEV_DBG("EDID: speaker allocation data SP byte = %08x %s%s%s%s%s%s%s\n",
 		sad[1],
 		(sad[1] & BIT(0)) ? "FL/FR," : "",
@@ -1064,15 +1221,13 @@
 		(sad[1] & BIT(4)) ? "RC," : "",
 		(sad[1] & BIT(5)) ? "FLC/FRC," : "",
 		(sad[1] & BIT(6)) ? "RLC/RRC," : "");
-
-	external_common_state->audio_speaker_data |= (speaker_allocation << 8);
 }
 
 static void hdmi_edid_extract_audio_data_blocks(const uint8 *in_buf)
 {
 	uint8 len;
-	uint16 audio_ch = 0;
-	const uint8 *sad = hdmi_edid_find_block(in_buf, 1, &len);
+	const uint8 *sad = hdmi_edid_find_block(in_buf, DBC_START_OFFSET, 1,
+			&len);
 	uint32 *adb = external_common_state->audio_data_blocks;
 
 	if (sad == NULL)
@@ -1083,16 +1238,69 @@
 		DEV_DBG("EDID: Audio Data Block=<ch=%d, format=%d "
 			"sampling=0x%02x bit-depth=0x%02x>\n",
 			(sad[1] & 0x7)+1, sad[1] >> 3, sad[2], sad[3]);
-		audio_ch |= (1 << (sad[1] & 0x7));
 		*adb++ = (uint32)sad[1] + ((uint32)sad[2] << 8)
 			+ ((uint32)sad[2] << 16);
 		++external_common_state->audio_data_block_cnt;
 		len -= 3;
 		sad += 3;
 	}
-	external_common_state->audio_speaker_data |= audio_ch;
 }
 
+static void hdmi_edid_extract_extended_data_blocks(const uint8 *in_buf)
+{
+	uint8 len = 0;
+	uint32 start_offset = DBC_START_OFFSET;
+
+	/* A Tage code of 7 identifies extended data blocks */
+	uint8 const *etag = hdmi_edid_find_block(in_buf, start_offset, 7, &len);
+
+	while (etag != NULL) {
+		/* The extended data block should at least be 2 bytes long */
+		if (len < 2) {
+			DEV_DBG("EDID: Found an extended data block of length"
+				"less than 2 bytes. Ignoring ...\n");
+		} else {
+			/*
+			 * The second byte of the extended data block has the
+			 * extended tag code
+			 */
+			switch (etag[1]) {
+			case 0:
+				/* Video Capability Data Block */
+				DEV_DBG("EDID: VCDB=%02X %02X\n", etag[1],
+						etag[2]);
+
+				/*
+				 * Check if the sink specifies underscan
+				 * support for:
+				 * BIT 5: preferred video format
+				 * BIT 3: IT video format
+				 * BIT 1: CE video format
+				 */
+				external_common_state->pt_scan_info = (etag[2] &
+							(BIT(4) | BIT(5))) >> 4;
+				external_common_state->it_scan_info = (etag[2] &
+							(BIT(3) | BIT(2))) >> 2;
+				external_common_state->ce_scan_info = etag[2] &
+							(BIT(1) | BIT(0));
+				DEV_DBG("EDID: Scan Information (pt|it|ce): "
+					"(%d|%d|%d)",
+					external_common_state->pt_scan_info,
+					external_common_state->it_scan_info,
+					external_common_state->ce_scan_info);
+				break;
+			default:
+				DEV_DBG("EDID: Extend Tag Code %d not"
+						"supported\n", etag[1]);
+				break;
+			}
+		}
+
+		/* There could be more that one extended data block */
+		start_offset = etag - in_buf + len + 1;
+		etag = hdmi_edid_find_block(in_buf, start_offset, 7, &len);
+	}
+}
 
 static void hdmi_edid_detail_desc(const uint8 *data_buf, uint32 *disp_mode)
 {
@@ -1226,6 +1434,192 @@
 	}
 }
 
+const char *single_video_3d_format_2string(uint32 format)
+{
+	switch (format) {
+	case TOP_AND_BOTTOM: return "TAB";
+	case FRAME_PACKING: return "FP";
+	case SIDE_BY_SIDE_HALF: return "SSH";
+	}
+	return "";
+}
+
+ssize_t video_3d_format_2string(uint32 format, char *buf)
+{
+	ssize_t ret, len = 0;
+	ret = snprintf(buf, PAGE_SIZE, "%s",
+		single_video_3d_format_2string(format & FRAME_PACKING));
+	len += ret;
+
+	if (len && (format & TOP_AND_BOTTOM))
+		ret = snprintf(buf + len, PAGE_SIZE, ":%s",
+			single_video_3d_format_2string(
+				format & TOP_AND_BOTTOM));
+	else
+		ret = snprintf(buf + len, PAGE_SIZE, "%s",
+			single_video_3d_format_2string(
+				format & TOP_AND_BOTTOM));
+	len += ret;
+
+	if (len && (format & SIDE_BY_SIDE_HALF))
+		ret = snprintf(buf + len, PAGE_SIZE, ":%s",
+			single_video_3d_format_2string(
+				format & SIDE_BY_SIDE_HALF));
+	else
+		ret = snprintf(buf + len, PAGE_SIZE, "%s",
+			single_video_3d_format_2string(
+				format & SIDE_BY_SIDE_HALF));
+	len += ret;
+
+	return len;
+}
+
+static void add_supported_3d_format(
+	struct hdmi_disp_mode_list_type *disp_mode_list,
+	uint32 video_format,
+	uint32 video_3d_format)
+{
+	char string[128];
+	boolean added = FALSE;
+	int i;
+	for (i = 0; i < disp_mode_list->num_of_elements; ++i) {
+		if (disp_mode_list->disp_mode_list[i] == video_format) {
+			disp_mode_list->disp_3d_mode_list[i] |=
+				video_3d_format;
+			added = TRUE;
+			break;
+		}
+	}
+	video_3d_format_2string(video_3d_format, string);
+	DEV_DBG("EDID[3D]: format: %d [%s], %s %s\n",
+		video_format, video_format_2string(video_format),
+		string, added ? "added" : "NOT added");
+}
+
+static void hdmi_edid_get_display_vsd_3d_mode(const uint8 *data_buf,
+	struct hdmi_disp_mode_list_type *disp_mode_list,
+	uint32 num_og_cea_blocks)
+{
+	uint8 len, offset, present_multi_3d, hdmi_vic_len, hdmi_3d_len;
+	uint16 structure_all, structure_mask;
+	const uint8 *vsd = num_og_cea_blocks ?
+		hdmi_edid_find_block(data_buf+0x80, DBC_START_OFFSET,
+				3, &len) : NULL;
+	int i;
+
+	offset = HDMI_VSDB_3D_DATA_OFFSET(vsd);
+	present_multi_3d = (vsd[offset] & 0x60) >> 5;
+
+	offset += 1;
+	hdmi_vic_len = (vsd[offset] >> 5) & 0x7;
+	hdmi_3d_len = vsd[offset] & 0x1F;
+	DEV_DBG("EDID[3D]: HDMI_VIC_LEN = %d, HDMI_3D_LEN = %d\n",
+		hdmi_vic_len, hdmi_3d_len);
+
+	offset += (hdmi_vic_len + 1);
+	if (present_multi_3d == 1 || present_multi_3d == 2) {
+		DEV_DBG("EDID[3D]: multi 3D present (%d)\n", present_multi_3d);
+		/* 3d_structure_all */
+		structure_all = (vsd[offset] << 8) | vsd[offset + 1];
+		offset += 2;
+		hdmi_3d_len -= 2;
+		if (present_multi_3d == 2) {
+			/* 3d_structure_mask */
+			structure_mask = (vsd[offset] << 8) | vsd[offset + 1];
+			offset += 2;
+			hdmi_3d_len -= 2;
+		} else
+			structure_mask = 0xffff;
+
+		i = 0;
+		while (i < 16) {
+			if (i >= disp_mode_list->disp_multi_3d_mode_list_cnt)
+				break;
+
+			if (!(structure_mask & BIT(i))) {
+				++i;
+				continue;
+			}
+
+			/* BIT0: FRAME PACKING */
+			if (structure_all & BIT(0))
+				add_supported_3d_format(disp_mode_list,
+					disp_mode_list->
+						disp_multi_3d_mode_list[i],
+					FRAME_PACKING);
+
+			/* BIT6: TOP AND BOTTOM */
+			if (structure_all & BIT(6))
+				add_supported_3d_format(disp_mode_list,
+					disp_mode_list->
+						disp_multi_3d_mode_list[i],
+					TOP_AND_BOTTOM);
+
+			/* BIT8: SIDE BY SIDE HALF */
+			if (structure_all & BIT(8))
+				add_supported_3d_format(disp_mode_list,
+					disp_mode_list->
+						disp_multi_3d_mode_list[i],
+					SIDE_BY_SIDE_HALF);
+
+			++i;
+		}
+	}
+
+	i = 0;
+	while (hdmi_3d_len > 0) {
+		DEV_DBG("EDID[3D]: 3D_Structure_%d @ %d: %02x\n",
+			i + 1, offset, vsd[offset]);
+
+		if ((vsd[offset] >> 4) >=
+			disp_mode_list->disp_multi_3d_mode_list_cnt) {
+			if ((vsd[offset] & 0x0F) >= 8) {
+				offset += 1;
+				hdmi_3d_len -= 1;
+				DEV_DBG("EDID[3D]: 3D_Detail_%d @ %d: %02x\n",
+					i + 1, offset, vsd[offset]);
+			}
+			i += 1;
+			offset += 1;
+			hdmi_3d_len -= 1;
+			continue;
+		}
+
+		switch (vsd[offset] & 0x0F) {
+		case 0:
+			/* 0000b: FRAME PACKING */
+			add_supported_3d_format(disp_mode_list,
+				disp_mode_list->disp_multi_3d_mode_list
+					[vsd[offset] >> 4],
+				FRAME_PACKING);
+			break;
+		case 6:
+			/* 0110b: TOP AND BOTTOM */
+			add_supported_3d_format(disp_mode_list,
+				disp_mode_list->disp_multi_3d_mode_list
+					[vsd[offset] >> 4],
+				TOP_AND_BOTTOM);
+			break;
+		case 8:
+			/* 1000b: SIDE BY SIDE HALF */
+			add_supported_3d_format(disp_mode_list,
+				disp_mode_list->disp_multi_3d_mode_list
+					[vsd[offset] >> 4],
+				SIDE_BY_SIDE_HALF);
+			break;
+		}
+		if ((vsd[offset] & 0x0F) >= 8) {
+			offset += 1;
+			hdmi_3d_len -= 1;
+			DEV_DBG("EDID[3D]: 3D_Detail_%d @ %d: %02x\n",
+				i + 1, offset, vsd[offset]);
+		}
+		i += 1;
+		offset += 1;
+		hdmi_3d_len -= 1;
+	}
+}
+
 static void hdmi_edid_get_display_mode(const uint8 *data_buf,
 	struct hdmi_disp_mode_list_type *disp_mode_list,
 	uint32 num_og_cea_blocks)
@@ -1237,9 +1631,14 @@
 	const uint8 *edid_blk0 = &data_buf[0x0];
 	const uint8 *edid_blk1 = &data_buf[0x80];
 	const uint8 *svd = num_og_cea_blocks ?
-		hdmi_edid_find_block(data_buf+0x80, 2, &len) : NULL;
+		hdmi_edid_find_block(data_buf+0x80, DBC_START_OFFSET,
+				2, &len) : NULL;
+	boolean has60hz_mode	= FALSE;
+	boolean has50hz_mode	= FALSE;
+
 
 	disp_mode_list->num_of_elements = 0;
+	disp_mode_list->disp_multi_3d_mode_list_cnt = 0;
 	if (svd != NULL) {
 		++svd;
 		for (i = 0; i < len; ++i, ++svd) {
@@ -1249,6 +1648,28 @@
 			video_format = (*svd & 0x7F) - 1;
 			add_supported_video_format(disp_mode_list,
 				video_format);
+			/* Make a note of the preferred video format */
+			if (i == 0) {
+				external_common_state->preferred_video_format =
+					video_format;
+			}
+			if (i < 16) {
+				disp_mode_list->disp_multi_3d_mode_list[i]
+					= video_format;
+				disp_mode_list->disp_multi_3d_mode_list_cnt++;
+			}
+
+			if (video_format <= HDMI_VFRMT_1920x1080p60_16_9 ||
+				video_format == HDMI_VFRMT_2880x480p60_4_3 ||
+				video_format == HDMI_VFRMT_2880x480p60_16_9)
+				has60hz_mode = TRUE;
+
+			if ((video_format >= HDMI_VFRMT_720x576p50_4_3 &&
+				video_format <= HDMI_VFRMT_1920x1080p50_16_9) ||
+				video_format == HDMI_VFRMT_2880x576p50_4_3 ||
+				video_format == HDMI_VFRMT_2880x576p50_16_9 ||
+				video_format == HDMI_VFRMT_1920x1250i50_16_9)
+				has50hz_mode = TRUE;
 			if (video_format == HDMI_VFRMT_640x480p60_4_3)
 				has480p = TRUE;
 		}
@@ -1271,6 +1692,11 @@
 				video_format);
 			if (video_format == HDMI_VFRMT_640x480p60_4_3)
 				has480p = TRUE;
+			/* Make a note of the preferred video format */
+			if (i == 0) {
+				external_common_state->preferred_video_format =
+					video_format;
+			}
 			desc_offset += 0x12;
 			++i;
 		}
@@ -1291,6 +1717,11 @@
 				video_format);
 			if (video_format == HDMI_VFRMT_640x480p60_4_3)
 				has480p = TRUE;
+			/* Make a note of the preferred video format */
+			if (i == 0) {
+				external_common_state->preferred_video_format =
+					video_format;
+			}
 			desc_offset += 0x12;
 			++i;
 		}
@@ -1314,11 +1745,46 @@
 				video_format);
 			if (video_format == HDMI_VFRMT_640x480p60_4_3)
 				has480p = TRUE;
+			/* Make a note of the preferred video format */
+			if (i == 0) {
+				external_common_state->preferred_video_format =
+					video_format;
+			}
 			desc_offset += 0x12;
 			++i;
 		}
 	}
 
+	/* mandaroty 3d format */
+	if (external_common_state->present_3d) {
+		if (has60hz_mode) {
+			add_supported_3d_format(disp_mode_list,
+				HDMI_VFRMT_1920x1080p24_16_9,
+				FRAME_PACKING | TOP_AND_BOTTOM);
+			add_supported_3d_format(disp_mode_list,
+				HDMI_VFRMT_1280x720p60_16_9,
+				FRAME_PACKING | TOP_AND_BOTTOM);
+			add_supported_3d_format(disp_mode_list,
+				HDMI_VFRMT_1920x1080i60_16_9,
+				SIDE_BY_SIDE_HALF);
+		}
+		if (has50hz_mode) {
+			add_supported_3d_format(disp_mode_list,
+				HDMI_VFRMT_1920x1080p24_16_9,
+				FRAME_PACKING | TOP_AND_BOTTOM);
+			add_supported_3d_format(disp_mode_list,
+				HDMI_VFRMT_1280x720p50_16_9,
+				FRAME_PACKING | TOP_AND_BOTTOM);
+			add_supported_3d_format(disp_mode_list,
+				HDMI_VFRMT_1920x1080i50_16_9,
+				SIDE_BY_SIDE_HALF);
+		}
+
+		/* 3d format described in Vendor Specific Data */
+		hdmi_edid_get_display_vsd_3d_mode(data_buf, disp_mode_list,
+			num_og_cea_blocks);
+	}
+
 	if (!has480p)
 		/* Need to add default 640 by 480 timings, in case not described
 		 * in the EDID structure.
@@ -1347,7 +1813,7 @@
 			__func__, (uint8)edid_buf[0x7F], (uint8)check_sum);
 #ifdef DEBUG
 		for (ndx = 0; ndx < 0x100; ndx += 16)
-			DEV_INFO("EDID[%02x-%02x] %02x %02x %02x %02x  "
+			DEV_DBG("EDID[%02x-%02x] %02x %02x %02x %02x  "
 				"%02x %02x %02x %02x    %02x %02x %02x %02x  "
 				"%02x %02x %02x %02x\n", ndx, ndx+15,
 				b[ndx+0], b[ndx+1], b[ndx+2], b[ndx+3],
@@ -1392,8 +1858,7 @@
 	/* EDID_BLOCK_SIZE[0x80] Each page size in the EDID ROM */
 	uint8 edid_buf[0x80 * 4];
 
-	/* Default 2ch-audio */
-	external_common_state->audio_speaker_data = 2;
+	external_common_state->preferred_video_format = 0;
 	external_common_state->present_3d = 0;
 	memset(&external_common_state->disp_mode_list, 0,
 		sizeof(external_common_state->disp_mode_list));
@@ -1445,6 +1910,7 @@
 				edid_buf+0x80);
 			hdmi_edid_extract_audio_data_blocks(edid_buf+0x80);
 			hdmi_edid_extract_3d_present(edid_buf+0x80);
+			hdmi_edid_extract_extended_data_blocks(edid_buf+0x80);
 		}
 		break;
 	case 2:
@@ -1537,13 +2003,7 @@
 				: HDMI_VFRMT_1440x576i50_16_9;
 			break;
 		case 1920:
-#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
-			format = (mfd->var_yres == 540)
-				? HDMI_VFRMT_1920x1080i60_16_9
-				: HDMI_VFRMT_1920x1080p30_16_9;
-#else
 			format = HDMI_VFRMT_1920x1080p60_16_9;
-#endif
 			break;
 		}
 	}
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/external_common.h msm/external_common.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/external_common.h	2012-07-16 10:04:32.200489771 -0700
+++ msm/external_common.h	2012-08-14 12:32:39.475339485 -0700
@@ -146,16 +146,16 @@
 	 720, 5, 5, 20, FALSE, 74250, 60000, FALSE, TRUE}
 #define HDMI_SETTINGS_1920x1080i60_16_9					\
 	{HDMI_VFRMT_1920x1080i60_16_9,   1920, 88,  44,  148, FALSE,	\
-	 540, 2, 5, 5, FALSE, 74250, 60000, TRUE, FALSE}
+	 540, 2, 5, 5, FALSE, 74250, 60000, FALSE, TRUE}
 #define HDMI_SETTINGS_1440x480i60_4_3					\
 	{HDMI_VFRMT_1440x480i60_4_3,     1440, 38,  124, 114, TRUE,	\
-	 240, 4, 3, 15, TRUE, 27000, 60000, TRUE, FALSE}
+	 240, 4, 3, 15, TRUE, 27000, 60000, TRUE, TRUE}
 #define HDMI_SETTINGS_1440x480i60_16_9					\
 	{HDMI_VFRMT_1440x480i60_16_9,    1440, 38,  124, 114, TRUE,	\
-	 240, 4, 3, 15, TRUE, 27000, 60000, TRUE, FALSE}
+	 240, 4, 3, 15, TRUE, 27000, 60000, TRUE, TRUE}
 #define HDMI_SETTINGS_1920x1080p60_16_9					\
 	{HDMI_VFRMT_1920x1080p60_16_9,   1920, 88,  44,  148,  FALSE,	\
-	 1080, 4, 5, 36, FALSE, 148500, 60000, FALSE, FALSE}
+	 1080, 4, 5, 36, FALSE, 148500, 60000, FALSE, TRUE}
 #define HDMI_SETTINGS_720x576p50_4_3					\
 	{HDMI_VFRMT_720x576p50_4_3,      720,  12,  64,  68,   TRUE,	\
 	 576,  5, 5, 39, TRUE, 27000, 50000, FALSE, TRUE}
@@ -167,13 +167,13 @@
 	 720,  5, 5, 20, FALSE, 74250, 50000, FALSE, TRUE}
 #define HDMI_SETTINGS_1440x576i50_4_3					\
 	{HDMI_VFRMT_1440x576i50_4_3,     1440, 24,  126, 138,  TRUE,	\
-	 288,  2, 3, 19, TRUE, 27000, 50000, TRUE, FALSE}
+	 288,  2, 3, 19, TRUE, 27000, 50000, TRUE, TRUE}
 #define HDMI_SETTINGS_1440x576i50_16_9					\
 	{HDMI_VFRMT_1440x576i50_16_9,    1440, 24,  126, 138,  TRUE,	\
-	 288,  2, 3, 19, TRUE, 27000, 50000, TRUE, FALSE}
+	 288,  2, 3, 19, TRUE, 27000, 50000, TRUE, TRUE}
 #define HDMI_SETTINGS_1920x1080p50_16_9					\
 	{HDMI_VFRMT_1920x1080p50_16_9,   1920,  528,  44,  148,  FALSE,	\
-	 1080, 4, 5, 36, FALSE, 148500, 50000, FALSE, FALSE}
+	 1080, 4, 5, 36, FALSE, 148500, 50000, FALSE, TRUE}
 #define HDMI_SETTINGS_1920x1080p24_16_9					\
 	{HDMI_VFRMT_1920x1080p24_16_9,   1920,  638,  44,  148,  FALSE,	\
 	 1080, 4, 5, 36, FALSE, 74250, 24000, FALSE, TRUE}
@@ -194,6 +194,12 @@
  * device */
 struct hdmi_disp_mode_list_type {
 	uint32	disp_mode_list[HDMI_VFRMT_MAX];
+#define TOP_AND_BOTTOM		0x10
+#define FRAME_PACKING		0x20
+#define SIDE_BY_SIDE_HALF	0x40
+	uint32	disp_3d_mode_list[HDMI_VFRMT_MAX];
+	uint32	disp_multi_3d_mode_list[16];
+	uint32	disp_multi_3d_mode_list_cnt;
 	uint32	num_of_elements;
 };
 #endif
@@ -216,13 +222,19 @@
 	uint8 speaker_allocation_block;
 	uint16 video_latency, audio_latency;
 	uint8 audio_data_block_cnt;
+	uint16 physical_address;
+	uint32 preferred_video_format;
+	uint8 pt_scan_info;
+	uint8 it_scan_info;
+	uint8 ce_scan_info;
+	uint8 spd_vendor_name[8];
+	uint8 spd_product_description[16];
 	boolean present_3d;
 	boolean present_hdcp;
 	uint32 audio_data_blocks[16];
 	int (*read_edid_block)(int block, uint8 *edid_buf);
 	int (*hpd_feature)(int on);
 #endif
-	uint16 audio_speaker_data;
 };
 
 /* The external interface driver needs to initialize the common state. */
@@ -250,6 +262,8 @@
 const struct hdmi_disp_mode_timing_type *hdmi_mhl_get_supported_mode(
 	uint32 mode);
 void hdmi_common_init_panel_info(struct msm_panel_info *pinfo);
+
+ssize_t video_3d_format_2string(uint32 format, char *buf);
 #endif
 
 int external_common_state_create(struct platform_device *pdev);
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/hdmi_msm.c msm/hdmi_msm.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/hdmi_msm.c	2012-08-08 09:32:42.782525955 -0700
+++ msm/hdmi_msm.c	2012-08-14 12:32:39.476339485 -0700
@@ -15,6 +15,9 @@
 #define DEV_DBG_PREFIX "HDMI: "
 /* #define REG_DUMP */
 
+#define CEC_MSG_PRINT
+#define TOGGLE_CEC_HARDWARE_FSM
+
 #include <linux/types.h>
 #include <linux/bitops.h>
 #include <linux/clk.h>
@@ -22,7 +25,6 @@
 #include <mach/msm_hdmi_audio.h>
 #include <mach/clk.h>
 #include <mach/msm_iomap.h>
-#include <linux/gpio.h>
 #include <mach/socinfo.h>
 
 #include "msm_fb.h"
@@ -61,7 +63,6 @@
 DEFINE_MUTEX(hdmi_msm_state_mutex);
 EXPORT_SYMBOL(hdmi_msm_state_mutex);
 static DEFINE_MUTEX(hdcp_auth_state_mutex);
-/*#define MHL_HPD_SOLUTION*/
 
 static void hdmi_msm_dump_regs(const char *prefix);
 
@@ -71,7 +72,6 @@
 static inline void hdmi_msm_hdcp_enable(void) {}
 #endif
 
-static boolean hdmi_msm_is_dvi_mode(void);
 static void hdmi_msm_turn_on(void);
 static int hdmi_msm_audio_off(void);
 static int hdmi_msm_read_edid(void);
@@ -132,12 +132,6 @@
 		| HDMI_MSM_CEC_REFTIMER_REFTIMER(27 * 50)
 		);
 
-	/* 0x02A4 CEC_TIME */
-	HDMI_OUTP(0x02A4,
-		HDMI_MSM_CEC_TIME_SIGNAL_FREE_TIME(350)
-		| HDMI_MSM_CEC_TIME_ENABLE
-		);
-
 	/*
 	 * 0x02A0 CEC_ADDR
 	 * Starting with a default address of 4
@@ -227,8 +221,13 @@
 
 	/* 0x0294 HDMI_MSM_CEC_RETRANSMIT */
 	HDMI_OUTP(0x0294,
+#ifdef DRVR_ONLY_CECT_NO_DAEMON
 		HDMI_MSM_CEC_RETRANSMIT_NUM(msg->retransmit)
 		| (msg->retransmit > 0) ? HDMI_MSM_CEC_RETRANSMIT_ENABLE : 0);
+#else
+		HDMI_MSM_CEC_RETRANSMIT_NUM(0) |
+			HDMI_MSM_CEC_RETRANSMIT_ENABLE);
+#endif
 
 	/* 0x028C CEC_CTRL */
 	HDMI_OUTP(0x028C, 0x1 | msg->frame_size << 4);
@@ -738,7 +737,7 @@
 	}
 }
 
-static void hdmi_outp(uint32 offset, uint32 value)
+void hdmi_outp(uint32 offset, uint32 value)
 {
 	uint32 in_val;
 
@@ -748,7 +747,7 @@
 		offset, value, in_val, hdmi_msm_name(offset));
 }
 
-static uint32 hdmi_inp(uint32 offset)
+uint32 hdmi_inp(uint32 offset)
 {
 	uint32 value = inpdw(MSM_HDMI_BASE+offset);
 	DEV_DBG("HDMI[%04x] <= %08x %s\n",
@@ -757,51 +756,31 @@
 }
 #endif /* DEBUG */
 
-void hdmi_hdcp_reg_dump(void)
-{
-	int i = 0;
-	while (i < 0x339) {
-		printk("HDMI_REG[0x%04x]:[0x%08x],[0x%08x],[0x%08x],[0x%08x]\n",
-				i,HDMI_INP(i+0x0),HDMI_INP(i+0x4),
-					HDMI_INP(i+0x8), HDMI_INP(i+0xC));
-		i +=0xF;
-	}
-}
-
 static void hdmi_msm_turn_on(void);
 static int hdmi_msm_audio_off(void);
 static int hdmi_msm_read_edid(void);
 static void hdmi_msm_hpd_off(void);
-static int hdmi_msm_hpd_on(bool trigger_handler);
-#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
-void mhl_hpd_handler(bool state)
-{
-
-	DEV_INFO("mhl_hpd_handler with state as %d\n", state);
-	hdmi_msm_state->mhl_hpd_state = state;
-	hdmi_msm_state->hpd_cable_chg_detected = TRUE;
-
-	if (state && hdmi_msm_state->boot_completion) {
-		/*To make sure that the previous
-		 disconnect event handling  is completed.*/
-		msleep(20);
-		hdmi_msm_hpd_on(true);
-	}
-}
-#endif
 
 static void hdmi_msm_hpd_state_work(struct work_struct *work)
 {
 	boolean hpd_state = false;
 	char *envp[2];
 
+	if (hdmi_msm_state->is_mhl_enabled) {
+		/*
+		 * HPD will be controlled from MHL
+		 */
+		envp[0] = "";
+		DEV_DBG("%s %u\n", envp[0], hpd_state);
+		return;
+	}
+
 	if (!hdmi_msm_state || !hdmi_msm_state->hpd_initialized ||
 		!MSM_HDMI_BASE) {
 		DEV_DBG("%s: ignored, probe failed\n", __func__);
 		return;
 	}
 
-#ifndef MHL_HPD_SOLUTION
 	DEV_DBG("%s:Got interrupt\n", __func__);
 	/* HPD_INT_STATUS[0x0250] */
 	hpd_state = (HDMI_INP(0x0250) & 0x2) >> 1;
@@ -829,14 +808,9 @@
 			__func__);
 		return;
 	}
-#endif/*MHL_HPD_SOLUTION*/
+
 	hdmi_msm_state->hpd_stable = 1;
 	DEV_INFO("HDMI HPD: event detected\n");
-#ifdef MHL_HPD_SOLUTION
-	mutex_lock(&hdmi_msm_state_mutex);
-	hpd_state = hdmi_msm_state->mhl_hpd_state;
-	external_common_state->hpd_state = hdmi_msm_state->mhl_hpd_state;
-#endif/*MHL_HPD_SOLUTION*/
 
 	if (!hdmi_msm_state->hpd_cable_chg_detected) {
 		mutex_unlock(&hdmi_msm_state_mutex);
@@ -844,7 +818,6 @@
 			if (!external_common_state->
 					disp_mode_list.num_of_elements)
 				hdmi_msm_read_edid();
-			hdmi_msm_turn_on();
 		}
 	} else {
 		hdmi_msm_state->hpd_cable_chg_detected = FALSE;
@@ -855,23 +828,21 @@
 		DEV_INFO("HDMI HPD: QDSP OFF\n");
 		kobject_uevent_env(external_common_state->uevent_kobj,
 				   KOBJ_CHANGE, envp);
-#ifdef QCT_SWITCH_STATE_CMD
 		switch_set_state(&external_common_state->sdev, 0);
 		DEV_INFO("Hdmi state switch to %d: %s\n",
 			external_common_state->sdev.state,  __func__);
-#endif
 		if (hpd_state) {
+			/* Build EDID table */
 			hdmi_msm_read_edid();
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 			hdmi_msm_state->reauth = FALSE ;
 #endif
-			/* Build EDID table */
-			hdmi_msm_turn_on();
 			DEV_INFO("HDMI HPD: sense CONNECTED: send ONLINE\n");
-			hdmi_msm_state->hpd_on_offline = TRUE;
 			kobject_uevent(external_common_state->uevent_kobj,
 				KOBJ_ONLINE);
-			hdmi_msm_hdcp_enable();
+			switch_set_state(&external_common_state->sdev, 1);
+				DEV_INFO("Hdmi state switch to %d: %s\n",
+			external_common_state->sdev.state,  __func__);
 #ifndef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 			/* Send Audio for HDMI Compliance Cases*/
 			envp[0] = "HDCP_STATE=PASS";
@@ -879,32 +850,18 @@
 			DEV_INFO("HDMI HPD: sense : send HDCP_PASS\n");
 			kobject_uevent_env(external_common_state->uevent_kobj,
 				KOBJ_CHANGE, envp);
-#ifdef QCT_SWITCH_STATE_CMD
 			switch_set_state(&external_common_state->sdev, 1);
 			DEV_INFO("Hdmi state switch to %d: %s\n",
 				external_common_state->sdev.state, __func__);
 #endif
-#endif
-			switch_set_state(&hdmi_msm_state->hdmi_audio_switch, 1);
-			/*sending hdmi_audio_ch*/
-			switch_set_state(&hdmi_msm_state->hdmi_audio_ch,
-				hdmi_msm_is_dvi_mode() ?
-				0 : external_common_state->audio_speaker_data);
 		} else {
 			DEV_INFO("HDMI HPD: sense DISCONNECTED: send OFFLINE\n"
 				);
-			hdmi_msm_state->hpd_on_offline = FALSE ;
 			kobject_uevent(external_common_state->uevent_kobj,
 				KOBJ_OFFLINE);
-			/*sending hdmi_audio_ch*/
-			switch_set_state(&hdmi_msm_state->hdmi_audio_ch, -1);
-
-			switch_set_state(&hdmi_msm_state->hdmi_audio_switch, 0);
-#ifdef QCT_SWITCH_STATE_CMD
 			switch_set_state(&external_common_state->sdev, 0);
 			DEV_INFO("Hdmi state switch to %d: %s\n",
 				external_common_state->sdev.state,  __func__);
-#endif
 		}
 	}
 
@@ -985,6 +942,9 @@
 {
 	uint32 hpd_int_status;
 	uint32 hpd_int_ctrl;
+#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT
+	uint32 cec_intr_status;
+#endif
 	uint32 ddc_int_ctrl;
 	uint32 audio_int_val;
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
@@ -1018,7 +978,6 @@
 
 		DEV_DBG("%s: HPD IRQ, Ctrl=%04x, State=%04x\n", __func__,
 			hpd_int_ctrl, hpd_int_status);
-#ifndef MHL_HPD_SOLUTION
 		mutex_lock(&hdmi_msm_state_mutex);
 		hdmi_msm_state->hpd_cable_chg_detected = TRUE;
 
@@ -1026,7 +985,7 @@
 		hdmi_msm_state->hpd_prev_state = cable_detected ? 0 : 1;
 		external_common_state->hpd_state = cable_detected ? 1 : 0;
 		hdmi_msm_state->hpd_stable = 0;
-		mod_timer(&hdmi_msm_state->hpd_state_timer, jiffies + HZ/6);
+		mod_timer(&hdmi_msm_state->hpd_state_timer, jiffies + HZ/2);
 		mutex_unlock(&hdmi_msm_state_mutex);
 		/*
 		 * HDCP Compliance 1A-01:
@@ -1044,7 +1003,6 @@
 			hdmi_msm_state->hpd_during_auth = TRUE;
 			mutex_unlock(&hdcp_auth_state_mutex);
 		}
-#endif /*MHL_HPD_SOLUTION*/
 		return IRQ_HANDLED;
 	}
 
@@ -1134,18 +1092,12 @@
 			DEV_INFO("HDMI HPD:QDSP OFF\n");
 			kobject_uevent_env(external_common_state->uevent_kobj,
 			KOBJ_CHANGE, envp);
-#ifdef QCT_SWITCH_STATE_CMD
 			switch_set_state(&external_common_state->sdev, 0);
 			DEV_INFO("Hdmi state switch to %d: %s\n",
 				external_common_state->sdev.state,  __func__);
-#endif
 			mutex_lock(&hdcp_auth_state_mutex);
 			hdmi_msm_state->full_auth_done = FALSE;
 			mutex_unlock(&hdcp_auth_state_mutex);
-			/*When hdcp_auth_fail occur, get hdmi_full_dump*/
-			if(HDMI_INP_ND(0x011C)==0x30000050 ||
-					HDMI_INP_ND(0x011C)==0x30000054)
-				hdmi_hdcp_reg_dump();
 			/* Calling reauth only when authentication
 			 * is sucessful or else we always go into
 			 * the reauth loop
@@ -1287,7 +1239,7 @@
 #endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT */
 
 	DEV_DBG("%s: HPD<Ctrl=%04x, State=%04x>, ddc_int_ctrl=%04x, "
-		"aud_int=%04x, cec_int=%04x\n", __func__, hpd_int_ctrl,
+		"aud_int=%04x, cec_intr_status=%04x\n", __func__, hpd_int_ctrl,
 		hpd_int_status, ddc_int_ctrl, audio_int_val,
 		HDMI_INP_ND(0x029C));
 
@@ -1316,13 +1268,11 @@
 	return 0;
 }
 
-#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 static boolean hdmi_msm_has_hdcp(void)
 {
 	/* RAW_FEAT_CONFIG_ROW0_LSB, HDCP_DISABLE */
 	return (inpdw(QFPROM_BASE + 0x0238) & 0x00400000) ? FALSE : TRUE;
 }
-#endif
 
 static boolean hdmi_msm_is_power_on(void)
 {
@@ -1371,7 +1321,8 @@
 
 	/* HDMI_CTRL */
 	HDMI_OUTP(0x0000, reg_val);
-	DEV_DBG("HDMI Core: %s\n", power_on ? "Enable" : "Disable");
+	DEV_DBG("HDMI Core: %s, HDMI_CTRL=0x%08x\n",
+			power_on ? "Enable" : "Disable", reg_val);
 }
 
 static void msm_hdmi_init_ddc(void)
@@ -1392,9 +1343,11 @@
 	 * Configure the Threshold */
 	HDMI_OUTP_ND(0x0220, (10 << 16) | (2 << 0));
 
-	/* 0x0224 HDMI_DDC_SETUP */
-	/* MHL CTS 6.3.18.2 6.3.18.4 2nd entry */
-	/* Increase waiting time limit 0x00 -> 0xff */
+	/*
+	 * 0x0224 HDMI_DDC_SETUP
+	 * Setting 31:24 bits : Time units to wait before timeout
+	 * when clock is being stalled by external sink device
+	 */
 	HDMI_OUTP_ND(0x0224, 0xff000000);
 
 	/* 0x027C HDMI_DDC_REF
@@ -2147,8 +2100,6 @@
 {
 	int i, rc = 0;
 	int block_size = 0x80;
-	uint32 ndx;
-	const u8 *b = edid_buf;
 
 	do {
 		DEV_DBG("EDID: reading block(%d) with block-size=%d\n",
@@ -2171,16 +2122,6 @@
 		block_size /= 2;
 	} while (rc && (block_size >= 16));
 
-	pr_info("****EDID : [%d] block****\n", block);
-	for (ndx = 0; ndx < 0x80; ndx += 16)
-		pr_info("EDID[%02x-%02x] %02x %02x %02x %02x  "
-			"%02x %02x %02x %02x    %02x %02x %02x %02x  "
-			"%02x %02x %02x %02x\n", ndx, ndx+15,
-			b[ndx+0], b[ndx+1], b[ndx+2], b[ndx+3],
-			b[ndx+4], b[ndx+5], b[ndx+6], b[ndx+7],
-			b[ndx+8], b[ndx+9], b[ndx+10], b[ndx+11],
-			b[ndx+12], b[ndx+13], b[ndx+14], b[ndx+15]);
-
 	return rc;
 }
 
@@ -2254,7 +2195,7 @@
 		DEV_DBG("%s: Checking", __func__);
 		break;
 	case 3:
-		DEV_INFO("%s: HDCP Keys Valid", __func__);
+		DEV_DBG("%s: HDCP Keys Valid", __func__);
 		break;
 	case 4:
 		DEV_WARN("%s: AKSV not valid", __func__);
@@ -2442,7 +2383,7 @@
 			ret = -EINVAL;
 			goto error;
 		}
-		DEV_INFO("HDCP: AKSV=%02x%08x\n", qfprom_aksv_1, qfprom_aksv_0);
+		DEV_DBG("HDCP: AKSV=%02x%08x\n", qfprom_aksv_1, qfprom_aksv_0);
 
 		/* 0x0288 HDCP_SW_LOWER_AKSV
 			[31:0] LOWER_AKSV */
@@ -2459,29 +2400,6 @@
 
 		msm_hdmi_init_ddc();
 
-		/* Read Bksv 5 bytes at 0x00 in HDCP port */
-		ret = hdmi_msm_ddc_read(0x74, 0x00, bksv, 5, 5, "Bksv", TRUE);
-		if (ret) {
-			DEV_ERR("%s(%d): Read BKSV failed", __func__, __LINE__);
-			goto error;
-		}
-		/* check there are 20 ones in BKSV */
-		if (hdmi_msm_count_one(bksv, 5) != 20) {
-			DEV_ERR("HDCP: BKSV read from Sink doesn't have "
-				"20 1's and 20 0's, FAIL (BKSV="
-				"%02x%02x%02x%02x%02x)\n",
-				bksv[4], bksv[3], bksv[2], bksv[1], bksv[0]);
-			ret = -EINVAL;
-			goto error;
-		}
-
-		link0_bksv_0 = bksv[3];
-		link0_bksv_0 = (link0_bksv_0 << 8) | bksv[2];
-		link0_bksv_0 = (link0_bksv_0 << 8) | bksv[1];
-		link0_bksv_0 = (link0_bksv_0 << 8) | bksv[0];
-		link0_bksv_1 = bksv[4];
-		DEV_INFO("HDCP: BKSV=%02x%08x\n", link0_bksv_1, link0_bksv_0);
-
 		/* read Bcaps at 0x40 in HDCP Port */
 		ret = hdmi_msm_ddc_read(0x74, 0x40, &bcaps, 1, 5, "Bcaps",
 			TRUE);
@@ -2490,7 +2408,7 @@
 			    __LINE__);
 			goto error;
 		}
-		DEV_INFO("HDCP: Bcaps=%02x\n", bcaps);
+		DEV_DBG("HDCP: Bcaps=%02x\n", bcaps);
 
 		/* HDCP setup prior to HDCP enabled */
 
@@ -2499,7 +2417,7 @@
 			[7:0] LINK0_AKSV_1 */
 		/* LINK0_AINFO	= 0x2 FEATURE 1.1 on.
 		 *		= 0x0 FEATURE 1.1 off*/
-		HDMI_OUTP(0x0148, 0x2 << 8);
+		HDMI_OUTP(0x0148, 0x0);
 
 		/* 0x012C HDCP_ENTROPY_CTRL0
 			[31:0] BITS_OF_INFLUENCE_0 */
@@ -2563,15 +2481,10 @@
 				__func__, __LINE__,
 			(HDMI_INP_ND(0x011C) & BIT(8)) >> 8,
 			(HDMI_INP_ND(0x011C) & BIT(9)) >> 9);
+			mutex_unlock(&hdcp_auth_state_mutex);
 			goto error;
 		}
 
-		/*
-		 * A small delay is needed here to avoid device crash observed
-		 * during reauthentication in MSM8960
-		 */
-		msleep(25);
-
 		/* 0x0168 HDCP_RCVPORT_DATA12
 		   [23:8] BSTATUS
 		   [7:0] BCAPS */
@@ -2629,23 +2542,46 @@
 			    __LINE__);
 			goto error;
 		}
-		DEV_INFO("HDCP: Link0-AKSV=%02x%08x\n",
+		DEV_DBG("HDCP: Link0-AKSV=%02x%08x\n",
 			link0_aksv_1 & 0xFF, link0_aksv_0);
 
+		/* Read Bksv 5 bytes at 0x00 in HDCP port */
+		ret = hdmi_msm_ddc_read(0x74, 0x00, bksv, 5, 5, "Bksv", TRUE);
+		if (ret) {
+			DEV_ERR("%s(%d): Read BKSV failed", __func__, __LINE__);
+			goto error;
+		}
+		/* check there are 20 ones in BKSV */
+		if (hdmi_msm_count_one(bksv, 5) != 20) {
+			DEV_ERR("HDCP: BKSV read from Sink doesn't have "
+				"20 1's and 20 0's, FAIL (BKSV="
+				"%02x%02x%02x%02x%02x)\n",
+				bksv[4], bksv[3], bksv[2], bksv[1], bksv[0]);
+			ret = -EINVAL;
+			goto error;
+		}
+
+		link0_bksv_0 = bksv[3];
+		link0_bksv_0 = (link0_bksv_0 << 8) | bksv[2];
+		link0_bksv_0 = (link0_bksv_0 << 8) | bksv[1];
+		link0_bksv_0 = (link0_bksv_0 << 8) | bksv[0];
+		link0_bksv_1 = bksv[4];
+		DEV_DBG("HDCP: BKSV=%02x%08x\n", link0_bksv_1, link0_bksv_0);
+
 		/* 0x0134 HDCP_RCVPORT_DATA0
 		   [31:0] LINK0_BKSV_0 */
 		HDMI_OUTP(0x0134, link0_bksv_0);
 		/* 0x0138 HDCP_RCVPORT_DATA1
 		   [31:0] LINK0_BKSV_1 */
 		HDMI_OUTP(0x0138, link0_bksv_1);
-		DEV_INFO("HDCP: Link0-BKSV=%02x%08x\n", link0_bksv_1,
+		DEV_DBG("HDCP: Link0-BKSV=%02x%08x\n", link0_bksv_1,
 		    link0_bksv_0);
 
 		/* HDMI_HPD_INT_STATUS[0x0250] */
 		hpd_int_status = HDMI_INP_ND(0x0250);
 		/* HDMI_HPD_INT_CTRL[0x0254] */
 		hpd_int_ctrl = HDMI_INP_ND(0x0254);
-		DEV_INFO("[SR-DEUG]: HPD_INTR_CTRL=[%u] HPD_INTR_STATUS=[%u]"
+		DEV_DBG("[SR-DEUG]: HPD_INTR_CTRL=[%u] HPD_INTR_STATUS=[%u] "
 			"before reading R0'\n", hpd_int_ctrl, hpd_int_status);
 
 		/*
@@ -3028,11 +2964,9 @@
 	char *envp[2];
 
 	if (!hdmi_msm_has_hdcp()) {
-#ifdef QCT_SWITCH_STATE_CMD
 		switch_set_state(&external_common_state->sdev, 1);
 		DEV_INFO("Hdmi state switch to %d: %s\n",
 			external_common_state->sdev.state, __func__);
-#endif
 		return;
 	}
 
@@ -3054,10 +2988,6 @@
 	hdmi_msm_state->full_auth_done = FALSE;
 	mutex_unlock(&hdcp_auth_state_mutex);
 
-	/* AKSV read is coming prior to HDMI CORE clk, which can make stability
-	issues, so put it later than HDMI CORE clk */
-	msleep(20);
-
 	/* PART I Authentication*/
 	ret = hdcp_authentication_part1();
 	if (ret)
@@ -3109,11 +3039,9 @@
 		kobject_uevent_env(external_common_state->uevent_kobj,
 		    KOBJ_CHANGE, envp);
 	}
-#ifdef QCT_SWITCH_STATE_CMD
 	switch_set_state(&external_common_state->sdev, 1);
 	DEV_INFO("Hdmi state switch to %d: %s\n",
 		external_common_state->sdev.state, __func__);
-#endif
 	return;
 
 error:
@@ -3133,11 +3061,9 @@
 			queue_work(hdmi_work_queue,
 			    &hdmi_msm_state->hdcp_reauth_work);
 	}
-#ifdef QCT_SWITCH_STATE_CMD
 	switch_set_state(&external_common_state->sdev, 0);
 	DEV_INFO("Hdmi state switch to %d: %s\n",
 		external_common_state->sdev.state, __func__);
-#endif
 }
 #endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT */
 
@@ -3422,6 +3348,10 @@
 
 	HDMI_OUTP(HDMI_AUDIO_CFG, hdmi_audio_config);
 
+	mb();
+	pr_info("%s :HDMI_AUDIO_CFG 0x%08x\n", __func__,
+		HDMI_INP(HDMI_AUDIO_CFG));
+
 	return 0;
 }
 EXPORT_SYMBOL(hdmi_audio_enable);
@@ -3460,11 +3390,9 @@
 	uint32 check_sum, audio_info_0_reg, audio_info_1_reg;
 	uint32 audio_info_ctrl_reg;
 	u32 aud_pck_ctrl_2_reg;
-	u32 aud_hdmi_deb_reg = 0;
 	u32 layout;
 
 	layout = (MSM_HDMI_AUDIO_CHANNEL_2 == num_of_channels) ? 0 : 1;
-	HDMI_OUTP(0x00204, aud_hdmi_deb_reg);
 	aud_pck_ctrl_2_reg = 1 | (layout << 1);
 	HDMI_OUTP(0x00044, aud_pck_ctrl_2_reg);
 
@@ -3574,18 +3502,6 @@
 }
 EXPORT_SYMBOL(hdmi_msm_audio_info_setup);
 
-static void hdmi_msm_audio_ctrl_setup(boolean enabled, int delay)
-{
-	uint32 audio_pkt_ctrl_reg = 0;
-
-	/* Enable Packet Transmission */
-	audio_pkt_ctrl_reg |= enabled ? 0x00000001 : 0;
-	audio_pkt_ctrl_reg |= (delay << 4);
-
-	/* HDMI_AUDIO_PKT_CTRL1[0x0020] */
-	HDMI_OUTP(0x0020, audio_pkt_ctrl_reg);
-}
-
 static void hdmi_msm_en_gc_packet(boolean av_mute_is_requested)
 {
 	/* HDMI_GC[0x0040] */
@@ -3691,7 +3607,6 @@
 		external_common_state->video_resolution,
 		msm_hdmi_sample_rate, channels);
 	hdmi_msm_audio_info_setup(TRUE, channels, 0, 0, FALSE);
-	hdmi_msm_audio_ctrl_setup(TRUE, 1);
 
 	/* Turn on Audio FIFO and SAM DROP ISR */
 	HDMI_OUTP(0x02CC, HDMI_INP(0x02CC) | BIT(1) | BIT(3));
@@ -3723,7 +3638,6 @@
 		}
 	}
 	hdmi_msm_audio_info_setup(FALSE, 0, 0, 0, FALSE);
-	hdmi_msm_audio_ctrl_setup(FALSE, 0);
 	hdmi_msm_audio_acr_setup(FALSE, 0, 0, 0);
 	DEV_INFO("HDMI Audio: Disabled\n");
 	return 0;
@@ -3737,8 +3651,8 @@
 	 0x10,	0x10,	0x10,	0x10,	0x10, 0x10, 0x10}, /*00*/
 	{0x18,	0x18,	0x28,	0x28,	0x28,	0x28,	0x28,	0x28,	0x28,
 	 0x28,	0x28,	0x28,	0x28,	0x18, 0x28, 0x18}, /*01*/
-	{0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
-	 0x00,	0x00,	0x00,	0x00,	0x00, 0x00, 0x00}, /*02*/
+	{0x00,	0x04,	0x04,	0x04,	0x04,	 0x04,	0x04,	0x04,	0x04,
+	 0x04,	0x04,	0x04,	0x04,	0x88, 0x00, 0x04}, /*02*/
 	{0x02,	0x06,	0x11,	0x15,	0x04,	0x13,	0x10,	0x05,	0x1F,
 	 0x14,	0x20,	0x22,	0x21,	0x01, 0x03, 0x11}, /*03*/
 	{0x00,	0x01,	0x00,	0x01,	0x00,	0x00,	0x00,	0x00,	0x00,
@@ -3770,6 +3684,7 @@
 	uint32 regVal;
 	int i;
 	int mode = 0;
+	boolean use_ce_scan_info = TRUE;
 
 	switch (external_common_state->video_resolution) {
 	case HDMI_VFRMT_720x480p60_4_3:
@@ -3835,6 +3750,48 @@
 
 	/* Data Byte 01: 0 Y1 Y0 A0 B1 B0 S1 S0 */
 	aviInfoFrame[3]  = hdmi_msm_avi_iframe_lut[0][mode];
+
+	/*
+	 * If the sink specified support for both underscan/overscan
+	 * then, by default, set the underscan bit.
+	 * Only checking underscan support for preferred format and cea formats
+	 */
+	if ((external_common_state->video_resolution ==
+			external_common_state->preferred_video_format)) {
+		use_ce_scan_info = FALSE;
+		switch (external_common_state->pt_scan_info) {
+		case 0:
+			/*
+			 * Need to use the info specified for the corresponding
+			 * IT or CE format
+			 */
+			DEV_DBG("%s: No underscan information specified for the"
+				" preferred video format\n", __func__);
+			use_ce_scan_info = TRUE;
+			break;
+		case 3:
+			DEV_DBG("%s: Setting underscan bit for the preferred"
+				" video format\n", __func__);
+			aviInfoFrame[3] |= 0x02;
+			break;
+		default:
+			DEV_DBG("%s: Underscan information not set for the"
+				" preferred video format\n", __func__);
+			break;
+		}
+	}
+
+	if (use_ce_scan_info) {
+		if (3 == external_common_state->ce_scan_info) {
+			DEV_DBG("%s: Setting underscan bit for the CE video"
+					" format\n", __func__);
+			aviInfoFrame[3] |= 0x02;
+		} else {
+			DEV_DBG("%s: Not setting underscan bit for the CE video"
+				       " format\n", __func__);
+		}
+	}
+
 	/* Data Byte 02: C1 C0 M1 M0 R3 R2 R1 R0 */
 	aviInfoFrame[4]  = hdmi_msm_avi_iframe_lut[1][mode];
 	/* Data Byte 03: ITC EC2 EC1 EC0 Q1 Q0 SC1 SC0 */
@@ -3990,6 +3947,137 @@
 }
 #endif
 
+#define IFRAME_CHECKSUM_32(d) \
+	((d & 0xff) + ((d >> 8) & 0xff) + \
+	((d >> 16) & 0xff) + ((d >> 24) & 0xff))
+
+static void hdmi_msm_spd_infoframe_packetsetup(void)
+{
+	uint32 packet_header  = 0;
+	uint32 check_sum      = 0;
+	uint32 packet_payload = 0;
+	uint32 packet_control = 0;
+
+	uint8 *vendor_name = external_common_state->spd_vendor_name;
+	uint8 *product_description =
+		external_common_state->spd_product_description;
+
+	/* 0x00A4 GENERIC1_HDR
+	 *   HB0             7:0  NUM
+	 *   HB1            15:8  NUM
+	 *   HB2           23:16  NUM */
+	/* Setup Packet header and payload */
+	/* 0x83 InfoFrame Type Code
+	   0x01 InfoFrame Version Number
+	   0x19 Length of Source Product Description InfoFrame
+	*/
+	packet_header  = 0x83 | (0x01 << 8) | (0x19 << 16);
+	HDMI_OUTP(0x00A4, packet_header);
+	check_sum += IFRAME_CHECKSUM_32(packet_header);
+
+	/* Vendor Name (7bit ASCII code) */
+	/* 0x00A8 GENERIC1_0
+	 *   BYTE0           7:0  CheckSum
+	 *   BYTE1          15:8  VENDOR_NAME[0]
+	 *   BYTE2         23:16  VENDOR_NAME[1]
+	 *   BYTE3         31:24  VENDOR_NAME[2] */
+	packet_payload = ((vendor_name[0] & 0x7f) << 8)
+		| ((vendor_name[1] & 0x7f) << 16)
+		| ((vendor_name[2] & 0x7f) << 24);
+	check_sum += IFRAME_CHECKSUM_32(packet_payload);
+	packet_payload |= ((0x100 - (0xff & check_sum)) & 0xff);
+	HDMI_OUTP(0x00A8, packet_payload);
+
+	/* 0x00AC GENERIC1_1
+	 *   BYTE4           7:0  VENDOR_NAME[3]
+	 *   BYTE5          15:8  VENDOR_NAME[4]
+	 *   BYTE6         23:16  VENDOR_NAME[5]
+	 *   BYTE7         31:24  VENDOR_NAME[6] */
+	packet_payload = (vendor_name[3] & 0x7f)
+		| ((vendor_name[4] & 0x7f) << 8)
+		| ((vendor_name[5] & 0x7f) << 16)
+		| ((vendor_name[6] & 0x7f) << 24);
+	HDMI_OUTP(0x00AC, packet_payload);
+	check_sum += IFRAME_CHECKSUM_32(packet_payload);
+
+	/* Product Description (7-bit ASCII code) */
+	/* 0x00B0 GENERIC1_2
+	 *   BYTE8           7:0  VENDOR_NAME[7]
+	 *   BYTE9          15:8  PRODUCT_NAME[ 0]
+	 *   BYTE10        23:16  PRODUCT_NAME[ 1]
+	 *   BYTE11        31:24  PRODUCT_NAME[ 2] */
+	packet_payload = (vendor_name[7] & 0x7f)
+		| ((product_description[0] & 0x7f) << 8)
+		| ((product_description[1] & 0x7f) << 16)
+		| ((product_description[2] & 0x7f) << 24);
+	HDMI_OUTP(0x00B0, packet_payload);
+	check_sum += IFRAME_CHECKSUM_32(packet_payload);
+
+	/* 0x00B4 GENERIC1_3
+	 *   BYTE12          7:0  PRODUCT_NAME[ 3]
+	 *   BYTE13         15:8  PRODUCT_NAME[ 4]
+	 *   BYTE14        23:16  PRODUCT_NAME[ 5]
+	 *   BYTE15        31:24  PRODUCT_NAME[ 6] */
+	packet_payload = (product_description[3] & 0x7f)
+		| ((product_description[4] & 0x7f) << 8)
+		| ((product_description[5] & 0x7f) << 16)
+		| ((product_description[6] & 0x7f) << 24);
+	HDMI_OUTP(0x00B4, packet_payload);
+	check_sum += IFRAME_CHECKSUM_32(packet_payload);
+
+	/* 0x00B8 GENERIC1_4
+	 *   BYTE16          7:0  PRODUCT_NAME[ 7]
+	 *   BYTE17         15:8  PRODUCT_NAME[ 8]
+	 *   BYTE18        23:16  PRODUCT_NAME[ 9]
+	 *   BYTE19        31:24  PRODUCT_NAME[10] */
+	packet_payload = (product_description[7] & 0x7f)
+		| ((product_description[8] & 0x7f) << 8)
+		| ((product_description[9] & 0x7f) << 16)
+		| ((product_description[10] & 0x7f) << 24);
+	HDMI_OUTP(0x00B8, packet_payload);
+	check_sum += IFRAME_CHECKSUM_32(packet_payload);
+
+	/* 0x00BC GENERIC1_5
+	 *   BYTE20          7:0  PRODUCT_NAME[11]
+	 *   BYTE21         15:8  PRODUCT_NAME[12]
+	 *   BYTE22        23:16  PRODUCT_NAME[13]
+	 *   BYTE23        31:24  PRODUCT_NAME[14] */
+	packet_payload = (product_description[11] & 0x7f)
+		| ((product_description[12] & 0x7f) << 8)
+		| ((product_description[13] & 0x7f) << 16)
+		| ((product_description[14] & 0x7f) << 24);
+	HDMI_OUTP(0x00BC, packet_payload);
+	check_sum += IFRAME_CHECKSUM_32(packet_payload);
+
+	/* 0x00C0 GENERIC1_6
+	 *   BYTE24          7:0  PRODUCT_NAME[15]
+	 *   BYTE25         15:8  Source Device Information
+	 *   BYTE26        23:16  NUM
+	 *   BYTE27        31:24  NUM */
+	/* Source Device Information
+	 * 00h unknown
+	 * 01h Digital STB
+	 * 02h DVD
+	 * 03h D-VHS
+	 * 04h HDD Video
+	 * 05h DVC
+	 * 06h DSC
+	 * 07h Video CD
+	 * 08h Game
+	 * 09h PC general */
+	packet_payload = (product_description[15] & 0x7f) | 0x00 << 8;
+	HDMI_OUTP(0x00C0, packet_payload);
+	check_sum += IFRAME_CHECKSUM_32(packet_payload);
+
+	/* GENERIC1_LINE | GENERIC1_CONT | GENERIC1_SEND
+	 * Setup HDMI TX generic packet control
+	 * Enable this packet to transmit every frame
+	 * Enable HDMI TX engine to transmit Generic packet 1 */
+	packet_control = HDMI_INP_ND(0x0034);
+	packet_control |= ((0x1 << 24) | (1 << 5) | (1 << 4));
+	HDMI_OUTP(0x0034, packet_control);
+}
+
 int hdmi_msm_clk(int on)
 {
 	int rc;
@@ -4016,12 +4104,10 @@
 				rc);
 			return rc;
 		}
-		hdmi_msm_state->clk_status = true;
 	} else {
 		clk_disable_unprepare(hdmi_msm_state->hdmi_app_clk);
 		clk_disable_unprepare(hdmi_msm_state->hdmi_m_pclk);
 		clk_disable_unprepare(hdmi_msm_state->hdmi_s_pclk);
-		hdmi_msm_state->clk_status = false;
 	}
 
 	return 0;
@@ -4029,7 +4115,6 @@
 
 static void hdmi_msm_turn_on(void)
 {
-	uint32 hpd_ctrl;
 	uint32 audio_pkt_ctrl, audio_cfg;
 	/*
 	 * Number of wait iterations for QDSP to disable Audio Engine
@@ -4052,6 +4137,7 @@
 		msleep(20);
 	}
 
+	hdmi_msm_set_mode(FALSE);
 	mutex_lock(&hdcp_auth_state_mutex);
 	hdmi_msm_reset_core();
 	mutex_unlock(&hdcp_auth_state_mutex);
@@ -4060,6 +4146,8 @@
 	/* HDMI_USEC_REFTIMER[0x0208] */
 	HDMI_OUTP(0x0208, 0x0001001B);
 
+	hdmi_msm_set_mode(TRUE);
+
 	hdmi_msm_video_setup(external_common_state->video_resolution);
 	if (!hdmi_msm_is_dvi_mode())
 		hdmi_msm_audio_setup();
@@ -4067,17 +4155,9 @@
 #ifdef CONFIG_FB_MSM_HDMI_3D
 	hdmi_msm_vendor_infoframe_packetsetup();
 #endif
+	hdmi_msm_spd_infoframe_packetsetup();
 
-	/* set timeout to 4.1ms (max) for hardware debounce */
-	hpd_ctrl = (HDMI_INP(0x0258) & ~0xFFF) | 0xFFF;
-
-	/* Toggle HPD circuit to trigger HPD sense */
-	HDMI_OUTP(0x0258, ~(1 << 28) & hpd_ctrl);
-	HDMI_OUTP(0x0258, (1 << 28) | hpd_ctrl);
-
-	hdmi_msm_set_mode(TRUE);
-
-	/* Setup HPD IRQ */
+	/* Set IRQ for HPD */
 	HDMI_OUTP(0x0254, 4 | (external_common_state->hpd_state ? 0 : 2));
 
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
@@ -4086,6 +4166,17 @@
 		hdmi_msm_state->reauth = FALSE ;
 	}
 #endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT */
+
+#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT
+	/* re-initialize CEC if enabled */
+	mutex_lock(&hdmi_msm_state_mutex);
+	if (hdmi_msm_state->cec_enabled == true) {
+		hdmi_msm_cec_init();
+		hdmi_msm_cec_write_logical_addr(
+			hdmi_msm_state->cec_logical_addr);
+	}
+	mutex_unlock(&hdmi_msm_state_mutex);
+#endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT */
 	DEV_INFO("HDMI Core: Initialized\n");
 }
 
@@ -4108,58 +4199,26 @@
 }
 #endif
 
-static void hdmi_msm_hpd_read_work(struct work_struct *work)
-{
-	uint32 hpd_ctrl;
-
-	clk_prepare_enable(hdmi_msm_state->hdmi_app_clk);
-	hdmi_msm_state->pd->core_power(1, 1);
-	hdmi_msm_state->pd->enable_5v(1);
-	hdmi_msm_set_mode(FALSE);
-	hdmi_msm_init_phy(external_common_state->video_resolution);
-	/* HDMI_USEC_REFTIMER[0x0208] */
-	HDMI_OUTP(0x0208, 0x0001001B);
-	hpd_ctrl = (HDMI_INP(0x0258) & ~0xFFF) | 0xFFF;
-
-	/* Toggle HPD circuit to trigger HPD sense */
-	HDMI_OUTP(0x0258, ~(1 << 28) & hpd_ctrl);
-	HDMI_OUTP(0x0258, (1 << 28) | hpd_ctrl);
-
-	hdmi_msm_set_mode(TRUE);
-	msleep(1000);
-	external_common_state->hpd_state = (HDMI_INP(0x0250) & 0x2) >> 1;
-	if (external_common_state->hpd_state) {
-		hdmi_msm_read_edid();
-		DEV_DBG("%s: sense CONNECTED: send ONLINE\n", __func__);
-		hdmi_msm_state->hpd_on_offline = TRUE;
-		kobject_uevent(external_common_state->uevent_kobj,
-			KOBJ_ONLINE);
-	}
-	hdmi_msm_hpd_off();
-	hdmi_msm_set_mode(FALSE);
-	hdmi_msm_state->pd->core_power(0, 1);
-	hdmi_msm_state->pd->enable_5v(0);
-	clk_disable_unprepare(hdmi_msm_state->hdmi_app_clk);
-}
-
 static void hdmi_msm_hpd_off(void)
 {
+	int rc = 0;
+
 	if (!hdmi_msm_state->hpd_initialized) {
 		DEV_DBG("%s: HPD is already OFF, returning\n", __func__);
 		return;
 	}
 
-	DEV_DBG("%s: (timer, clk, 5V, core, IRQ off)\n", __func__);
+	DEV_DBG("%s: (timer, 5V, IRQ off)\n", __func__);
 	del_timer(&hdmi_msm_state->hpd_state_timer);
 	disable_irq(hdmi_msm_state->irq);
 
 	hdmi_msm_set_mode(FALSE);
-	hdmi_msm_state->hpd_initialized = FALSE;
-	hdmi_msm_powerdown_phy();
-	hdmi_msm_state->pd->cec_power(0);
 	hdmi_msm_state->pd->enable_5v(0);
-	hdmi_msm_state->pd->core_power(0, 1);
 	hdmi_msm_clk(0);
+	rc = hdmi_msm_state->pd->gpio_config(0);
+	if (rc != 0)
+		DEV_INFO("%s: Failed to disable GPIOs. Error=%d\n",
+				__func__, rc);
 	hdmi_msm_state->hpd_initialized = FALSE;
 }
 
@@ -4175,73 +4234,97 @@
 {
 	static int phy_reset_done;
 	uint32 hpd_ctrl;
+	int rc = 0;
 
 	if (hdmi_msm_state->hpd_initialized) {
-		DEV_DBG("%s: HPD is already ON, returning\n", __func__);
-		return 0;
+		DEV_DBG("%s: HPD is already ON\n", __func__);
+	} else {
+		rc = hdmi_msm_state->pd->gpio_config(1);
+		if (rc) {
+			DEV_ERR("%s: Failed to enable GPIOs. Error=%d\n",
+					__func__, rc);
+			goto error1;
 	}
 
-	hdmi_msm_clk(1);
-	hdmi_msm_state->pd->core_power(1, 1);
-	hdmi_msm_state->pd->enable_5v(1);
+		rc = hdmi_msm_clk(1);
+		if (rc) {
+			DEV_ERR("%s: Failed to enable clocks. Error=%d\n",
+					__func__, rc);
+			goto error2;
+		}
+
+		rc = hdmi_msm_state->pd->enable_5v(1);
+		if (rc) {
+			DEV_ERR("%s: Failed to enable 5V regulator. Error=%d\n",
+					__func__, rc);
+			goto error3;
+		}
 	hdmi_msm_dump_regs("HDMI-INIT: ");
-	hdmi_msm_set_mode(FALSE);
 
+		hdmi_msm_set_mode(FALSE);
 	if (!phy_reset_done) {
 		hdmi_phy_reset();
 		phy_reset_done = 1;
 	}
+		hdmi_msm_set_mode(TRUE);
 
-	hdmi_msm_init_phy(external_common_state->video_resolution);
 	/* HDMI_USEC_REFTIMER[0x0208] */
 	HDMI_OUTP(0x0208, 0x0001001B);
 
-	/* Check HPD State */
-	enable_irq(hdmi_msm_state->irq);
-
 	/* set timeout to 4.1ms (max) for hardware debounce */
-	hpd_ctrl = (HDMI_INP(0x0258) & ~0xFFF) | 0xFFF;
+		hpd_ctrl = HDMI_INP(0x0258) | 0x1FFF;
 
 	/* Toggle HPD circuit to trigger HPD sense */
 	HDMI_OUTP(0x0258, ~(1 << 28) & hpd_ctrl);
 	HDMI_OUTP(0x0258, (1 << 28) | hpd_ctrl);
 
-	DEV_DBG("%s: (clk, 5V, core, IRQ on) <trigger:%s>\n", __func__,
-		trigger_handler ? "true" : "false");
+		hdmi_msm_state->hpd_initialized = TRUE;
+
+		/* Check HPD State */
+		enable_irq(hdmi_msm_state->irq);
+	}
 
 	if (trigger_handler) {
 		/* Set HPD state machine: ensure at least 2 readouts */
+		mutex_lock(&external_common_state_hpd_mutex);
 		mutex_lock(&hdmi_msm_state_mutex);
 		hdmi_msm_state->hpd_stable = 0;
 		hdmi_msm_state->hpd_prev_state = TRUE;
-		mutex_lock(&external_common_state_hpd_mutex);
 		external_common_state->hpd_state = FALSE;
-		mutex_unlock(&external_common_state_hpd_mutex);
 		hdmi_msm_state->hpd_cable_chg_detected = TRUE;
 		mutex_unlock(&hdmi_msm_state_mutex);
+		mutex_unlock(&external_common_state_hpd_mutex);
 		mod_timer(&hdmi_msm_state->hpd_state_timer,
-			jiffies + HZ/6);
+			jiffies + HZ/2);
 	}
 
-	hdmi_msm_state->hpd_initialized = TRUE;
-
-	hdmi_msm_set_mode(TRUE);
-
+	DEV_DBG("%s: (IRQ, 5V on) <trigger:%s>\n", __func__,
+		trigger_handler ? "true" : "false");
 	return 0;
+
+error3:
+	hdmi_msm_clk(0);
+error2:
+	hdmi_msm_state->pd->gpio_config(0);
+error1:
+	return rc;
 }
 
 static int hdmi_msm_power_ctrl(boolean enable)
 {
-	if (!external_common_state->hpd_feature_on ||
-				!external_common_state->hpd_state)
+	int rc = 0;
+	if (!hdmi_prim_display && !external_common_state->hpd_feature_on)
 		return 0;
 
-	if (enable)
-		hdmi_msm_hpd_on(true);
-	else
+	if (enable) {
+		DEV_DBG("%s: Turning HPD ciruitry on\n", __func__);
+		rc = hdmi_msm_hpd_on(true);
+	} else {
+		DEV_DBG("%s: Turning HPD ciruitry off\n", __func__);
 		hdmi_msm_hpd_off();
+	}
 
-	return 0;
+	return rc;
 }
 
 static int hdmi_msm_power_on(struct platform_device *pdev)
@@ -4265,27 +4348,15 @@
 #endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT */
 
 	changed = hdmi_common_get_video_format_from_drv_data(mfd);
-
-#ifdef	MHL_HPD_SOLUTION
-	/* Hpd is not turned on or off baseed on the user option.
-	 Mhl triggers the on and dtv_off puts the hdmi in off state..*/
-	if (!external_common_state->hpd_feature_on || mfd->ref_cnt) {
-		int rc = hdmi_msm_hpd_on(true);
-		DEV_INFO("HPD: panel power without 'hpd' feature on\n");
-		if (rc) {
-			DEV_WARN("HPD: activation failed: rc=%d\n", rc);
-			return rc;
-		}
-	}
-#endif/*MHL_HPD_SOLUTION*/
 	hdmi_msm_audio_info_setup(TRUE, 0, 0, 0, FALSE);
 
 	mutex_lock(&external_common_state_hpd_mutex);
 	hdmi_msm_state->panel_power_on = TRUE;
-	if ((external_common_state->hpd_state && !hdmi_msm_is_power_on())
-		|| changed) {
+	if (external_common_state->hpd_state && hdmi_msm_is_power_on()) {
+		DEV_DBG("%s: Turning HDMI on\n", __func__);
 		mutex_unlock(&external_common_state_hpd_mutex);
 		hdmi_msm_turn_on();
+		hdmi_msm_hdcp_enable();
 	} else
 		mutex_unlock(&external_common_state_hpd_mutex);
 
@@ -4297,6 +4368,50 @@
 	return 0;
 }
 
+void mhl_connect_api(boolean on)
+{
+	char *envp[2];
+
+	/* Simulating a HPD event based on MHL event */
+	hdmi_msm_state->hpd_cable_chg_detected = FALSE;
+	/* QDSP OFF preceding the HPD event notification */
+	switch_set_state(&external_common_state->sdev, 0);
+	DEV_INFO("Hdmi state switch to %d: %s\n",
+		 external_common_state->sdev.state,  __func__);
+	if (on) {
+		hdmi_msm_read_edid();
+		if (hdmi_msm_has_hdcp())
+			hdmi_msm_state->reauth = FALSE ;
+		/* Build EDID table */
+		hdmi_msm_turn_on();
+		DEV_INFO("HDMI HPD: sense CONNECTED: send ONLINE\n");
+		kobject_uevent(external_common_state->uevent_kobj,
+			       KOBJ_ONLINE);
+		hdmi_msm_hdcp_enable();
+		envp[0] = 0;
+		if (!hdmi_msm_has_hdcp()) {
+			/* Send Audio for HDMI Compliance Cases*/
+			envp[0] = "HDCP_STATE=PASS";
+			envp[1] = NULL;
+			DEV_INFO("HDMI HPD: sense : send HDCP_PASS\n");
+			kobject_uevent_env(external_common_state->uevent_kobj,
+					   KOBJ_CHANGE, envp);
+			switch_set_state(&external_common_state->sdev, 1);
+			DEV_INFO("Hdmi state switch to %d: %s\n",
+				 external_common_state->sdev.state, __func__);
+		}
+	} else {
+		DEV_INFO("HDMI HPD: sense DISCONNECTED: send OFFLINE\n"
+			);
+		kobject_uevent(external_common_state->uevent_kobj,
+			       KOBJ_OFFLINE);
+		switch_set_state(&external_common_state->sdev, 0);
+		DEV_INFO("Hdmi state switch to %d: %s\n",
+			 external_common_state->sdev.state,  __func__);
+	}
+}
+EXPORT_SYMBOL(mhl_connect_api);
+
 /* Note that power-off will also be called when the cable-remove event is
  * processed on the user-space and as a result the framebuffer is powered
  * down.  However, we are still required to be able to detect a cable-insert
@@ -4305,8 +4420,6 @@
  */
 static int hdmi_msm_power_off(struct platform_device *pdev)
 {
-	struct msm_fb_data_type *mfd = platform_get_drvdata(pdev);
-
 	if (!hdmi_msm_state->hdmi_app_clk)
 		return -ENODEV;
 
@@ -4326,51 +4439,17 @@
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 	hdcp_deauthenticate();
 #endif
-	hdmi_msm_hpd_off();
 	hdmi_msm_powerdown_phy();
-	hdmi_msm_dump_regs("HDMI-OFF: ");
-	if (hdmi_msm_state->mhl_hpd_state)
-		hdmi_msm_hpd_on(true);
-
-	mutex_lock(&external_common_state_hpd_mutex);
-	if (!external_common_state->hpd_feature_on || mfd->ref_cnt)
-		hdmi_msm_hpd_off();
-	mutex_unlock(&external_common_state_hpd_mutex);
 
 	hdmi_msm_state->panel_power_on = FALSE;
 	return 0;
 }
 
-static ssize_t sysfs_store_hpd_onoff(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t len)
-{
-	int rc;
-	int onoff;
-
-	DEV_DBG("sysfs_hpd_onoff, set to make hpd interruptible\n");
-
-	rc = kstrtoul(buf, 0, (unsigned long *)&onoff);
-	if (rc < 0)
-		return rc;
-	if (onoff)
-		rc = hdmi_msm_hpd_on(true);
-	else
-		hdmi_msm_hpd_off();
-	return len;
-}
-
-static DEVICE_ATTR(hpd_onoff, 0664,
-			NULL, sysfs_store_hpd_onoff);
-
 static int __devinit hdmi_msm_probe(struct platform_device *pdev)
 {
 	int rc;
 	struct platform_device *fb_dev;
 
-	if (cpu_is_apq8064())
-		return -ENODEV;
-
 	if (!hdmi_msm_state) {
 		pr_err("%s: hdmi_msm_state is NULL\n", __func__);
 		return -ENOMEM;
@@ -4379,7 +4458,7 @@
 	external_common_state->dev = &pdev->dev;
 	DEV_DBG("probe\n");
 	if (pdev->id == 0) {
-		struct resource *res = NULL;
+		struct resource *res;
 
 		#define GET_RES(name, mode) do {			\
 			res = platform_get_resource_byname(pdev, mode, name); \
@@ -4438,6 +4517,8 @@
 		goto error;
 	}
 
+	hdmi_msm_state->is_mhl_enabled = hdmi_msm_state->pd->is_mhl_enabled;
+
 	rc = check_hdmi_features();
 	if (rc) {
 		DEV_ERR("Init FAILED: check_hdmi_features rc=%d\n", rc);
@@ -4454,19 +4535,12 @@
 		rc = -ENODEV;
 		goto error;
 	}
-#ifdef CONFIG_SAMSUNG_HDMI_ENABLE_POWER
-	if (hdmi_msm_state->pd->hdmi_enable)
-		hdmi_msm_state->pd->hdmi_enable();
-#endif
 
-	hdmi_msm_state->boot_completion = false;
-	/*uevent for switching audio path */
-	hdmi_msm_state->hdmi_audio_switch.name = "hdmi";
-	switch_dev_register(&hdmi_msm_state->hdmi_audio_switch);
-
-	/*uevent for info of hdmi audio channel*/
-	hdmi_msm_state->hdmi_audio_ch.name = "ch_hdmi_audio";
-	switch_dev_register(&hdmi_msm_state->hdmi_audio_ch);
+	if (!hdmi_msm_state->pd->cec_power) {
+		DEV_ERR("Init FAILED: cec_power function missing\n");
+		rc = -ENODEV;
+		goto error;
+	}
 
 	rc = request_threaded_irq(hdmi_msm_state->irq, NULL, &hdmi_msm_isr,
 		IRQF_TRIGGER_HIGH | IRQF_ONESHOT, "hdmi_msm_isr", NULL);
@@ -4482,7 +4556,6 @@
 	hdmi_msm_state->hpd_state_timer.data = (uint32)NULL;
 
 	hdmi_msm_state->hpd_state_timer.expires = 0xffffffffL;
-	add_timer(&hdmi_msm_state->hpd_state_timer);
 
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 	init_timer(&hdmi_msm_state->hdcp_timer);
@@ -4513,37 +4586,29 @@
 	} else
 		DEV_ERR("Init FAILED: failed to add fb device\n");
 
-	DEV_INFO("HDMI HPD: ON\n");
-#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
+	if (hdmi_prim_display) {
 	rc = hdmi_msm_hpd_on(true);
 	if (rc)
 		goto error;
-#endif
+	}
 
-#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 	if (hdmi_msm_has_hdcp()) {
+		/* Don't Set Encryption in case of non HDCP builds */
+		external_common_state->present_hdcp = FALSE;
+#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 		external_common_state->present_hdcp = TRUE;
+#endif
 	} else {
 		external_common_state->present_hdcp = FALSE;
+#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 		/*
 		 * If the device is not hdcp capable do
 		 * not start hdcp timer.
 		 */
 		del_timer(&hdmi_msm_state->hdcp_timer);
-	}
-#else
-	external_common_state->present_hdcp = FALSE;
 #endif
-	rc = device_create_file(&pdev->dev, &dev_attr_hpd_onoff);
-	if (rc < 0) {
-		DEV_ERR("failed to add hpd_onoff sysfs entries\n");
-		goto error;
 	}
-#if !defined(CONFIG_VIDEO_MHL_V1) && !defined(CONFIG_VIDEO_MHL_V2)
-	queue_work(hdmi_work_queue, &hdmi_msm_state->hpd_read_work);
-#endif
 
-#ifdef QCT_SWITCH_STATE_CMD
 	/* Initialize hdmi node and register with switch driver */
 	if (hdmi_prim_display)
 		external_common_state->sdev.name = "hdmi_as_primary";
@@ -4551,7 +4616,7 @@
 		external_common_state->sdev.name = "hdmi";
 	if (switch_dev_register(&external_common_state->sdev) < 0)
 		DEV_ERR("Hdmi switch registration failed\n");
-#endif
+
 	return 0;
 
 error:
@@ -4585,10 +4650,9 @@
 
 	DEV_INFO("HDMI HPD: OFF\n");
 
-#ifdef QCT_SWITCH_STATE_CMD
 	/* Unregister hdmi node from switch driver */
 	switch_dev_unregister(&external_common_state->sdev);
-#endif
+
 	hdmi_msm_hpd_off();
 	free_irq(hdmi_msm_state->irq, NULL);
 
@@ -4623,10 +4687,14 @@
 {
 	int rc = 0;
 
-	if (hdmi_msm_state->mhl_hpd_state)
-		hdmi_msm_hpd_on(true);
-
-	hdmi_msm_state->boot_completion = true;
+	DEV_INFO("%s: %d\n", __func__, on);
+	if (on) {
+		rc = hdmi_msm_hpd_on(true);
+	} else {
+		hdmi_msm_hpd_off();
+		/* Set HDMI switch node to 0 on HPD feature disable */
+		switch_set_state(&external_common_state->sdev, 0);
+	}
 
 	return rc;
 }
@@ -4640,9 +4708,7 @@
 static struct msm_fb_panel_data hdmi_msm_panel_data = {
 	.on = hdmi_msm_power_on,
 	.off = hdmi_msm_power_off,
-#ifdef	MHL_HPD_SOLUTION
 	.power_ctrl = hdmi_msm_power_ctrl,
-#endif
 };
 
 static struct platform_device this_device = {
@@ -4655,9 +4721,6 @@
 {
 	int rc;
 
-	if (cpu_is_msm8930())
-		return 0;
-
 	if (msm_fb_detect_client("hdmi_msm"))
 		return 0;
 
@@ -4669,7 +4732,8 @@
 	hdmi_msm_state = kzalloc(sizeof(*hdmi_msm_state), GFP_KERNEL);
 	if (!hdmi_msm_state) {
 		pr_err("hdmi_msm_init FAILED: out of memory\n");
-		return -ENOMEM;
+		rc = -ENOMEM;
+		goto init_exit;
 	}
 
 	external_common_state = &hdmi_msm_state->common;
@@ -4677,16 +4741,31 @@
 #ifdef CONFIG_FB_MSM_HDMI_3D
 	external_common_state->switch_3d = hdmi_msm_switch_3d;
 #endif
+	memset(external_common_state->spd_vendor_name, 0,
+			sizeof(external_common_state->spd_vendor_name));
+	memset(external_common_state->spd_product_description, 0,
+			sizeof(external_common_state->spd_product_description));
+
+#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT
+	hdmi_msm_state->cec_queue_start =
+		kzalloc(sizeof(struct hdmi_msm_cec_msg)*CEC_QUEUE_SIZE,
+			GFP_KERNEL);
+	if (!hdmi_msm_state->cec_queue_start) {
+		pr_err("hdmi_msm_init FAILED: CEC queue out of memory\n");
+		rc = -ENOMEM;
+		goto init_exit;
+	}
+
+	hdmi_msm_state->cec_queue_wr = hdmi_msm_state->cec_queue_start;
+	hdmi_msm_state->cec_queue_rd = hdmi_msm_state->cec_queue_start;
+	hdmi_msm_state->cec_queue_full = false;
+#endif
 
 	/*
 	 * Create your work queue
 	 * allocs and returns ptr
 	*/
 	hdmi_work_queue = create_workqueue("hdmi_hdcp");
-	if (!hdmi_work_queue) {
-		rc = -ENOMEM;
-		goto init_exit;
-	}
 	external_common_state->hpd_feature = hdmi_msm_hpd_feature;
 
 	rc = platform_driver_register(&this_driver);
@@ -4699,7 +4778,6 @@
 	hdmi_common_init_panel_info(&hdmi_msm_panel_data.panel_info);
 	init_completion(&hdmi_msm_state->ddc_sw_done);
 	INIT_WORK(&hdmi_msm_state->hpd_state_work, hdmi_msm_hpd_state_work);
-	INIT_WORK(&hdmi_msm_state->hpd_read_work, hdmi_msm_hpd_read_work);
 #ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_HDCP_SUPPORT
 	init_completion(&hdmi_msm_state->hdcp_success_done);
 	INIT_WORK(&hdmi_msm_state->hdcp_reauth_work, hdmi_msm_hdcp_reauth_work);
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/hdmi_msm.h msm/hdmi_msm.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/hdmi_msm.h	2012-07-16 10:04:32.201489771 -0700
+++ msm/hdmi_msm.h	2012-08-14 12:32:39.476339485 -0700
@@ -14,7 +14,6 @@
 #define __HDMI_MSM_H__
 
 #include <mach/msm_iomap.h>
-#include <linux/switch.h>
 #include "external_common.h"
 /* #define PORT_DEBUG */
 
@@ -34,7 +33,22 @@
 #define HDMI_INP(offset)		inpdw(MSM_HDMI_BASE+(offset))
 #endif
 
+
+/*
+ * Ref. HDMI 1.4a
+ * Supplement-1 CEC Section 6, 7
+ */
+struct hdmi_msm_cec_msg {
+	uint8 sender_id;
+	uint8 recvr_id;
+	uint8 opcode;
+	uint8 operand[15];
+	uint8 frame_size;
+	uint8 retransmit;
+};
+
 #define QFPROM_BASE		((uint32)hdmi_msm_state->qfprom_io)
+#define HDMI_BASE		((uint32)hdmi_msm_state->hdmi_io)
 
 struct hdmi_msm_state_type {
 	boolean panel_power_on;
@@ -47,7 +61,7 @@
 	boolean hpd_cable_chg_detected;
 	boolean full_auth_done;
 	boolean hpd_during_auth;
-	struct work_struct hpd_state_work, hpd_read_work;
+	struct work_struct hpd_state_work;
 	struct timer_list hpd_state_timer;
 	struct completion ddc_sw_done;
 
@@ -84,7 +98,7 @@
 
 #define CEC_QUEUE_SIZE		16
 #define CEC_QUEUE_END	 (hdmi_msm_state->cec_queue_start + CEC_QUEUE_SIZE)
-#define RETRANSMIT_MAX_NUM	7
+#define RETRANSMIT_MAX_NUM	5
 #endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT */
 
 	int irq;
@@ -92,18 +106,11 @@
 	struct clk *hdmi_app_clk;
 	struct clk *hdmi_m_pclk;
 	struct clk *hdmi_s_pclk;
-	boolean clk_status;
 	void __iomem *qfprom_io;
 	void __iomem *hdmi_io;
 
 	struct external_common_state_type common;
-#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
-	boolean mhl_hpd_state;
-	boolean hpd_on_offline;
-#endif
-	struct switch_dev	hdmi_audio_switch;
-	struct switch_dev	hdmi_audio_ch;
-	boolean	boot_completion;
+	boolean is_mhl_enabled;
 };
 
 extern struct hdmi_msm_state_type *hdmi_msm_state;
@@ -121,4 +128,12 @@
 void hdmi_msm_phy_status_poll(void);
 #endif
 
+#ifdef CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT
+void hdmi_msm_cec_init(void);
+void hdmi_msm_cec_write_logical_addr(int addr);
+void hdmi_msm_cec_msg_recv(void);
+void hdmi_msm_cec_one_touch_play(void);
+void hdmi_msm_cec_msg_send(struct hdmi_msm_cec_msg *msg);
+#endif /* CONFIG_FB_MSM_HDMI_MSM_PANEL_CEC_SUPPORT */
+void mhl_connect_api(boolean on);
 #endif /* __HDMI_MSM_H__ */
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/Kconfig msm/Kconfig
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/Kconfig	2012-08-08 09:32:42.755525958 -0700
+++ msm/Kconfig	2012-08-14 12:32:39.463339486 -0700
@@ -1,7 +1,5 @@
 
 source "drivers/video/msm/vidc/Kconfig"
-source "drivers/video/msm/mhl_v1/Kconfig"
-source "drivers/video/msm/mhl_v2/Kconfig"
 
 config FB_MSM
 	tristate "MSM Framebuffer support"
@@ -86,6 +84,16 @@
 	  Support for MSM MDP HW revision 4.0
 	  Say Y here if this is msm7x30 variant platform.
 
+config FB_MSM_MDSS
+	bool "MDSS HW"
+	---help---
+	The Mobile Display Sub System (MDSS) driver supports devices which
+	contain MDSS hardware block.
+
+	The MDSS driver implements frame buffer interface to provide access to
+	the display hardware and provide a way for users to display graphics
+	on connected display panels.
+
 config FB_MSM_MDP_NONE
 	bool "MDP HW None"
 	---help---
@@ -109,6 +117,10 @@
 	bool
 	default n
 
+config FB_MSM_LVDS
+	bool
+	default n
+
 config FB_MSM_OVERLAY
 	depends on FB_MSM_MDP40 && ANDROID_PMEM
 	bool "MDP4 overlay support"
@@ -186,21 +198,19 @@
         select FB_MSM_MIPI_DSI
         default n
 
-config FB_MSM_MIPI_DSI_SAMSUNG_OLED
+config FB_MSM_MIPI_DSI_NT35510
 	bool
 	select FB_MSM_MIPI_DSI
-	default n
-
-config SAMSUNG_CMC624
-	bool "Support for integrated LCD controller in msm8960"
-	depends on FB && ARCH_MSM
-	default n
 
 config FB_MSM_MIPI_DSI_ORISE
         bool
         select FB_MSM_MIPI_DSI
         default n
 
+config FB_MSM_MIPI_DSI_NT35516
+	bool
+	select FB_MSM_MIPI_DSI
+
 config FB_MSM_MIPI_DSI_TC358764_DSI2LVDS
 	bool
 	select FB_MSM_MIPI_DSI
@@ -263,6 +273,20 @@
 	select FB_MSM_LCDC_PANEL
 	default n
 
+config FB_MSM_LCDC_TRULY_HVGA_IPS3P2335
+        bool
+        select FB_MSM_LCDC_PANEL
+        default n
+
+config FB_MSM_LCDC_TRULY_HVGA_IPS3P2335_PT_PANEL
+        depends on FB_MSM_LCDC_HW
+        bool "LCDC Truly HVGA PT Panel"
+        select FB_MSM_LCDC_TRULY_HVGA_IPS3P2335
+        default n
+        ---help---
+        Support for LCDC Truly HVGA PT panel
+
+
 config FB_MSM_LCDC_SAMSUNG_OLED_PT
 	bool
 	select FB_MSM_LCDC_PANEL
@@ -278,6 +302,16 @@
 	select FB_MSM_LCDC_PANEL
 	default n
 
+config FB_MSM_LVDS_CHIMEI_WXGA
+	bool
+	select FB_MSM_LVDS
+	default n
+
+config FB_MSM_LVDS_FRC_FHD
+	bool
+	select FB_MSM_LVDS
+	default n
+
 config FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT
 	bool
 	select FB_MSM_MIPI_DSI_TOSHIBA
@@ -298,25 +332,11 @@
 	select FB_MSM_MIPI_DSI_NOVATEK
 	default n
 
-config FB_MSM_MIPI_MAGNA_OLED_VIDEO_QHD_PT
-	bool
-	select FB_MSM_MIPI_DSI_SAMSUNG_OLED
-	default n
-
 config FB_MSM_MIPI_NOVATEK_CMD_QHD_PT
 	bool
 	select FB_MSM_MIPI_DSI_NOVATEK
 	default n
 
-config FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT
-	bool
-	select FB_MSM_MIPI_DSI_NOVATEK
-	default n
-
-config FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT
-	bool
-	select FB_MSM_MIPI_DSI_NOVATEK
-
 config FB_MSM_MIPI_ORISE_VIDEO_720P_PT
 	bool
 	select FB_MSM_MIPI_DSI_ORISE
@@ -337,20 +357,27 @@
 	select FB_MSM_MIPI_DSI_RENESAS
 	default n
 
-config FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT
+config FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT
 	bool
-	select FB_MSM_MIPI_DSI_SAMSUNG_OLED
+	select FB_MSM_MIPI_DSI_NT35510
 	default n
 
-config FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT
+config FB_MSM_MIPI_NT35510_CMD_WVGA_PT
 	bool
-	select FB_MSM_MIPI_DSI_SAMSUNG_OLED
+	select FB_MSM_MIPI_DSI_NT35510
 	default n
 
-config FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_WVGA_PT
+config FB_MSM_MIPI_NT35516_VIDEO_QHD_PT
 	bool
-	select FB_MSM_MIPI_DSI_SAMSUNG_OLED
+        select FB_MSM_MIPI_DSI_NT35516
 	default n
+
+config FB_MSM_MIPI_NT35516_CMD_QHD_PT
+        bool
+        select FB_MSM_MIPI_DSI_NT35516
+        default n
+
+
 config FB_MSM_MIPI_CHIMEI_WXGA
 	bool "LVDS Chimei WXGA Panel using Toshiba MIPI DSI-to-LVDS bridge."
 	select FB_MSM_MIPI_DSI_TC358764_DSI2LVDS
@@ -360,17 +387,14 @@
 	  The panel is connected to the host
 	  via Toshiba DSI-to-LVDS bridge.
 
-
-config FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT
-	bool
-	select FB_MSM_MIPI_DSI_TC358764_DSI2LVDS
-	default n
-
-config FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT
-	bool
+config FB_MSM_MIPI_CHIMEI_WUXGA
+	bool "LVDS Chimei WUXGA Panel using Toshiba MIPI DSI-to-LVDS bridge."
 	select FB_MSM_MIPI_DSI_TC358764_DSI2LVDS
-	default n
-
+	---help---
+	  Support for Chimei WUXGA (1920x1200) panel.
+	  The panel is using a serial LVDS input.
+	  The panel is connected to the host
+	  via Toshiba DSI-to-LVDS bridge.
 
 config FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT
 	bool
@@ -381,10 +405,6 @@
 	select FB_MSM_MIPI_DSI_SIMULATOR
 	default n
 
-config FB_MSM_MIPI_PANEL_POWERON_LP11
-	default n
-	bool "LP11 assertion during panel power on"
-
 config FB_MSM_NO_MDP_PIPE_CTRL
 	depends on FB_MSM_OVERLAY
 	bool "Do not use mdp_pipe_ctrl"
@@ -488,6 +508,21 @@
 	---help---
 	  Support for LCDC Samsung OLED PT (480x800) panel
 
+config FB_MSM_LVDS_CHIMEI_WXGA_PANEL
+        bool "LVDS Chimei WXGA Panel"
+        select FB_MSM_LVDS_CHIMEI_WXGA
+        ---help---
+          Support for LVDS Chimei WXGA(1366x768) panel
+
+config FB_MSM_LVDS_FRC_FHD_PANEL
+	bool "LVDS FRC FHD Panel"
+	select FB_MSM_LVDS_FRC_FHD
+	---help---
+	  Support for LVDS Frc FHD(1920x1080) panel
+	  FRC(Frame Rate Converter) uses LVDS as input
+	  interface. It is treated as a HDMI panel with
+	  1920x1080 resolution.
+
 config FB_MSM_TRY_MDDI_CATCH_LCDC_PRISM
 	depends on FB_MSM_LCDC_HW
 	bool "MDDI Panel Auto Detect + LCDC Prism WVGA"
@@ -509,21 +544,19 @@
 	select FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT
 	select FB_MSM_MIPI_TOSHIBA_VIDEO_WUXGA
 	select FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT
-	select FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT
-	select FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT
-	select FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_WVGA_PT
 	select FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT
 	select FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT
 	select FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT
 	select FB_MSM_MIPI_NOVATEK_CMD_QHD_PT
-	select FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT
-	select FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT
+	select FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT
+	select FB_MSM_MIPI_NT35510_CMD_WVGA_PT
 	select FB_MSM_MIPI_ORISE_VIDEO_720P_PT
 	select FB_MSM_MIPI_ORISE_CMD_720P_PT
+	select FB_MSM_MIPI_NT35516_VIDEO_QHD_PT
+	select FB_MSM_MIPI_NT35516_CMD_QHD_PT
 	select FB_MSM_MIPI_SIMULATOR_VIDEO
 	select FB_MSM_MIPI_CHIMEI_WXGA
-	select FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT
-	select FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT
+	select FB_MSM_MIPI_CHIMEI_WUXGA
 	---help---
 	  Support for MIPI panel auto detect
 
@@ -557,14 +590,36 @@
 	select FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT
 	select FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT
 	select FB_MSM_MIPI_NOVATEK_CMD_QHD_PT
-	select FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT
-	select FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT
+	select FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT
+	select FB_MSM_MIPI_NT35510_CMD_WVGA_PT
+	select FB_MSM_MIPI_NT35516_VIDEO_QHD_PT
+	select FM_MSM_MIPI_NT35516_CMD_QHD_PT
 	select FB_MSM_MIPI_SIMULATOR_VIDEO
-	select FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT
-	select FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT
 	---help---
 	  Support for LCDC + MIPI panel auto detect
 
+config FB_MSM_LVDS_MIPI_PANEL_DETECT
+	bool "LVDS + MIPI Panel Auto Detect"
+	select FB_MSM_LVDS_CHIMEI_WXGA
+	select FB_MSM_LVDS_FRC_FHD
+	select FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT
+	select FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT
+	select FB_MSM_MIPI_TOSHIBA_VIDEO_WUXGA
+	select FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT
+	select FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT
+	select FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT
+	select FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT
+	select FB_MSM_MIPI_NOVATEK_CMD_QHD_PT
+	select FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT
+	select FB_MSM_MIPI_NT35510_CMD_WVGA_PT
+	select FB_MSM_MIPI_ORISE_VIDEO_720P_PT
+	select FB_MSM_MIPI_ORISE_CMD_720P_PT
+	select FB_MSM_MIPI_SIMULATOR_VIDEO
+	select FB_MSM_MIPI_CHIMEI_WXGA
+	select FB_MSM_MIPI_CHIMEI_WUXGA
+	---help---
+	  Support for LVDS + MIPI panel auto detect
+
 config FB_MSM_MDDI_PRISM_WVGA
 	bool "MDDI Prism WVGA Panel"
 	select FB_MSM_MDDI
@@ -611,22 +666,10 @@
 	bool "MIPI NOVATEK VIDEO QHD PT Panel"
 	select FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT
 
-config FB_MSM_MIPI_MAGNA_OLED_VIDEO_QHD_PT_PANEL
-	bool "MIPI MAGNA VIDEO QHD PT Panel"
-	select FB_MSM_MIPI_MAGNA_OLED_VIDEO_QHD_PT
-
 config FB_MSM_MIPI_NOVATEK_CMD_QHD_PT_PANEL
 	bool "MIPI NOVATEK CMD QHD PT Panel"
 	select FB_MSM_MIPI_NOVATEK_CMD_QHD_PT
 
-config FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT_PANEL
-	bool "MIPI NOVATEK CMD WVGA PT Panel"
-	select FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT
-
-config FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT_PANEL
-	bool "MIPI NOVATEK BOE CMD WVGA PT Panel"
-	select FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT
-
 config FB_MSM_MIPI_ORISE_VIDEO_720P_PT_PANEL
 	bool "MIPI ORISE VIDEO 720P PT Panel"
 	select FB_MSM_MIPI_ORISE_VIDEO_720P_PT
@@ -643,33 +686,34 @@
 	bool "MIPI Renesas Command FWVGA PT Panel"
 	select FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT
 
-config FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT_PANEL
-	bool "MIPI SAMSUNG OLED CMD QHD PT Panel"
-	select FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT
-
-config FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT_PANEL
-	bool "MIPI SAMSUNG OLED VIDEO HD PT Panel"
-	select FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT
-
-config FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_WVGA_PT_PANEL
-	bool "MIPI SAMSUNG OLED VIDEO WVGA PT Panel"
-	select FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_WVGA_PT
 config FB_MSM_MIPI_CHIMEI_WXGA_PANEL
 	bool "MIPI Chimei WXGA PT Panel"
 	select FB_MSM_MIPI_CHIMEI_WXGA
 
-config FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT_PANEL
-	bool "Samsung MIPI+LVDS WSVGA Panel"
-	select FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT
-
-config FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT_PANEL
-	bool "BEOT MIPI+LVDS WSVGA Panel"
-	select FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT
+config FB_MSM_MIPI_CHIMEI_WUXGA_PANEL
+	bool "MIPI Chimei WUXGA Panel"
+	select FB_MSM_MIPI_CHIMEI_WUXGA
 
 config FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT_PANEL
 	bool "MIPI Truly Video WVGA PT Panel"
 	select FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT
 
+config FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT_PANEL
+	bool "MIPI NT35510 Video WVGA PT Panel"
+	select FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT
+
+config FB_MSM_MIPI_NT35510_CMD_WVGA_PT_PANEL
+	bool "MIPI NT35510 Command WVGA PT Panel"
+	select FB_MSM_MIPI_NT35510_CMD_WVGA_PT
+
+config FB_MSM_MIPI_NT35516_VIDEO_QHD_PT_PANEL
+        bool "MIPI NT35516 Video qHD PT Panel"
+        select FB_MSM_MIPI_NT35516_VIDEO_QHD_PT
+
+config FB_MSM_MIPI_NT35516_CMD_QHD_PT_PANEL
+        bool "MIPI NT35516 Command qHD PT Panel"
+        select FB_MSM_MIPI_NT35516_CMD_QHD_PT
+
 config FB_MSM_MIPI_SIMULATOR_VIDEO_PANEL
 	bool "MIPI Simulator Video Panel"
 	select FB_MSM_MIPI_SIMULATOR_VIDEO
@@ -718,15 +762,6 @@
 	  No secondary panel
 endchoice
 
-config FB_MSM_BACKLIGHT_AAT1402IUQ
-	depends on FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT_PANEL
-	bool "AAT1402IUQ Backlight Driver"
-	default n
-
-config MIPI_SAMSUNG_ESD_REFRESH
-	bool "Samsung ESD Recovery Driver"
-	default n
-
 config FB_MSM_LCDC_DSUB
 	depends on FB_MSM_LCDC_SAMSUNG_WSVGA && FB_MSM_MDP40 && FB_MSM_LCDC_HW
 	bool "External DSUB support"
@@ -801,9 +836,18 @@
 	  Support for HDMI CEC Feature
 	  Choose to enable CEC
 
-config FB_MSM_HDMI_MHL
+config FB_MSM_HDMI_MHL_9244
 	depends on FB_MSM_HDMI_MSM_PANEL
-	bool 'HDMI to MHL support'
+	bool 'SI_MHL 9244 support'
+	default n
+	---help---
+	  Support the HDMI to MHL conversion.
+	  MHL (Mobile High-Definition Link) technology
+	  uses USB connector to output HDMI content
+
+config FB_MSM_HDMI_MHL_8334
+	depends on FB_MSM_HDMI_MSM_PANEL
+	bool 'SI_MHL 8334 support '
 	default n
 	---help---
 	  Support the HDMI to MHL conversion.
@@ -911,4 +955,8 @@
 	default n
 	---help---
 	  Support for EBI2 panel auto detect
+
+if FB_MSM_MDSS
+	source "drivers/video/msm/mdss/Kconfig"
+endif
 endif
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/lcdc.c msm/lcdc.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/lcdc.c	2012-08-08 09:32:42.782525955 -0700
+++ msm/lcdc.c	2012-08-14 12:32:48.898338840 -0700
@@ -37,6 +37,7 @@
 
 static int lcdc_off(struct platform_device *pdev);
 static int lcdc_on(struct platform_device *pdev);
+static void cont_splash_clk_ctrl(int enable);
 
 static struct platform_device *pdev_list[MSM_FB_MAX_DEV_LIST];
 static int pdev_list_cnt;
@@ -100,6 +101,8 @@
 #endif
 	mfd = platform_get_drvdata(pdev);
 
+	cont_splash_clk_ctrl(0);
+
 	if (lcdc_pdata && lcdc_pdata->lcdc_get_clk)
 		panel_pixclock_freq = lcdc_pdata->lcdc_get_clk();
 
@@ -151,6 +154,20 @@
 	return ret;
 }
 
+static void cont_splash_clk_ctrl(int enable)
+{
+	static int cont_splash_clks_enabled;
+	if (enable && !cont_splash_clks_enabled) {
+		clk_prepare_enable(pixel_mdp_clk);
+		clk_prepare_enable(pixel_lcdc_clk);
+		cont_splash_clks_enabled = 1;
+	} else if (!enable && cont_splash_clks_enabled) {
+		clk_disable_unprepare(pixel_mdp_clk);
+		clk_disable_unprepare(pixel_lcdc_clk);
+		cont_splash_clks_enabled = 0;
+	}
+}
+
 static int lcdc_probe(struct platform_device *pdev)
 {
 	struct msm_fb_data_type *mfd;
@@ -199,6 +216,8 @@
 	if (!mdp_dev)
 		return -ENOMEM;
 
+	cont_splash_clk_ctrl(1);
+
 	/*
 	 * link to the latest pdev
 	 */
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/lcdc_gordon.c msm/lcdc_gordon.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/lcdc_gordon.c	2012-07-16 10:04:32.201489771 -0700
+++ msm/lcdc_gordon.c	2012-08-14 12:32:39.477339485 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2009-2010, 2012 Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -12,7 +12,7 @@
  */
 
 #include <linux/delay.h>
-#include <mach/gpio.h>
+#include <linux/gpio.h>
 #include "msm_fb.h"
 
 /* registers */
@@ -84,6 +84,7 @@
 static int spi_sdo;
 static int spi_sdi;
 static int spi_dac;
+static int bl_level;
 static unsigned char bit_shift[8] = { (1 << 7),	/* MSB */
 	(1 << 6),
 	(1 << 5),
@@ -313,6 +314,17 @@
 		spi_init();	/* LCD needs SPI */
 		gordon_disp_powerup();
 		gordon_disp_on();
+		if (bl_level <= 1) {
+			/* keep back light OFF */
+			serigo(GORDON_REG_LCDIFCTL2, 0x0B);
+			udelay(15);
+			serigo(GORDON_REG_VALTRAN, 0x01);
+		} else {
+			/* keep back light ON */
+			serigo(GORDON_REG_LCDIFCTL2, 0x7B);
+			udelay(15);
+			serigo(GORDON_REG_VALTRAN, 0x01);
+		}
 		gordon_state.disp_initialized = TRUE;
 	}
 	return 0;
@@ -351,8 +363,9 @@
 
 static void lcdc_gordon_set_backlight(struct msm_fb_data_type *mfd)
 {
-		int bl_level = mfd->bl_level;
+		bl_level = mfd->bl_level;
 
+		if (gordon_state.disp_initialized) {
 		if (bl_level <= 1) {
 			/* keep back light OFF */
 			serigo(GORDON_REG_LCDIFCTL2, 0x0B);
@@ -365,6 +378,7 @@
 			serigo(GORDON_REG_VALTRAN, 0x01);
 		}
 }
+}
 
 static int __devinit gordon_probe(struct platform_device *pdev)
 {
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/lcdc_toshiba_fwvga_pt.c msm/lcdc_toshiba_fwvga_pt.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/lcdc_toshiba_fwvga_pt.c	2012-07-16 10:04:32.202489771 -0700
+++ msm/lcdc_toshiba_fwvga_pt.c	2012-08-14 12:32:39.489339484 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -436,7 +436,7 @@
 	pinfo->bl_max = 100;
 	pinfo->bl_min = 1;
 
-	if (cpu_is_msm7x25a() || cpu_is_msm7x25aa()) {
+	if (cpu_is_msm7x25a() || cpu_is_msm7x25aa() || cpu_is_msm7x25ab()) {
 		pinfo->yres = 320;
 		pinfo->lcdc.h_back_porch = 10;
 		pinfo->lcdc.h_front_porch = 21;
Only in msm: lcdc_truly_ips3p2335.c
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/logo.c msm/logo.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/logo.c	2012-08-08 09:32:42.782525955 -0700
+++ msm/logo.c	2012-07-26 15:01:31.761832375 -0700
@@ -23,10 +23,6 @@
 
 #include <linux/irq.h>
 #include <asm/system.h>
-#if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT)
-#include <asm/cacheflush.h>
-#endif
 
 #define fb_width(fb)	((fb)->var.xres)
 #define fb_height(fb)	((fb)->var.yres)
@@ -40,42 +36,6 @@
 		*ptr++ = val;
 }
 
-
-/* convert RGB565 to RBG8888 */
-static int total_pixel = 1;
-static int memset16_rgb8888(void *_ptr, unsigned short val, unsigned count,
-				struct fb_info *fb)
-{
-	unsigned short *ptr = _ptr;
-	unsigned short red;
-	unsigned short green;
-	unsigned short blue;
-	int need_align = (fb->fix.line_length >> 2) - fb->var.xres;
-	int align_amount = need_align << 1;
-	int pad = 0;
-
-	red = (val & 0xF800) >> 8;
-	green = (val & 0x7E0) >> 3;
-	blue = (val & 0x1F) << 3;
-
-	count >>= 1;
-	while (count--) {
-		*ptr++ = (green << 8) | red;
-		*ptr++ = blue;
-
-		if (need_align) {
-			if (!(total_pixel % fb->var.xres)) {
-				ptr += align_amount;
-				pad++;
-			}
-		}
-
-		total_pixel++;
-	}
-
-	return pad * align_amount;
-}
-
 /* 565RLE image format: [count(2 bytes), rle(2 bytes)] */
 int load_565rle_image(char *filename, bool bf_supported)
 {
@@ -83,10 +43,6 @@
 	int fd, count, err = 0;
 	unsigned max;
 	unsigned short *data, *bits, *ptr;
-#ifndef CONFIG_FRAMEBUFFER_CONSOLE
-	struct module *owner;
-#endif
-	int pad;
 
 	info = registered_fb[0];
 	if (!info) {
@@ -95,16 +51,6 @@
 		return -ENODEV;
 	}
 
-#ifndef CONFIG_FRAMEBUFFER_CONSOLE
-	owner = info->fbops->owner;
-	if (!try_module_get(owner))
-		return -ENODEV;
-	if (info->fbops->fb_open && info->fbops->fb_open(info, 0)) {
-		module_put(owner);
-		return -ENODEV;
-	}
-#endif
-
 	fd = sys_open(filename, O_RDONLY, 0);
 	if (fd < 0) {
 		printk(KERN_WARNING "%s: Can not open %s\n",
@@ -141,95 +87,17 @@
 		unsigned n = ptr[0];
 		if (n > max)
 			break;
-		if (info->var.bits_per_pixel >= 24) {
-			pad = memset16_rgb8888(bits, ptr[1], n << 1, info);
-			bits += n << 1;
-			bits += pad;
-		} else {
 			memset16(bits, ptr[1], n << 1);
 			bits += n;
-		}
 		max -= n;
 		ptr += 2;
 		count -= 4;
 	}
 
-#if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT)
-	flush_cache_all();
-	outer_flush_all();
-#endif
-
 err_logo_free_data:
 	kfree(data);
 err_logo_close_file:
 	sys_close(fd);
-
-#ifndef CONFIG_FRAMEBUFFER_CONSOLE
-	err = fb_pan_display(info, &info->var);
-	if (err < 0) {
-		printk(KERN_WARNING "%s: Can not update framebuffer\n",
-			__func__);
-		return -ENODEV;
-	}
-#endif
-
 	return err;
 }
 EXPORT_SYMBOL(load_565rle_image);
-
-int draw_rgb888_screen(void)
-{
-	struct fb_info *fb = registered_fb[0];
-	u32 height = fb->var.yres / 5;
-	u32 line = fb->fix.line_length;
-	u32 i, j;
-
-	for (i = 0; i < height; i++) {
-		for (j = 0; j < fb->var.xres; j++) {
-			memset(fb->screen_base + i * line + j * 4 + 0, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 1, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 2, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 3, 0x00, 1);
-		}
-	}
-
-	for (i = height; i < height * 2; i++) {
-		for (j = 0; j < fb->var.xres; j++) {
-			memset(fb->screen_base + i * line + j * 4 + 0, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 1, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 2, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 3, 0x00, 1);
-		}
-	}
-
-	for (i = height * 2; i < height * 3; i++) {
-		for (j = 0; j < fb->var.xres; j++) {
-			memset(fb->screen_base + i * line + j * 4 + 0, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 1, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 2, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 3, 0x00, 1);
-		}
-	}
-
-	for (i = height * 3; i < height * 4; i++) {
-		for (j = 0; j < fb->var.xres; j++) {
-			memset(fb->screen_base + i * line + j * 4 + 0, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 1, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 2, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 3, 0xff, 1);
-		}
-	}
-
-	for (i = height * 4; i < height * 5; i++) {
-		for (j = 0; j < fb->var.xres; j++) {
-			memset(fb->screen_base + i * line + j * 4 + 0, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 1, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 2, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 3, 0x00, 1);
-		}
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(draw_rgb888_screen);
Only in msm: lvds.c
Only in msm: lvds_chimei_wxga.c
Only in msm: lvds_frc_fhd.c
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/Makefile msm/Makefile
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/Makefile	2012-08-08 09:32:42.755525958 -0700
+++ msm/Makefile	2012-08-14 12:32:39.474339485 -0700
@@ -1,10 +1,12 @@
+ifeq ($(CONFIG_FB_MSM_MDSS),y)
+obj-y += mdss/
+else
 obj-y := msm_fb.o
 
 obj-$(CONFIG_FB_MSM_LOGO) += logo.o
 obj-$(CONFIG_FB_BACKLIGHT) += msm_fb_bl.o
 
 ifeq ($(CONFIG_FB_MSM_MDP_HW),y)
-
 # MDP
 obj-y += mdp.o
 
@@ -12,12 +14,6 @@
 
 ifeq ($(CONFIG_FB_MSM_MDP40),y)
 obj-y += mdp4_util.o
-obj-$(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT) += mdp4_video_enhance.o
-obj-$(CONFIG_FB_MSM_MIPI_MAGNA_OLED_VIDEO_QHD_PT) += mdp4_video_enhance.o
-obj-$(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) += mdp4_video_enhance.o
-obj-$(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT) += mdp4_video_enhance.o
-obj-$(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_WVGA_PT) += mdp4_video_enhance.o
-obj-$(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT) += mdp4_video_enhance.o
 obj-y += mdp4_hsic.o
 else
 obj-y += mdp_hw_init.o
@@ -64,6 +60,9 @@
 # LCDC
 obj-$(CONFIG_FB_MSM_LCDC) += lcdc.o
 
+# LVDS
+obj-$(CONFIG_FB_MSM_LVDS) += lvds.o
+
 # MDDI
 msm_mddi-objs := mddi.o mddihost.o mddihosti.o
 obj-$(CONFIG_FB_MSM_MDDI) += msm_mddi.o
@@ -81,8 +80,9 @@
 obj-$(CONFIG_FB_MSM_MIPI_DSI_NOVATEK) += mipi_novatek.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_ORISE) += mipi_orise.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_RENESAS) += mipi_renesas.o
-obj-$(CONFIG_FB_MSM_MIPI_DSI_SAMSUNG_OLED) += mipi_samsung_oled.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_TRULY) += mipi_truly.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_NT35510) += mipi_NT35510.o
+obj-$(CONFIG_FB_MSM_MIPI_DSI_NT35516) += mipi_truly_tft540960_1_e.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_SIMULATOR) += mipi_simulator.o
 
 # MIPI Bridge
@@ -119,39 +119,35 @@
 obj-$(CONFIG_FB_MSM_MDDI_QUICKVX) += mddi_quickvx.o
 endif
 
-# ESD Recovery
-obj-$(CONFIG_MIPI_SAMSUNG_ESD_REFRESH) += mipi_samsung_esd_refresh.o
-
 ifeq ($(CONFIG_FB_MSM_MIPI_PANEL_DETECT),y)
 obj-y += mipi_toshiba_video_wvga_pt.o mipi_toshiba_video_wsvga_pt.o mipi_toshiba_video_wuxga.o
 obj-y += mipi_novatek_video_qhd_pt.o mipi_novatek_cmd_qhd_pt.o
 obj-y += mipi_orise_video_720p_pt.o mipi_orise_cmd_720p_pt.o
 obj-y += mipi_renesas_video_fwvga_pt.o mipi_renesas_cmd_fwvga_pt.o
+obj-y += mipi_NT35510_video_wvga_pt.o mipi_NT35510_cmd_wvga_pt.o
+obj-y += mipi_truly_tft540960_1_e_video_qhd_pt.o mipi_truly_tft540960_1_e_cmd_qhd_pt.o
 obj-y += mipi_chimei_wxga_pt.o
+obj-y += mipi_chimei_wuxga.o
 obj-y += mipi_truly_video_wvga_pt.o
-obj-y += mipi_boeot_tft_video_wsvga_pt.o
-obj-y += mipi_samsung_tft_video_wxga_pt.o
 else
 obj-$(CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT) += mipi_toshiba_video_wvga_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT) += mipi_toshiba_video_wsvga_pt.o
-obj-$(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) += mipi_novatek_cmd_wvga_pt.o
-obj-$(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT) += mipi_novatek_boe_hydis_cmd_wvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WUXGA) += mipi_toshiba_video_wuxga.o
 obj-$(CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT) += mipi_novatek_video_qhd_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_ORISE_VIDEO_720P_PT) += mipi_orise_video_720p_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_ORISE_CMD_720P_PT) += mipi_orise_cmd_720p_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_QHD_PT) += mipi_novatek_cmd_qhd_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT) += mipi_renesas_video_fwvga_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT) += mipi_renesas_cmd_fwvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT) += mipi_renesas_video_fwvga_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT) += mipi_truly_video_wvga_pt.o
-obj-$(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT) += mipi_samsung_oled_cmd_qhd_pt.o smart_mtp_s6e39a0x02.o
-obj-$(CONFIG_FB_MSM_MIPI_MAGNA_OLED_VIDEO_QHD_PT) += mipi_magna_oled_video_qhd_pt.o smart_mtp_ea8960.o
-obj-$(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT) += mipi_samsung_oled_video_hd_pt.o smart_mtp_s6e8aa0x01.o
-obj-$(CONFIG_SAMSUNG_CMC624) += samsung_cmc624.o cmc624_sysfs.o
-obj-$(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_WVGA_PT) += mipi_samsung_oled_video_wvga_pt.o smart_mtp_s6e63m0.o
+obj-$(CONFIG_FB_MSM_MIPI_NT35510_CMD_WVGA_PT) += mipi_NT35510_cmd_wvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_NT35510_VIDEO_WVGA_PT) += mipi_NT35510_video_wvga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_NT35516_CMD_QHD_PT) += mipi_truly_tft540960_1_e_cmd_qhd_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_NT35516_VIDEO_QHD_PT) += mipi_truly_tft540960_1_e_video_qhd_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_SIMULATOR_VIDEO) += mipi_simulator_video.o
 obj-$(CONFIG_FB_MSM_MIPI_CHIMEI_WXGA) += mipi_chimei_wxga_pt.o
-obj-$(CONFIG_FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT) += mipi_boeot_tft_video_wsvga_pt.o
-obj-$(CONFIG_FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT) += mipi_samsung_tft_video_wxga_pt.o
+obj-$(CONFIG_FB_MSM_MIPI_CHIMEI_WUXGA) += mipi_chimei_wuxga.o
 endif
 
 obj-$(CONFIG_FB_MSM_LCDC_PANEL) += lcdc_panel.o
@@ -170,27 +166,33 @@
 obj-$(CONFIG_FB_MSM_LCDC_SAMSUNG_OLED_PT) += lcdc_samsung_oled_pt.o
 obj-$(CONFIG_FB_MSM_HDMI_ADV7520_PANEL) += adv7520.o
 obj-$(CONFIG_FB_MSM_LCDC_ST15_WXGA) += lcdc_st15.o
+obj-$(CONFIG_FB_MSM_LVDS_CHIMEI_WXGA) += lvds_chimei_wxga.o
+obj-$(CONFIG_FB_MSM_LVDS_FRC_FHD) += lvds_frc_fhd.o
 obj-$(CONFIG_FB_MSM_HDMI_MSM_PANEL) += hdmi_msm.o
 obj-$(CONFIG_FB_MSM_EXT_INTERFACE_COMMON) += external_common.o
+obj-$(CONFIG_FB_MSM_LCDC_TRULY_HVGA_IPS3P2335) += lcdc_truly_ips3p2335.o
 
 obj-$(CONFIG_FB_MSM_TVOUT) += tvout_msm.o
 
+ccflags-y := -I$(src)/mhl
+obj-$(CONFIG_FB_MSM_HDMI_MHL_8334) += mhl-8334.o
+mhl-8334-objs  += mhl/mhl_8334.o
+mhl-8334-objs  += mhl/mhl_i2c_utils.o
+
 obj-$(CONFIG_FB_MSM_EXTMDDI_SVGA) += mddi_ext_lcd.o
 
 obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += mdp4_wfd_writeback_panel.o
 obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += mdp4_wfd_writeback.o
 obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += mdp4_overlay_writeback.o
-
-obj-$(CONFIG_MSM_VIDC_1080P) += vidc/
-obj-$(CONFIG_MSM_VIDC_720P) += vidc/
-obj-$(CONFIG_VIDEO_MHL_V1) += mhl_v1/
-obj-$(CONFIG_VIDEO_MHL_V2) += mhl_v2/
 else
 obj-$(CONFIG_FB_MSM_EBI2) += ebi2_host.o
 obj-$(CONFIG_FB_MSM_EBI2) += ebi2_lcd.o
 obj-y += msm_fb_panel.o
 obj-$(CONFIG_FB_MSM_EBI2_EPSON_S1D_QVGA_PANEL) += ebi2_epson_s1d_qvga.o
 endif
+endif
 
+obj-$(CONFIG_MSM_VIDC_1080P) += vidc/
+obj-$(CONFIG_MSM_VIDC_720P) += vidc/
 clean:
 	rm *.o .*cmd
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mddi_client_nt35399.c msm/mddi_client_nt35399.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mddi_client_nt35399.c	2012-07-16 10:04:32.202489771 -0700
+++ msm/mddi_client_nt35399.c	2012-08-14 12:32:39.489339484 -0700
@@ -154,14 +154,10 @@
 		ret = 0;
 		goto uninit;
 	}
-	ret = gpio_request(gpio, "vsync");
+	ret = gpio_request_one(gpio, GPIOF_IN, "vsync");
 	if (ret)
 		goto err_request_gpio_failed;
 
-	ret = gpio_direction_input(gpio);
-	if (ret)
-		goto err_gpio_direction_input_failed;
-
 	ret = irq = gpio_to_irq(gpio);
 	if (ret < 0)
 		goto err_get_irq_num_failed;
@@ -179,7 +175,6 @@
 	free_irq(gpio_to_irq(gpio), panel->client_data);
 err_request_irq_failed:
 err_get_irq_num_failed:
-err_gpio_direction_input_failed:
 	gpio_free(gpio);
 err_request_gpio_failed:
 	return ret;
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_dtv.c msm/mdp4_dtv.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_dtv.c	2012-08-08 09:32:42.784525957 -0700
+++ msm/mdp4_dtv.c	2012-08-14 12:32:39.515339482 -0700
@@ -137,19 +137,24 @@
 		clk_prepare_enable(ebi1_clk);
 	}
 #endif
+
+	if (dtv_pdata && dtv_pdata->lcdc_power_save)
+		dtv_pdata->lcdc_power_save(1);
+	if (dtv_pdata && dtv_pdata->lcdc_gpio_config)
+		ret = dtv_pdata->lcdc_gpio_config(1);
+
 	mfd = platform_get_drvdata(pdev);
 
 	ret = clk_set_rate(tv_src_clk, mfd->fbi->var.pixclock);
 	if (ret) {
 		pr_info("%s: clk_set_rate(%d) failed\n", __func__,
 			mfd->fbi->var.pixclock);
-		if (mfd->fbi->var.pixclock == 27027000)
+		if (mfd->fbi->var.pixclock == 27030000)
 			mfd->fbi->var.pixclock = 27000000;
 		ret = clk_set_rate(tv_src_clk, mfd->fbi->var.pixclock);
 	}
 	pr_info("%s: tv_src_clk=%dkHz, pm_qos_rate=%ldkHz, [%d]\n", __func__,
 		mfd->fbi->var.pixclock/1000, pm_qos_rate, ret);
-
 	mfd->panel_info.clk_rate = mfd->fbi->var.pixclock;
 	clk_prepare_enable(hdmi_clk);
 	clk_reset(hdmi_clk, CLK_RESET_ASSERT);
@@ -159,11 +164,6 @@
 	if (mdp_tv_clk)
 		clk_prepare_enable(mdp_tv_clk);
 
-	if (dtv_pdata && dtv_pdata->lcdc_power_save)
-		dtv_pdata->lcdc_power_save(1);
-	if (dtv_pdata && dtv_pdata->lcdc_gpio_config)
-		ret = dtv_pdata->lcdc_gpio_config(1);
-
 	ret = panel_next_on(pdev);
 	return ret;
 }
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4.h msm/mdp4.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4.h	2012-08-13 16:39:47.801233556 -0700
+++ msm/mdp4.h	2012-08-14 12:32:48.899338839 -0700
@@ -25,8 +25,8 @@
 extern spinlock_t mdp_spin_lock;
 extern struct mdp4_statistic mdp4_stat;
 extern uint32 mdp4_extn_disp;
+extern char *mmss_cc_base;	/* mutimedia sub system clock control */
 extern spinlock_t dsi_clk_lock;
-extern u32 mdp_max_clk;
 
 #define MDP4_OVERLAYPROC0_BASE	0x10000
 #define MDP4_OVERLAYPROC1_BASE	0x18000
@@ -41,14 +41,7 @@
 /* chip select controller */
 #define CS_CONTROLLER_0 0x0707ffff
 #define CS_CONTROLLER_1 0x03073f3f
-#if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT)
-extern int is_lcd_connected ;
-#endif
-#if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT)
-#define FACTORY_TEST
-#endif
+
 enum {
 	OVERLAY_PERF_LEVEL1 = 1,
 	OVERLAY_PERF_LEVEL2,
@@ -56,12 +49,6 @@
 	OVERLAY_PERF_LEVEL4
 };
 
-enum mdp4_overlay_status {
-	MDP4_OVERLAY_TYPE_UNSET,
-	MDP4_OVERLAY_TYPE_SET,
-	MDP4_OVERLAY_TYPE_MAX
-};
-
 typedef int (*cmd_fxn_t)(struct platform_device *pdev);
 
 enum {		/* display */
@@ -372,8 +359,6 @@
 	uint32 blt_ov_done;
 	uint32 blt_dmap_koff;
 	uint32 blt_dmap_done;
-	uint32 req_clk;
-	uint32 req_bw;
 	uint32 luma_align_size;
 	struct mdp4_hsic_regs hsic_regs;
 	struct mdp_overlay req_data;
@@ -623,6 +608,9 @@
 void mdp4_lcdc_wait4vsync(int cndx, long long *vtime);
 void mdp4_overlay_lcdc_vsync_push(struct msm_fb_data_type *mfd,
 				struct mdp4_overlay_pipe *pipe);
+void mdp4_overlay_dtv_set_perf(struct msm_fb_data_type *mfd);
+void mdp4_update_perf_level(u32 perf_level);
+void mdp4_set_perf_level(void);
 void mdp4_mddi_overlay_dmas_restore(void);
 
 #ifndef CONFIG_FB_MSM_MIPI_DSI
@@ -674,16 +662,6 @@
 void mdp4_fetch_cfg(uint32 clk);
 uint32 mdp4_rgb_igc_lut_cvt(uint32 ndx);
 void mdp4_vg_qseed_init(int);
-#if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_MAGNA_OLED_VIDEO_QHD_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_MAGNA_OLED_VIDEO_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT)
-void mdp4_vg_qseed_init_DMB(int vg_num);
-void mdp4_vg_qseed_init_VideoPlay(int vg_num);
-#endif
 int mdp4_overlay_blt(struct fb_info *info, struct msmfb_overlay_blt *req);
 
 #ifdef CONFIG_FB_MSM_MIPI_DSI
@@ -872,7 +850,6 @@
 
 int mdp4_mixer_info(int mixer_num, struct mdp_mixer_info *info);
 
-void mipi_dsi_mdp_busy_wait(struct msm_fb_data_type *mfd);
 void mdp_dmap_vsync_set(int enable);
 int mdp_dmap_vsync_get(void);
 void mdp_hw_cursor_done(void);
@@ -899,7 +876,6 @@
 		struct mdp4_overlay_pipe *pipe);
 void mdp4_writeback_dma_busy_wait(struct msm_fb_data_type *mfd);
 void mdp4_overlay1_done_writeback(struct mdp_dma_data *dma);
-void mdp4_dma_e_done_dtv(void);
 
 int mdp4_writeback_start(struct fb_info *info);
 int mdp4_writeback_stop(struct fb_info *info);
@@ -925,24 +901,6 @@
 u32  mdp4_allocate_writeback_buf(struct msm_fb_data_type *mfd, u32 mix_num);
 void mdp4_init_writeback_buf(struct msm_fb_data_type *mfd, u32 mix_num);
 void mdp4_free_writeback_buf(struct msm_fb_data_type *mfd, u32 mix_num);
-#if defined(CONFIG_MIPI_SAMSUNG_ESD_REFRESH)
-void set_esd_disable(void);
-void set_esd_enable(void);
-#endif
-
-extern int play_speed_1_5;
-#if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT)
-extern boolean camera_mode;
-#endif
-
-#if defined(CONFIG_SAMSUNG_CMC624)
-extern boolean video_mode;
-void cmc_timing_generator_reset(void) ;
-void mipi_samsung_oled_display_fast_init(void);
-void pull_ldi_reset_down(void);
-void pull_ldi_reset_up(void);
-bool samsung_has_cmc624(void);
-#endif
 
 int mdp4_igc_lut_config(struct mdp_igc_lut_data *cfg);
 void mdp4_overlay_iommu_pipe_free(int ndx, int all);
@@ -958,9 +916,4 @@
 	unsigned long srcp0_addr, unsigned long srcp1_addr,
 	unsigned long srcp2_addr);
 
-int mdp4_overlay_mdp_pipe_req(struct mdp4_overlay_pipe *pipe,
-			      struct msm_fb_data_type *mfd);
-int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd,
-			      struct mdp4_overlay_pipe *plist);
-void mdp4_overlay_mdp_perf_upd(struct msm_fb_data_type *mfd, int flag);
 #endif /* MDP_H */
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_atv.c msm/mdp4_overlay_atv.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_atv.c	2012-08-13 16:39:47.802233556 -0700
+++ msm/mdp4_overlay_atv.c	2012-08-14 12:32:48.900338838 -0700
@@ -110,6 +110,7 @@
 
 	mdp4_overlay_dmae_xy(pipe);	/* dma_e */
 	mdp4_overlay_dmae_cfg(mfd, 1);
+
 	mdp4_overlay_rgb_setup(pipe);
 
 	mdp4_overlayproc_cfg(pipe);
@@ -182,8 +183,6 @@
 	} else {
 		pipe->srcp0_addr = (uint32)(buf + buf_offset);
 	}
-	mdp4_overlay_mdp_perf_req(pipe, mfd);
-	mdp4_overlay_mdp_perf_upd(mfd, 1);
 	mdp4_overlay_rgb_setup(pipe);
 	mdp4_overlay_reg_flush(pipe, 0);
 	mdp4_mixer_stage_up(pipe);
@@ -202,7 +201,10 @@
 	spin_unlock_irqrestore(&mdp_spin_lock, flag);
 	wait_for_completion_killable(&atv_pipe->comp);
 	mdp_disable_irq(MDP_OVERLAY1_TERM);
-	mdp4_overlay_mdp_perf_upd(mfd, 0);
+
+	/* change mdp clk while mdp is idle` */
+	mdp4_set_perf_level();
+
 	mdp4_stat.kickoff_atv++;
 	mutex_unlock(&mfd->dma->ov_mutex);
 }
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay.c msm/mdp4_overlay.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay.c	2012-08-14 12:32:14.106341219 -0700
+++ msm/mdp4_overlay.c	2012-08-14 12:32:48.900338838 -0700
@@ -104,21 +104,7 @@
 
 static DEFINE_MUTEX(iommu_mutex);
 static struct mdp4_overlay_ctrl *ctrl = &mdp4_overlay_db;
-
-struct mdp4_overlay_perf {
-	u32 mdp_clk_rate;
-	u32 use_ov0_blt;
-	u32 use_ov1_blt;
-	u32 mdp_bw;
-};
-
-struct mdp4_overlay_perf perf_request = {
-	.mdp_bw = OVERLAY_PERF_LEVEL4,
-};
-struct mdp4_overlay_perf perf_current = {
-	.mdp_bw = OVERLAY_PERF_LEVEL4,
-};
-
+static int new_perf_level;
 static struct ion_client *display_iclient;
 
 
@@ -213,34 +199,24 @@
 	struct ion_handle **srcp_ihdl)
 {
 	struct mdp4_iommu_pipe_info *iom;
-	unsigned long size = 0;
-	int ret;
 
 	if (!display_iclient)
 		return -EINVAL;
 
-	*srcp_ihdl = ion_import_fd(display_iclient, mem_id);
+	*srcp_ihdl = ion_import_dma_buf(display_iclient, mem_id);
 	if (IS_ERR_OR_NULL(*srcp_ihdl)) {
 		pr_err("ion_import_dma_buf() failed\n");
 		return PTR_ERR(*srcp_ihdl);
 	}
-
-	ret = ion_handle_get_size(display_iclient, *srcp_ihdl, &size);
-	if (ret)
-		pr_err("ion_handle_get_size failed with ret %d\n", ret);
-	else
-		size *= 2;
-
-	pr_debug("%s(): ion_hdl %p, size 0x%lx\n", __func__,
-		*srcp_ihdl, size);
+	pr_debug("%s(): ion_hdl %p, ion_buf %d\n", __func__, *srcp_ihdl,
+		ion_share_dma_buf(display_iclient, *srcp_ihdl));
 	pr_debug("mixer %u, pipe %u, plane %u\n", pipe->mixer_num,
 		pipe->pipe_ndx, plane);
 	if (ion_map_iommu(display_iclient, *srcp_ihdl,
-		DISPLAY_READ_DOMAIN, GEN_POOL, SZ_4K, size, start,
+		DISPLAY_READ_DOMAIN, GEN_POOL, SZ_4K, 0, start,
 		len, 0, ION_IOMMU_UNMAP_DELAYED)) {
 		ion_free(display_iclient, *srcp_ihdl);
-		pr_err("%s(): ion_map_iommu() failed\n",
-			__func__);
+		pr_err("ion_map_iommu() failed\n");
 		return -EINVAL;
 	}
 
@@ -397,12 +373,7 @@
 		MDP_OUTP(MDP_BASE + 0xb3014, 0x1000080);
 		MDP_OUTP(MDP_BASE + 0xb4004, 0x67686970);
 	} else {
-#ifdef CONFIG_FB_MSM_EXT_INTERFACE_COMMON
 		mdp_vid_quant_set();
-#endif
-		MDP_OUTP(MDP_BASE + 0xb0070, 0xff0000);
-		MDP_OUTP(MDP_BASE + 0xb0074, 0xff0000);
-		MDP_OUTP(MDP_BASE + 0xb0078, 0xff0000);
 	}
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
@@ -451,7 +422,6 @@
 	* MDP_OVERLAY_REG_FLUSH
 	*/
 	MDP_OUTP(MDP_BASE + 0x18000, BIT(3));
-
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 	return;
 }
@@ -1867,13 +1837,7 @@
 		op_mode &= ~(MDP4_OP_FLIP_UD + MDP4_OP_SCALEY_EN);
 		outpdw(base + 0x0058, op_mode);
 		outpdw(base + 0x1008, 0);	/* black */
-		/*
-		 * Set src size and dst size same to avoid underruns
-		 */
-		outpdw(base + 0x0000, inpdw(base + 0x0008));
 	} else {
-		u32 src_size = ((pipe->src_h << 16) | pipe->src_w);
-		outpdw(base + 0x0000, src_size);
 		format &= ~MDP4_FORMAT_SOLID_FILL;
 		blend->solidfill_pipe = NULL;
 	}
@@ -2131,6 +2095,79 @@
 
 }
 
+static int mdp4_overlay_validate_downscale(struct mdp_overlay *req,
+	struct msm_fb_data_type *mfd, uint32 perf_level, uint32 pclk_rate)
+{
+	__u32 panel_clk_khz, mdp_clk_khz;
+	__u32 num_hsync_pix_clks, mdp_clks_per_hsync, src_wh;
+	__u32 hsync_period_ps, mdp_period_ps, total_hsync_period_ps;
+	unsigned long fill_rate_y_dir, fill_rate_x_dir;
+	unsigned long fillratex100, mdp_pixels_produced;
+	unsigned long mdp_clk_hz;
+
+	pr_debug("%s: LCDC Mode Downscale validation with MDP Core"
+		" Clk rate\n", __func__);
+	pr_debug("src_w %u, src_h %u, dst_w %u, dst_h %u\n",
+		req->src_rect.w, req->src_rect.h, req->dst_rect.w,
+		req->dst_rect.h);
+
+
+	panel_clk_khz = pclk_rate/1000;
+	mdp_clk_hz = mdp_perf_level2clk_rate(perf_level);
+
+	if (!mdp_clk_hz || !req->dst_rect.w || !req->dst_rect.h) {
+		pr_debug("mdp_perf_level2clk_rate returned 0,"
+			 "or dst_rect height/width is 0,"
+			 "Downscale Validation incomplete\n");
+		return 0;
+	}
+
+	mdp_clk_khz = mdp_clk_hz/1000;
+
+	num_hsync_pix_clks = mfd->panel_info.lcdc.h_back_porch +
+		mfd->panel_info.lcdc.h_front_porch +
+		mfd->panel_info.lcdc.h_pulse_width +
+		mfd->panel_info.xres;
+
+	hsync_period_ps = 1000000000/panel_clk_khz;
+	mdp_period_ps = 1000000000/mdp_clk_khz;
+
+	total_hsync_period_ps = num_hsync_pix_clks * hsync_period_ps;
+	mdp_clks_per_hsync = total_hsync_period_ps/mdp_period_ps;
+
+	pr_debug("hsync_period_ps %u, mdp_period_ps %u,"
+		"total_hsync_period_ps %u\n", hsync_period_ps,
+		mdp_period_ps, total_hsync_period_ps);
+
+	src_wh = req->src_rect.w * req->src_rect.h;
+	if (src_wh % req->dst_rect.h)
+		fill_rate_y_dir = (src_wh / req->dst_rect.h) + 1;
+	else
+		fill_rate_y_dir = (src_wh / req->dst_rect.h);
+
+	fill_rate_x_dir = (mfd->panel_info.xres - req->dst_rect.w)
+		+ req->src_rect.w;
+
+	if (fill_rate_y_dir >= fill_rate_x_dir)
+		fillratex100 = 100 * fill_rate_y_dir / mfd->panel_info.xres;
+	else
+		fillratex100 = 100 * fill_rate_x_dir / mfd->panel_info.xres;
+
+	pr_debug("mdp_clks_per_hsync %u, fill_rate_y_dir %lu,"
+		"fill_rate_x_dir %lu\n", mdp_clks_per_hsync,
+		fill_rate_y_dir, fill_rate_x_dir);
+
+	mdp_pixels_produced = 100 * mdp_clks_per_hsync/fillratex100;
+	pr_debug("fillratex100 %lu, mdp_pixels_produced %lu\n",
+		fillratex100, mdp_pixels_produced);
+	if (mdp_pixels_produced <= mfd->panel_info.xres) {
+		mdp4_stat.err_underflow++;
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
 static int mdp4_overlay_req2pipe(struct mdp_overlay *req, int mixer,
 			struct mdp4_overlay_pipe **ppipe,
 			struct msm_fb_data_type *mfd)
@@ -2372,451 +2409,11 @@
 
 	pipe->transp = req->transp_mask;
 
-	pipe->flags = req->flags;
-
 	*ppipe = pipe;
 
 	return 0;
 }
 
-static int mdp4_calc_pipe_mdp_clk(struct msm_fb_data_type *mfd,
-				  struct mdp4_overlay_pipe *pipe)
-{
-	u32 pclk;
-	u32 xscale, yscale;
-	u32 hsync = 0;
-	u32 shift = 16;
-	u64 rst;
-	int ret = -EINVAL;
-
-	if (!pipe) {
-		pr_err("%s: pipe is null!\n", __func__);
-		pipe->req_bw = OVERLAY_PERF_LEVEL4;
-		return ret;
-	}
-	if (!mfd) {
-		pr_err("%s: mfd is null!\n", __func__);
-		pipe->req_bw = OVERLAY_PERF_LEVEL4;
-		return ret;
-	}
-
-	/*
-	 * Serveral special cases require the max mdp clk but cannot
-	 * be explained by mdp clk equation.
-	 */
-	if (pipe->flags & MDP_DEINTERLACE) {
-		pr_info("%s deinterlace requires max mdp clk.\n",
-			__func__);
-		pipe->req_clk = mdp_max_clk;
-		return 0;
-	}
-
-	pr_debug("%s: pipe sets: panel res(x,y)=(%d,%d)\n",
-		 __func__,  mfd->panel_info.xres, mfd->panel_info.yres);
-	pr_debug("%s: src(w,h)(%d,%d),src(x,y)(%d,%d)\n",
-		 __func__,  pipe->src_w, pipe->src_h, pipe->src_x, pipe->src_y);
-	pr_debug("%s: dst(w,h)(%d,%d),dst(x,y)(%d,%d)\n",
-		 __func__, pipe->dst_w, pipe->dst_h, pipe->dst_x, pipe->dst_y);
-
-	pclk = (mfd->panel_info.type == MIPI_VIDEO_PANEL ||
-		mfd->panel_info.type == MIPI_CMD_PANEL) ?
-		mfd->panel_info.mipi.dsi_pclk_rate :
-		mfd->panel_info.clk_rate;
-	if (!pclk) {
-		pipe->req_clk = mdp_max_clk;
-		pr_err("%s panel pixel clk is zero!\n", __func__);
-		return ret;
-	}
-	pr_debug("%s: mdp panel pixel clk is %d.\n",
-		 __func__, pclk);
-
-	if (!pipe->dst_h) {
-		pr_err("%s: pipe dst_h is zero!\n", __func__);
-		pipe->req_clk = mdp_max_clk;
-		return ret;
-	}
-
-	if (!pipe->src_h) {
-		pr_err("%s: pipe src_h is zero!\n", __func__);
-		pipe->req_clk = mdp_max_clk;
-		return ret;
-	}
-
-	if (!pipe->dst_w) {
-		pr_err("%s: pipe dst_w is zero!\n", __func__);
-		pipe->req_clk = mdp_max_clk;
-		return ret;
-	}
-
-	if (!pipe->dst_h) {
-		pr_err("%s: pipe dst_h is zero!\n", __func__);
-		pipe->req_clk = mdp_max_clk;
-		return ret;
-	}
-
-	/*
-	 * For the scaling cases, make more margin by removing porch
-	 * values and adding extra 20%.
-	 */
-	if ((pipe->src_h != pipe->dst_h) ||
-	    (pipe->src_w != pipe->dst_w)) {
-		hsync = mfd->panel_info.xres;
-		hsync *= 100;
-		hsync /= 120;
-		pr_debug("%s: panel hsync is %d. with scaling\n",
-			__func__, hsync);
-
-	} else {
-		hsync = mfd->panel_info.lcdc.h_back_porch +
-			mfd->panel_info.lcdc.h_front_porch +
-			mfd->panel_info.lcdc.h_pulse_width +
-			mfd->panel_info.xres;
-		pr_debug("%s: panel hsync is %d.\n",
-			__func__, hsync);
-	}
-
-	if (!hsync) {
-		pipe->req_clk = mdp_max_clk;
-		pr_err("%s: panel hsync is zero!\n", __func__);
-		return 0;
-	}
-
-	xscale = mfd->panel_info.xres;
-	xscale += pipe->src_w;
-
-	if (xscale < pipe->dst_w) {
-		pipe->req_clk = mdp_max_clk;
-		pr_err("%s: xres+src_w cannot be less than dst_w!\n",
-		       __func__);
-		return ret;
-	}
-
-	xscale -= pipe->dst_w;
-	xscale <<= shift;
-	xscale /= hsync;
-	pr_debug("%s: the right %d shifted xscale is %d.\n",
-		 __func__, shift, xscale);
-
-	if (pipe->src_h > pipe->dst_h) {
-		yscale = pipe->src_h;
-		yscale <<= shift;
-		yscale /= pipe->dst_h;
-	} else {		/* upscale */
-		yscale = pipe->dst_h;
-		yscale <<= shift;
-		yscale /= pipe->src_h;
-	}
-
-	yscale *= pipe->src_w;
-	yscale /= hsync;
-
-	pr_debug("%s: the right %d shifted yscale is %d.\n",
-		 __func__, shift, yscale);
-
-	rst = pclk;
-	if (yscale > xscale)
-		rst *= yscale;
-	else
-		rst *= xscale;
-
-	rst >>= shift;
-
-	/*
-	 * If the calculated mdp clk is less than panel pixel clk,
-	 * most likely due to upscaling, mdp clk rate will be set to
-	 * greater than pclk. Now the driver uses 1.15 as the
-	 * factor. Ideally this factor is passed from board file.
-	 */
-	if (rst < pclk) {
-		rst = ((pclk >> shift) * 23 / 20) << shift;
-		pr_debug("%s calculated mdp clk is less than pclk.\n",
-			__func__);
-	}
-
-	pipe->req_clk = (u32) rst;
-
-	pr_debug("%s: required mdp clk %d mixer %d pipe ndx %d\n",
-		 __func__, pipe->req_clk, pipe->mixer_num, pipe->pipe_ndx);
-
-	return 0;
-}
-
-#define OVERLAY_VGA_SIZE	0x04B000
-#define OVERLAY_720P_TILE_SIZE  0x0E6000
-#define OVERLAY_WSVGA_SIZE 0x98000 /* 1024x608, align 600 to 32bit */
-
-#define OVERLAY_BUS_SCALE_TABLE_BASE	6
-
-
-static int mdp4_calc_pipe_mdp_bw(struct msm_fb_data_type *mfd,
-			  struct mdp4_overlay_pipe *pipe)
-{
-	u32 res;
-	int ret = -EINVAL;
-
-	if (!pipe) {
-		pr_err("%s: pipe is null!\n", __func__);
-		return ret;
-	}
-	if (!mfd) {
-		pr_err("%s: mfd is null!\n", __func__);
-		return ret;
-	}
-
-	if (pipe->flags & MDP_DEINTERLACE) {
-		pr_info("%s deinterlace requires max mdp bw.\n",
-			__func__);
-		pipe->req_bw = OVERLAY_PERF_LEVEL1;
-		return 0;
-	}
-
-	if (pipe->pipe_type == OVERLAY_TYPE_BF) {
-		pipe->req_bw = OVERLAY_PERF_LEVEL4;
-		return 0;
-	}
-
-	res = pipe->src_w * pipe->src_h;
-
-	if (res <= OVERLAY_WSVGA_SIZE)
-		pipe->req_bw = OVERLAY_PERF_LEVEL4;
-	else if (res <= OVERLAY_VGA_SIZE)
-		pipe->req_bw = OVERLAY_PERF_LEVEL3;
-	else if (res <= OVERLAY_720P_TILE_SIZE)
-		pipe->req_bw = OVERLAY_PERF_LEVEL2;
-	else
-		pipe->req_bw = OVERLAY_PERF_LEVEL1;
-
-	return 0;
-}
-
-int mdp4_overlay_mdp_perf_req(struct msm_fb_data_type *mfd,
-			      struct mdp4_overlay_pipe *plist)
-{
-	u32 worst_mdp_clk = 0;
-	u32 worst_mdp_bw = OVERLAY_PERF_LEVEL4;
-	int i;
-	struct mdp4_overlay_perf *perf_req = &perf_request;
-	struct mdp4_overlay_pipe *pipe = plist;
-	u32 cnt = 0;
-	int ret = -EINVAL;
-
-	if (!mfd) {
-		pr_err("%s: mfd is null!\n", __func__);
-		return ret;
-	}
-
-	if (!plist) {
-		pr_err("%s: plist is null!\n", __func__);
-		return ret;
-	}
-
-	perf_req->use_ov0_blt = 0;
-	perf_req->use_ov1_blt = 0;
-
-	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
-
-		if (!pipe)
-			return ret;
-
-		if (!pipe->pipe_used)
-			continue;
-		cnt++;
-		if (worst_mdp_clk < pipe->req_clk)
-			worst_mdp_clk = pipe->req_clk;
-		if (pipe->req_clk > mdp_max_clk) {
-			if (pipe->mixer_num == MDP4_MIXER0)
-				perf_req->use_ov0_blt = 1;
-			if (pipe->mixer_num == MDP4_MIXER1)
-				perf_req->use_ov1_blt = 1;
-		}
-
-		if (!pipe->req_bw) {
-			pr_err("%s mdp pipe bw request should not be zero!\n",
-			       __func__);
-			pr_debug("%s %d pid %d num %d idx %d mix %d bw %d\n",
-				 __func__, __LINE__, current->pid,
-				 pipe->pipe_num, pipe->pipe_ndx,
-				 pipe->mixer_num, pipe->req_bw);
-			pipe->req_bw = OVERLAY_PERF_LEVEL4;
-		}
-
-		if (pipe->req_bw < worst_mdp_bw)
-			worst_mdp_bw = pipe->req_bw;
-
-		if (mfd->mdp_rev == MDP_REV_41) {
-			/*
-			 * writeback (blt) mode to provide work around
-			 * for dsi cmd mode interface hardware bug.
-			 */
-			if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD) {
-				if (pipe->dst_x != 0)
-					perf_req->use_ov0_blt = 1;
-			}
-			if ((mfd->panel_info.xres > 1280) &&
-			    (mfd->panel_info.type != DTV_PANEL)) {
-				perf_req->use_ov0_blt = 1;
-			}
-		}
-	}
-
-	perf_req->mdp_clk_rate = worst_mdp_clk;
-	if (perf_req->mdp_clk_rate > mdp_max_clk)
-		perf_req->mdp_clk_rate = mdp_max_clk;
-
-	perf_req->mdp_clk_rate = mdp_clk_round_rate(perf_req->mdp_clk_rate);
-
-	perf_req->mdp_bw = worst_mdp_bw;
-
-	if (cnt >= 3)
-		perf_req->mdp_bw = OVERLAY_PERF_LEVEL1;
-
-	pr_debug("%s %d pid %d cnt %d clk %d ov0_blt %d, ov1_blt %d bw %d\n",
-		 __func__, __LINE__, current->pid, cnt,
-		 perf_req->mdp_clk_rate,
-		 perf_req->use_ov0_blt,
-		 perf_req->use_ov1_blt,
-		 perf_req->mdp_bw);
-
-	return 0;
-}
-
-int mdp4_overlay_mdp_pipe_req(struct mdp4_overlay_pipe *pipe,
-				  struct msm_fb_data_type *mfd)
-{
-	int ret = 0;
-
-	if (mdp4_calc_pipe_mdp_clk(mfd, pipe)) {
-		pr_err("%s unable to calc mdp pipe clk rate ret=%d\n",
-		       __func__, ret);
-		ret = -EINVAL;
-	}
-	if (mdp4_calc_pipe_mdp_bw(mfd, pipe)) {
-		pr_err("%s unable to calc mdp pipe bandwidth ret=%d\n",
-		       __func__, ret);
-		ret = -EINVAL;
-	}
-	return ret;
-}
-
-void mdp4_overlay_mdp_perf_upd(struct msm_fb_data_type *mfd,
-				  int flag)
-{
-	struct mdp4_overlay_perf *perf_req = &perf_request;
-	struct mdp4_overlay_perf *perf_cur = &perf_current;
-
-	pr_debug("%s %d: req mdp clk %d, cur mdp clk %d flag %d\n",
-		 __func__, __LINE__,
-		 perf_req->mdp_clk_rate,
-		 perf_cur->mdp_clk_rate,
-		 flag);
-
-	if (!mdp4_extn_disp)
-		perf_cur->use_ov1_blt = 0;
-
-	if (flag) {
-		if (perf_req->mdp_clk_rate > perf_cur->mdp_clk_rate) {
-			mdp_set_core_clk(perf_req->mdp_clk_rate);
-			pr_info("%s mdp clk is changed [%d] from %d to %d\n",
-				__func__,
-				flag,
-				perf_cur->mdp_clk_rate,
-				perf_req->mdp_clk_rate);
-			perf_cur->mdp_clk_rate =
-				perf_req->mdp_clk_rate;
-		}
-		if (perf_req->mdp_bw < perf_cur->mdp_bw) {
-			mdp_bus_scale_update_request
-				(OVERLAY_BUS_SCALE_TABLE_BASE -
-				 perf_req->mdp_bw);
-			pr_info("%s mdp bw is changed [%d] from %d to %d\n",
-				__func__,
-				flag,
-				perf_cur->mdp_bw,
-				perf_req->mdp_bw);
-			perf_cur->mdp_bw = perf_req->mdp_bw;
-		}
-		if (mfd->panel_info.pdest == DISPLAY_1 &&
-		    perf_req->use_ov0_blt && !perf_cur->use_ov0_blt) {
-			mdp4_allocate_writeback_buf(mfd, MDP4_MIXER0);
-			if (mfd->panel_info.type == LCDC_PANEL ||
-			    mfd->panel_info.type == LVDS_PANEL)
-				mdp4_lcdc_overlay_blt_start(mfd);
-			else if (mfd->panel_info.type == MIPI_VIDEO_PANEL)
-				mdp4_dsi_video_blt_start(mfd);
-			else if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD)
-				mdp4_dsi_cmd_blt_start(mfd);
-			pr_info("%s mixer0 start blt [%d] from %d to %d.\n",
-				__func__,
-				flag,
-				perf_cur->use_ov0_blt,
-				perf_req->use_ov0_blt);
-			perf_cur->use_ov0_blt = perf_req->use_ov0_blt;
-		}
-		if (mfd->panel_info.pdest == DISPLAY_2 &&
-		    perf_req->use_ov1_blt && !perf_cur->use_ov1_blt) {
-			mdp4_allocate_writeback_buf(mfd, MDP4_MIXER1);
-			mdp4_dtv_overlay_blt_start(mfd);
-			pr_info("%s mixer1 start blt [%d] from %d to %d.\n",
-				__func__,
-				flag,
-				perf_cur->use_ov1_blt,
-				perf_req->use_ov1_blt);
-			perf_cur->use_ov1_blt = perf_req->use_ov1_blt;
-		}
-	} else {
-		if (perf_req->mdp_clk_rate < perf_cur->mdp_clk_rate) {
-			pr_info("%s mdp clk is changed [%d] from %d to %d\n",
-				__func__,
-				flag,
-				perf_cur->mdp_clk_rate,
-				perf_req->mdp_clk_rate);
-			mdp_set_core_clk(perf_req->mdp_clk_rate);
-			perf_cur->mdp_clk_rate =
-				perf_req->mdp_clk_rate;
-		}
-		if (perf_req->mdp_bw > perf_cur->mdp_bw) {
-			pr_info("%s mdp bw is changed [%d] from %d to %d\n",
-				__func__,
-				flag,
-				perf_cur->mdp_bw,
-				perf_req->mdp_bw);
-			mdp_bus_scale_update_request
-				(OVERLAY_BUS_SCALE_TABLE_BASE -
-				 perf_req->mdp_bw);
-			perf_cur->mdp_bw = perf_req->mdp_bw;
-		}
-		if (mfd->panel_info.pdest == DISPLAY_1 &&
-		    !perf_req->use_ov0_blt && perf_cur->use_ov0_blt) {
-			if (mfd->panel_info.type == LCDC_PANEL ||
-			    mfd->panel_info.type == LVDS_PANEL)
-				mdp4_lcdc_overlay_blt_stop(mfd);
-			else if (mfd->panel_info.type == MIPI_VIDEO_PANEL)
-				mdp4_dsi_video_blt_stop(mfd);
-			else if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD)
-				mdp4_dsi_cmd_blt_stop(mfd);
-			mdp4_free_writeback_buf(mfd, MDP4_MIXER0);
-			pr_info("%s mixer0 stop blt [%d] from %d to %d.\n",
-				__func__,
-				flag,
-				perf_cur->use_ov0_blt,
-				perf_req->use_ov0_blt);
-			perf_cur->use_ov0_blt = perf_req->use_ov0_blt;
-		}
-		if (mfd->panel_info.pdest == DISPLAY_2 &&
-		    !perf_req->use_ov1_blt && perf_cur->use_ov1_blt) {
-			mdp4_dtv_overlay_blt_stop(mfd);
-			mdp4_free_writeback_buf(mfd, MDP4_MIXER1);
-			pr_info("%s mixer1 stop blt [%d] from %d to %d.\n",
-				__func__,
-				flag,
-				perf_cur->use_ov1_blt,
-				perf_req->use_ov1_blt);
-			perf_cur->use_ov1_blt = perf_req->use_ov1_blt;
-		}
-	}
-	return;
-}
-
 static int get_img(struct msmfb_data *img, struct fb_info *info,
 	struct mdp4_overlay_pipe *pipe, unsigned int plane,
 	unsigned long *start, unsigned long *len, struct file **srcp_file,
@@ -2939,12 +2536,153 @@
 	return 0;
 }
 
+#define OVERLAY_VGA_SIZE	0x04B000
+#define OVERLAY_720P_TILE_SIZE  0x0E6000
+#define OVERLAY_WSVGA_SIZE 0x98000 /* 1024x608, align 600 to 32bit */
+
+#define OVERLAY_BUS_SCALE_TABLE_BASE	6
+
+static int mdp4_overlay_is_rgb_type(int format)
+{
+	switch (format) {
+	case MDP_RGB_565:
+	case MDP_RGB_888:
+	case MDP_BGR_565:
+	case MDP_XRGB_8888:
+	case MDP_ARGB_8888:
+	case MDP_RGBA_8888:
+	case MDP_BGRA_8888:
+	case MDP_RGBX_8888:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static uint32 mdp4_overlay_get_perf_level(struct mdp_overlay *req,
+					  struct msm_fb_data_type *mfd)
+{
+	int is_fg = 0, i, cnt;
+
+	if (req->is_fg && ((req->alpha & 0x0ff) == 0xff))
+		is_fg = 1;
+
+	if (mdp4_extn_disp)
+		return OVERLAY_PERF_LEVEL1;
+
+	if (req->flags & (MDP_DEINTERLACE | MDP_BACKEND_COMPOSITION))
+		return OVERLAY_PERF_LEVEL1;
+
+	for (i = 0, cnt = 0; i < OVERLAY_PIPE_MAX; i++) {
+		if (ctrl->plist[i].pipe_used && ++cnt > 2)
+			return OVERLAY_PERF_LEVEL1;
+	}
+
+	if (mdp4_overlay_is_rgb_type(req->src.format) && is_fg &&
+		((req->src.width * req->src.height) <= OVERLAY_WSVGA_SIZE))
+		return OVERLAY_PERF_LEVEL4;
+	else if (mdp4_overlay_is_rgb_type(req->src.format))
+		return OVERLAY_PERF_LEVEL1;
+
+	if (req->src.width*req->src.height <= OVERLAY_VGA_SIZE) {
+		if (mfd->mdp_rev >= MDP_REV_42)
+			return OVERLAY_PERF_LEVEL4;
+		else
+			return OVERLAY_PERF_LEVEL3;
+
+	} else if (req->src.width*req->src.height <= OVERLAY_720P_TILE_SIZE) {
+		u32 max, min;
+		max = (req->dst_rect.h > req->dst_rect.w) ?
+			req->dst_rect.h : req->dst_rect.w;
+		min = (mfd->panel_info.yres > mfd->panel_info.xres) ?
+			mfd->panel_info.xres : mfd->panel_info.yres;
+		if (max > min)	/* landscape mode */
+			return OVERLAY_PERF_LEVEL3;
+		else		/* potrait mode */
+			return OVERLAY_PERF_LEVEL2;
+	}
+	else
+		return OVERLAY_PERF_LEVEL1;
+}
+
+void mdp4_update_perf_level(u32 perf_level)
+{
+	static int first = 1;
+
+	new_perf_level = perf_level;
+
+	if (first) {
+		first = 0;
+		mdp4_set_perf_level();
+	}
+}
+
+void mdp4_set_perf_level(void)
+{
+	static int old_perf_level;
+	int cur_perf_level;
+
+	if (mdp4_extn_disp)
+		cur_perf_level = OVERLAY_PERF_LEVEL1;
+	else
+		cur_perf_level = new_perf_level;
+
+	if (old_perf_level != cur_perf_level) {
+		mdp_set_core_clk(cur_perf_level);
+		old_perf_level = cur_perf_level;
+		mdp_bus_scale_update_request(OVERLAY_BUS_SCALE_TABLE_BASE
+					     - cur_perf_level);
+	}
+}
+
+static u32 mdp4_overlay_blt_enable(struct mdp_overlay *req,
+	struct msm_fb_data_type *mfd, uint32 perf_level)
+{
+	u32 clk_rate = mfd->panel_info.clk_rate;
+	u32 pull_mode = 0, use_blt = 0;
+
+	if (mfd->panel_info.type == MIPI_VIDEO_PANEL)
+		clk_rate = (&mfd->panel_info.mipi)->dsi_pclk_rate;
+
+	if ((mfd->panel_info.type == LCDC_PANEL) ||
+	    (mfd->panel_info.type == MIPI_VIDEO_PANEL) ||
+	    (mfd->panel_info.type == DTV_PANEL))
+		pull_mode = 1;
+
+	if (pull_mode && (req->src_rect.h > req->dst_rect.h ||
+		req->src_rect.w > req->dst_rect.w)) {
+		if (mdp4_overlay_validate_downscale(req, mfd, perf_level,
+			clk_rate))
+			use_blt = 1;
+	}
+
+	if (mfd->panel_info.type == MDDI_PANEL) {
+		if ((req->src_rect.h/2) >= req->dst_rect.h ||
+			(req->src_rect.w/2) >= req->dst_rect.w)
+				use_blt = 1;
+	}
+
+	if (mfd->mdp_rev == MDP_REV_41) {
+		/*
+		* writeback (blt) mode to provide work around for
+		* dsi cmd mode interface hardware bug.
+		*/
+		if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD) {
+			if (req->dst_rect.x != 0)
+				use_blt = 1;
+		}
+		if ((mfd->panel_info.xres > 1280) &&
+		    (mfd->panel_info.type != DTV_PANEL))
+			use_blt = 1;
+	}
+	return use_blt;
+}
+
 int mdp4_overlay_set(struct fb_info *info, struct mdp_overlay *req)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
-	int ret, mixer;
+	int ret, mixer, perf_level;
 	struct mdp4_overlay_pipe *pipe;
-	u32 use_blt = 0;
 
 	if (mfd == NULL) {
 		pr_err("%s: mfd == NULL, -ENODEV\n", __func__);
@@ -2973,10 +2711,20 @@
 		return ret;
 	}
 
+	perf_level = mdp4_overlay_get_perf_level(req, mfd);
+
+	if (mixer == MDP4_MIXER0) {
+		u32 use_blt = mdp4_overlay_blt_enable(req, mfd,	perf_level);
+		mfd->use_ov0_blt &= ~(1 << (pipe->pipe_ndx-1));
+		mfd->use_ov0_blt |= (use_blt << (pipe->pipe_ndx-1));
+	}
+
 	/* return id back to user */
 	req->id = pipe->pipe_ndx;	/* pipe_ndx start from 1 */
 	pipe->req_data = *req;		/* keep original req */
 
+	pipe->flags = req->flags;
+
 	if (!IS_ERR_OR_NULL(mfd->iclient)) {
 		pr_debug("pipe->flags 0x%x\n", pipe->flags);
 		if (pipe->flags & MDP_SECURE_OVERLAY_SESSION) {
@@ -3005,12 +2753,49 @@
 
 	mdp4_stat.overlay_set[pipe->mixer_num]++;
 
-	mdp4_overlay_mdp_pipe_req(pipe, mfd);
+	if (ctrl->panel_mode & MDP4_PANEL_DTV &&
+	    pipe->mixer_num == MDP4_MIXER1) {
+		u32 use_blt = mdp4_overlay_blt_enable(req, mfd, perf_level);
+
+		if (hdmi_prim_display) {
+			if (!mdp4_overlay_is_rgb_type(req->src.format) &&
+				pipe->pipe_type == OVERLAY_TYPE_VIDEO &&
+				(req->src_rect.h > req->dst_rect.h ||
+				req->src_rect.w > req->dst_rect.w))
+				use_blt = 1;
+		}
 
+		mdp4_overlay_dtv_set(mfd, pipe);
+		mfd->use_ov1_blt &= ~(1 << (pipe->pipe_ndx-1));
+		mfd->use_ov1_blt |= (use_blt << (pipe->pipe_ndx-1));
+	}
+
+	if (new_perf_level != perf_level) {
+		u32 old_level = new_perf_level;
+		mdp4_update_perf_level(perf_level);
+
+		/* change clck base on perf level */
+		if (pipe->mixer_num == MDP4_MIXER0) {
+			if (ctrl->panel_mode & MDP4_PANEL_DSI_VIDEO) {
+				if (old_level > perf_level)
+					mdp4_set_perf_level();
+			} else if (ctrl->panel_mode & MDP4_PANEL_DSI_CMD) {
+				mdp4_set_perf_level();
+			} else if (ctrl->panel_mode & MDP4_PANEL_LCDC) {
+				if (old_level > perf_level)
+					mdp4_set_perf_level();
+			} else if (ctrl->panel_mode & MDP4_PANEL_MDDI) {
+				mdp4_mddi_dma_busy_wait(mfd);
+				mdp4_mddi_blt_dmap_busy_wait(mfd);
+				mdp4_set_perf_level();
+			}
+		} else {
+			if (ctrl->panel_mode & MDP4_PANEL_DTV)
+				mdp4_overlay_dtv_set_perf(mfd);
+		}
+	}
 	mutex_unlock(&mfd->dma->ov_mutex);
 
-	if (mfd->backlight_ctrl_ongoing)
-		usleep(5000);
 	return 0;
 }
 
@@ -3066,11 +2851,13 @@
 	else {
 		/* mixer 0 */
 		ctrl->mixer0_played = 0;
+
 		if (ctrl->panel_mode & MDP4_PANEL_MDDI) {
 			if (mfd->panel_power_on)
 				mdp4_mddi_blt_dmap_busy_wait(mfd);
 		}
 	}
+
 	mdp4_overlay_reg_flush(pipe, 1);
 	mdp4_mixer_stage_down(pipe);
 
@@ -3079,9 +2866,13 @@
 			if (mfd->panel_power_on)
 				mdp4_mddi_overlay_restore();
 		}
+
+		mfd->use_ov0_blt &= ~(1 << (pipe->pipe_ndx-1));
 	} else {	/* mixer1, DTV, ATV */
-		if (ctrl->panel_mode & MDP4_PANEL_DTV)
+		if (ctrl->panel_mode & MDP4_PANEL_DTV) {
 			mdp4_overlay_dtv_unset(mfd, pipe);
+			mfd->use_ov1_blt &= ~(1 << (pipe->pipe_ndx-1));
+		}
 	}
 
 	/* Reset any HSIC settings to default */
@@ -3096,6 +2887,7 @@
 	mdp4_stat.overlay_unset[pipe->mixer_num]++;
 
 	mdp4_overlay_pipe_free(pipe);
+
 	mutex_unlock(&mfd->dma->ov_mutex);
 
 	return 0;
@@ -3133,9 +2925,8 @@
 			mdp4_dsi_cmd_vsync_ctrl(0, cmd);
 		else if (ctrl->panel_mode & MDP4_PANEL_LCDC)
 			mdp4_lcdc_vsync_ctrl(0, cmd);
-	} else if (hdmi_prim_display || info->node == 1) {
+	} else if (hdmi_prim_display || info->node == 1)
 		mdp4_dtv_vsync_ctrl(0, cmd);
-	}
 
 	return 0;
 }
@@ -3207,6 +2998,7 @@
 
 	pr_debug("%s: pipe=%x ndx=%d num=%d used=%d\n", __func__,
 		(int) pipe, pipe->pipe_ndx, pipe->pipe_num, pipe->pipe_used);
+
 	mdp4_overlay_reg_flush(pipe, 1);
 	mdp4_mixer_stage_up(pipe);
 }
@@ -3244,7 +3036,8 @@
 		return 0;
 	}
 
-	if (pipe->mixer_num == MDP4_MIXER2 || ctrl->panel_mode & MDP4_PANEL_MDDI)
+	if (pipe->mixer_num == MDP4_MIXER2 ||
+					ctrl->panel_mode & MDP4_PANEL_MDDI)
 		mutex_lock(&mfd->dma->ov_mutex);
 
 	img = &req->data;
@@ -3352,9 +3145,8 @@
 		}
 	}
 
-	mdp4_overlay_mdp_perf_req(mfd, ctrl->plist);
-
-	if (pipe->mixer_num == MDP4_MIXER2 || ctrl->panel_mode & MDP4_PANEL_MDDI)
+	if (pipe->mixer_num == MDP4_MIXER2 ||
+				ctrl->panel_mode & MDP4_PANEL_MDDI)
 		goto mddi;
 
 	if (pipe->mixer_num == MDP4_MIXER0) {
@@ -3377,17 +3169,17 @@
 	return ret;
 
 mddi:
+
 	if (pipe->pipe_type == OVERLAY_TYPE_VIDEO) {
 		mdp4_overlay_vg_setup(pipe);    /* video/graphic pipe */
 	} else {
-		mdp4_overlay_rgb_setup(pipe);	/* rgb pipe */
+		if (pipe->flags & MDP_SHARPENING) {
+			pr_debug(
+			"%s: Sharpening/Smoothing not supported on RGB pipe\n",
+								     __func__);
+			pipe->flags &= ~MDP_SHARPENING;
 	}
-
-	if (pipe->mixer_num != MDP4_MIXER2) {
-		if ((ctrl->panel_mode & MDP4_PANEL_DTV) ||
-			(ctrl->panel_mode & MDP4_PANEL_LCDC) ||
-			(ctrl->panel_mode & MDP4_PANEL_DSI_VIDEO))
-			mdp4_overlay_reg_flush(pipe, 1);
+		mdp4_overlay_rgb_setup(pipe);	/* rgb pipe */
 	}
 
 	mdp4_mixer_stage_up(pipe);
@@ -3411,6 +3203,9 @@
 		mdp4_mddi_kickoff_video(mfd, pipe);
 	}
 
+	/* write out DPP HSIC registers */
+	if (pipe->flags & MDP_DPP_HSIC)
+		mdp4_hsic_update(pipe);
 	if (!(pipe->flags & MDP_OV_PLAY_NOWAIT))
 		mdp4_iommu_unmap(pipe);
 	mdp4_stat.overlay_play[pipe->mixer_num]++;
@@ -3481,6 +3276,13 @@
 	},
 };
 
+static int mdp_iommu_fault_handler(struct iommu_domain *domain,
+	struct device *dev, unsigned long iova, int flags)
+{
+	pr_err("MDP IOMMU page fault: iova 0x%lx", iova);
+	return 0;
+}
+
 void mdp4_iommu_attach(void)
 {
 	static int done;
@@ -3511,6 +3313,8 @@
 			if (!domain)
 				continue;
 
+			iommu_set_fault_handler(domain,
+				mdp_iommu_fault_handler);
 			if (iommu_attach_device(domain,	ctx)) {
 				WARN(1, "%s: could not attach domain %d to context %s."
 					" iommu programming will not occur.\n",
Only in msm: .mdp4_overlay.c.swp
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_dsi_cmd.c msm/mdp4_overlay_dsi_cmd.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_dsi_cmd.c	2012-08-13 16:39:47.802233556 -0700
+++ msm/mdp4_overlay_dsi_cmd.c	2012-08-14 12:32:48.900338838 -0700
@@ -874,7 +874,6 @@
 	/* disable dsi trigger */
 	MDP_OUTP(MDP_BASE + 0x000a4, 0x00);
 
-
 	mdp4_overlay_setup_pipe_addr(mfd, pipe);
 
 	mdp4_overlay_rgb_setup(pipe);
@@ -1016,6 +1015,7 @@
 	atomic_set(&vctrl->suspend, 0);
 	pr_info("%s-:\n", __func__);
 
+
 	return ret;
 }
 
@@ -1120,12 +1120,18 @@
 		mdp4_dsi_cmd_pipe_queue(0, pipe);
 	}
 
-	mdp4_overlay_mdp_perf_upd(mfd, 1);
+	if (mfd->use_ov0_blt != mfd->ov0_blt_state) {
+
+		if (mfd->use_ov0_blt)
+			mdp4_dsi_cmd_do_blt(mfd, 1);
+		else
+			mdp4_dsi_cmd_do_blt(mfd, 0);
+
+		mfd->ov0_blt_state = mfd->use_ov0_blt;
+	}
 
 	mdp4_dsi_cmd_pipe_commit();
 	mdp4_dsi_cmd_wait4vsync(0, &xx);
 	vctrl->expire_tick = VSYNC_EXPIRE_TICK;
 	vctrl->clk_control = 1;
-
-	mdp4_overlay_mdp_perf_upd(mfd, 0);
 }
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_dsi_video.c msm/mdp4_overlay_dsi_video.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_dsi_video.c	2012-08-13 16:39:47.803233556 -0700
+++ msm/mdp4_overlay_dsi_video.c	2012-08-14 12:32:48.900338838 -0700
@@ -39,7 +39,6 @@
 
 #define DSI_VIDEO_BASE	0xE0000
 
-
 static int first_pixel_start_x;
 static int first_pixel_start_y;
 static int dsi_video_enabled;
@@ -197,8 +196,6 @@
 	}
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
-	mdp4_overlay_mdp_perf_upd(vctrl->mfd, 1);
-
 	if (vctrl->blt_change) {
 		pipe = vctrl->base_pipe;
 		spin_lock_irqsave(&vctrl->spin_lock, flags);
@@ -212,7 +209,6 @@
 	}
 
 	pipe = vp->plist;
-
 	for (i = 0; i < OVERLAY_PIPE_MAX; i++, pipe++) {
 		if (pipe->pipe_used) {
 			cnt++;
@@ -530,8 +526,6 @@
 	pipe->src_w = fbi->var.xres;
 	pipe->src_y = 0;
 	pipe->src_x = 0;
-	pipe->dst_h = fbi->var.yres;
-	pipe->dst_w = fbi->var.xres;
 	pipe->srcp0_ystride = fbi->fix.line_length;
 	pipe->bpp = bpp;
 
@@ -543,8 +537,6 @@
 	pipe->dst_h = fbi->var.yres;
 	pipe->dst_w = fbi->var.xres;
 
-	mdp4_overlay_mdp_pipe_req(pipe, mfd);
-
 	atomic_set(&vctrl->suspend, 0);
 
 	mdp4_overlay_dmap_xy(pipe);	/* dma_p */
@@ -827,6 +819,13 @@
 	MDP_OUTP(MDP_BASE + 0x90008, addr);
 }
 
+void mdp4_overlay_dsi_video_set_perf(struct msm_fb_data_type *mfd)
+{
+	/* change mdp clk while mdp is idle */
+	mdp4_set_perf_level();
+}
+
+
 /*
  * mdp4_primary_vsync_dsi_video: called from isr
  */
@@ -928,6 +927,8 @@
 	vctrl = &vsync_ctrl_db[cndx];
 	pipe = vctrl->base_pipe;
 
+	mdp4_allocate_writeback_buf(mfd, MDP4_MIXER0);
+
 	if (mfd->ov0_wb_buf->write_addr == 0) {
 		pr_info("%s: no blt_base assigned\n", __func__);
 		return;
@@ -951,7 +952,7 @@
 		vctrl->blt_change++;
 	}
 
-	pr_info("%s: changed=%d enable=%d blt_addr=%x\n", __func__,
+	pr_info("%s: changed=%d enable=%d ov_blt_addr=%x\n", __func__,
 		vctrl->blt_change, enable, (int)pipe->ov_blt_addr);
 
 	if (!vctrl->blt_change) {
@@ -960,10 +961,6 @@
 	}
 
 	spin_unlock_irqrestore(&vctrl->spin_lock, flag);
-	
-#if defined(CONFIG_MIPI_SAMSUNG_ESD_REFRESH)
-    set_esd_disable();
-#endif
 }
 
 void mdp4_dsi_video_overlay_blt(struct msm_fb_data_type *mfd,
@@ -1013,7 +1010,15 @@
 		mdp4_dsi_video_pipe_queue(0, pipe);
 	}
 
-	mdp4_overlay_mdp_perf_upd(mfd, 1);
+	if (mfd->use_ov0_blt != mfd->ov0_blt_state) {
+
+		if (mfd->use_ov0_blt)
+			mdp4_dsi_video_do_blt(mfd, 1);
+		else
+			mdp4_dsi_video_do_blt(mfd, 0);
+
+		mfd->ov0_blt_state = mfd->use_ov0_blt;
+	}
 
 	mdp4_dsi_video_pipe_commit();
 
@@ -1021,7 +1026,5 @@
 		mdp4_dsi_video_wait4ov(0);
 	else
 		mdp4_dsi_video_wait4dmap(0);
-
-	mdp4_overlay_mdp_perf_upd(mfd, 0);
 }
 
Only in msm: .mdp4_overlay_dsi_video.c.swp
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_dtv.c msm/mdp4_overlay_dtv.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_dtv.c	2012-08-13 16:39:47.803233556 -0700
+++ msm/mdp4_overlay_dtv.c	2012-08-14 12:32:48.900338838 -0700
@@ -30,10 +30,8 @@
 #include "mdp.h"
 #include "msm_fb.h"
 #include "mdp4.h"
-#include "hdmi_msm.h"
 
 #define DTV_BASE	0xD0000
-#define DMA_E_BASE	0xB0000
 
 static int dtv_enabled;
 
@@ -483,15 +481,6 @@
 	MDP_OUTP(MDP_BASE + DTV_BASE + 0x30, active_v_start);
 	MDP_OUTP(MDP_BASE + DTV_BASE + 0x38, active_v_end);
 
-	/* All of hdmi resolution except of 640*480p
-	   should trasmmit as a limited RGB range following HDMI/MHL SPEC.*/
-	if (var->reserved[3] != 1) {
-		/*MHL CTS 3.2.3.4 Video Quantization Ranges*/
-		MDP_OUTP(MDP_BASE + DMA_E_BASE + 0x70, 0x00EB0010);
-		MDP_OUTP(MDP_BASE + DMA_E_BASE + 0x74, 0x00EB0010);
-		MDP_OUTP(MDP_BASE + DMA_E_BASE + 0x78, 0x00EB0010);
-	}
-
 	/* Test pattern 8 x 8 pixel */
 	/* MDP_OUTP(MDP_BASE + DTV_BASE + 0x4C, 0x80000808); */
 
@@ -532,13 +521,6 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
-#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
-	if (!hdmi_msm_state->hpd_on_offline) {
-		pr_info("hdmi_online is not\n");
-		return -ENODEV;
-	}
-#endif
-
 	vctrl->dev = mfd->fbi->dev;
 	vctrl->fake_vsync = 1;
 
@@ -572,18 +554,10 @@
 {
 	struct msm_fb_data_type *mfd;
 	int ret = 0;
-
 	int cndx = 0;
 	struct vsycn_ctrl *vctrl;
 	struct mdp4_overlay_pipe *pipe;
 
-#if defined(CONFIG_VIDEO_MHL_V1) || defined(CONFIG_VIDEO_MHL_V2)
-	if (hdmi_msm_state->hpd_on_offline) {
-		pr_info("hpd_offline is not\n");
-		return -ENODEV;
-	}
-#endif
-
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
 
 	vctrl = &vsync_ctrl_db[cndx];
@@ -673,7 +647,8 @@
 
 void mdp4_overlay_dtv_set_perf(struct msm_fb_data_type *mfd)
 {
-
+	/* change mdp clk while mdp is idle` */
+	mdp4_set_perf_level();
 }
 
 static void mdp4_overlay_dtv_alloc_pipe(struct msm_fb_data_type *mfd,
@@ -726,16 +701,10 @@
 	pipe->src_width = fbi->var.xres;
 	pipe->src_h = fbi->var.yres;
 	pipe->src_w = fbi->var.xres;
-	pipe->dst_h = fbi->var.yres;
-	pipe->dst_w = fbi->var.xres;
 	pipe->src_y = 0;
 	pipe->src_x = 0;
-	pipe->dst_h = fbi->var.yres;
-	pipe->dst_w = fbi->var.xres;
 	pipe->srcp0_ystride = fbi->fix.line_length;
 
-	mdp4_overlay_mdp_pipe_req(pipe, mfd);
-
 	ret = mdp4_overlay_format2pipe(pipe);
 	if (ret < 0)
 		pr_warn("%s: format2type failed\n", __func__);
@@ -867,7 +836,6 @@
 	} else  {
 		mdp4_overlay_dma_commit(MDP4_MIXER1);
 	}
-
 	vsync_irq_disable(INTR_DMA_E_DONE, MDP_DMA_E_TERM);
 	spin_unlock(&vctrl->spin_lock);
 }
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_lcdc.c msm/mdp4_overlay_lcdc.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_lcdc.c	2012-08-13 16:39:47.803233556 -0700
+++ msm/mdp4_overlay_lcdc.c	2012-08-14 12:32:48.901338838 -0700
@@ -201,8 +201,6 @@
 	}
 	spin_unlock_irqrestore(&vctrl->spin_lock, flags);
 
-	mdp4_overlay_mdp_perf_upd(vctrl->mfd, 1);
-
 	if (vctrl->blt_change) {
 		pipe = vctrl->base_pipe;
 		spin_lock_irqsave(&vctrl->spin_lock, flags);
@@ -497,14 +495,13 @@
 		pipe = vctrl->base_pipe;
 	}
 
+
 	pipe->src_height = fbi->var.yres;
 	pipe->src_width = fbi->var.xres;
 	pipe->src_h = fbi->var.yres;
 	pipe->src_w = fbi->var.xres;
 	pipe->src_y = 0;
 	pipe->src_x = 0;
-	pipe->dst_h = fbi->var.yres;
-	pipe->dst_w = fbi->var.xres;
 
 	if (mfd->display_iova)
 		pipe->srcp0_addr = mfd->display_iova + buf_offset;
@@ -514,8 +511,6 @@
 	pipe->srcp0_ystride = fbi->fix.line_length;
 	pipe->bpp = bpp;
 
-	mdp4_overlay_mdp_pipe_req(pipe, mfd);
-
 	atomic_set(&vctrl->suspend, 0);
 
 	mdp4_overlay_dmap_xy(pipe);
@@ -545,7 +540,12 @@
 	lcdc_bpp = mfd->panel_info.bpp;
 
 	hsync_period =
-	    hsync_pulse_width + h_back_porch + lcdc_width + h_front_porch;
+	    hsync_pulse_width + h_back_porch + h_front_porch;
+	if ((mfd->panel_info.type == LVDS_PANEL) &&
+		(mfd->panel_info.lvds.channel_mode == LVDS_DUAL_CHANNEL_MODE))
+		hsync_period += lcdc_width / 2;
+	else
+		hsync_period += lcdc_width;
 	hsync_ctrl = (hsync_period << 16) | hsync_pulse_width;
 	hsync_start_x = hsync_pulse_width + h_back_porch;
 	hsync_end_x = hsync_period - h_front_porch - 1;
@@ -580,8 +580,13 @@
 
 
 #ifdef CONFIG_FB_MSM_MDP40
+	if (mfd->panel_info.lcdc.is_sync_active_high) {
+		hsync_polarity = 0;
+		vsync_polarity = 0;
+	} else {
 	hsync_polarity = 1;
 	vsync_polarity = 1;
+	}
 	lcdc_underflow_clr |= 0x80000000;	/* enable recovery */
 #else
 	hsync_polarity = 0;
@@ -707,6 +712,12 @@
 	MDP_OUTP(MDP_BASE + 0x90008, addr);
 }
 
+void mdp4_overlay_lcdc_set_perf(struct msm_fb_data_type *mfd)
+{
+	/* change mdp clk while mdp is idle */
+	mdp4_set_perf_level();
+}
+
 /*
  * mdp4_primary_vsync_lcdc: called from isr
  */
@@ -887,7 +898,15 @@
 		mdp4_lcdc_pipe_queue(0, pipe);
 	}
 
-	mdp4_overlay_mdp_perf_upd(mfd, 1);
+	if (mfd->use_ov0_blt != mfd->ov0_blt_state) {
+
+		if (mfd->use_ov0_blt)
+			mdp4_lcdc_do_blt(mfd, 1);
+		else
+			mdp4_lcdc_do_blt(mfd, 0);
+
+		mfd->ov0_blt_state = mfd->use_ov0_blt;
+	}
 
 	mdp4_lcdc_pipe_commit();
 
@@ -895,6 +914,4 @@
 		mdp4_lcdc_wait4ov(0);
 	else
 		mdp4_lcdc_wait4dmap(0);
-
-	mdp4_overlay_mdp_perf_upd(mfd, 0);
 }
Only in msm: .mdp4_overlay_lcdc.c.swp
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_mddi.c msm/mdp4_overlay_mddi.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_mddi.c	2012-08-13 16:39:47.803233556 -0700
+++ msm/mdp4_overlay_mddi.c	2012-08-14 12:32:48.901338838 -0700
@@ -574,6 +574,8 @@
 				struct mdp4_overlay_pipe *pipe)
 {
 	unsigned long flag;
+	/* change mdp clk while mdp is idle` */
+	mdp4_set_perf_level();
 
 	mdp_enable_irq(MDP_OVERLAY0_TERM);
 	spin_lock_irqsave(&mdp_spin_lock, flag);
@@ -658,6 +660,9 @@
 void mdp4_mddi_dma_s_kickoff(struct msm_fb_data_type *mfd,
 				struct mdp4_overlay_pipe *pipe)
 {
+	/* change mdp clk while mdp is idle` */
+	mdp4_set_perf_level();
+
 	mdp_enable_irq(MDP_DMA_S_TERM);
 
 	if (mddi_pipe->ov_blt_addr == 0)
@@ -693,10 +698,9 @@
 
 		if (mddi_pipe && mddi_pipe->ov_blt_addr)
 			mdp4_mddi_blt_dmap_busy_wait(mfd);
-		mdp4_overlay_mdp_perf_upd(mfd, 0);
+
 		mdp4_overlay_update_lcd(mfd);
 
-		mdp4_overlay_mdp_perf_upd(mfd, 1);
 		if (mdp_hw_revision < MDP4_REVISION_V2_1) {
 			/* dmas dmap switch */
 			if (mdp4_overlay_mixer_play(mddi_pipe->mixer_num)
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_writeback.c msm/mdp4_overlay_writeback.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_overlay_writeback.c	2012-08-13 16:39:47.803233556 -0700
+++ msm/mdp4_overlay_writeback.c	2012-08-14 12:32:48.901338838 -0700
@@ -87,8 +87,7 @@
 		pipe->mixer_stage  = MDP4_MIXER_STAGE_BASE;
 		pipe->mixer_num  = MDP4_MIXER2;
 		pipe->src_format = MDP_ARGB_8888;
-		mdp4_overlay_panel_mode(pipe->mixer_num,
-		MDP4_PANEL_WRITEBACK);
+		mdp4_overlay_panel_mode(pipe->mixer_num, MDP4_PANEL_WRITEBACK);
 		ret = mdp4_overlay_format2pipe(pipe);
 		if (ret < 0)
 			pr_info("%s: format2type failed\n", __func__);
@@ -175,7 +174,6 @@
 	pipe->dst_y = 0;
 	pipe->dst_x = 0;
 
-	mdp4_overlay_mdp_pipe_req(pipe, mfd);
 	if (mfd->display_iova)
 		pipe->srcp0_addr = mfd->display_iova + buf_offset;
 	else
@@ -314,9 +312,6 @@
 	int ret = 0;
 	struct msmfb_writeback_data_list *node = NULL;
 
-	if (!mfd)
-		return;
-
 	mutex_lock(&mfd->unregister_mutex);
 	mutex_lock(&mfd->writeback_mutex);
 	if (!list_empty(&mfd->writeback_free_queue)
@@ -423,7 +418,7 @@
 		else if (mfd->iclient) {
 			struct ion_handle *srcp_ihdl;
 			ulong len;
-			srcp_ihdl = ion_import_fd(mfd->iclient,
+			srcp_ihdl = ion_import_dma_buf(mfd->iclient,
 						  data->memory_id);
 			if (IS_ERR_OR_NULL(srcp_ihdl)) {
 				pr_err("%s: ion import fd failed\n", __func__);
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_util.c msm/mdp4_util.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_util.c	2012-08-13 16:39:47.804233556 -0700
+++ msm/mdp4_util.c	2012-08-14 12:32:39.539339479 -0700
@@ -102,15 +102,15 @@
 		data = 0x40;	/* bit 6 */
 		intf = MDDI_LCDC_INTF;
 		if (output == SECONDARY_INTF_SEL) {
-			MSM_FB_INFO("%s: Illegal INTF selected, output=%d" \
-				"intf=%d\n", __func__, output, (int)intf);
+			MSM_FB_INFO("%s: Illegal INTF selected, output=%d \
+				intf=%d\n", __func__, output, (int)intf);
 		}
 	} else if (intf == DSI_CMD_INTF) {
 		data = 0x80;	/* bit 7 */
 		intf = MDDI_INTF;
 		if (output == EXTERNAL_INTF_SEL) {
-			MSM_FB_INFO("%s: Illegal INTF selected, output=%d" \
-				"intf=%d\n", __func__, output, (int)intf);
+			MSM_FB_INFO("%s: Illegal INTF selected, output=%d \
+				intf=%d\n", __func__, output, (int)intf);
 		}
 	} else
 		data = 0;
@@ -142,8 +142,7 @@
 	/* MDP cmd block disable */
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
-	MSM_FB_DEBUG("mdp4_display_intf_sel: 0x%x\n",
-	(int)inpdw(MDP_BASE + 0x0038));
+  MSM_FB_DEBUG("mdp4_display_intf_sel: 0x%x\n", (int)inpdw(MDP_BASE + 0x0038));
 }
 
 unsigned long mdp4_display_status(void)
@@ -250,7 +249,7 @@
 	/* MDP cmd block enable */
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 
-	mdp_bus_scale_update_request(5);
+	mdp4_update_perf_level(OVERLAY_PERF_LEVEL4);
 
 #ifdef MDP4_ERROR
 	/*
@@ -577,529 +576,6 @@
 };
 
 static uint32 vg_qseed_table2[] = {
-	0x02000000, 0x00000000, 0x02060ff2, 0x00000008,
-	0x02090fe4, 0x00000013, 0x020a0fd9, 0x0ffc0021,
-	0x02080fce, 0x0ffa0030, 0x02030fc5, 0x0ff60042,
-	0x01fd0fbe, 0x0ff10054, 0x01f50fb6, 0x0fed0068,
-	0x01e90fb1, 0x0fe60080, 0x01dc0fae, 0x0fe10095,
-	0x01ca0fae, 0x0fda00ae, 0x01b70fad, 0x0fd600c6,
-	0x01a40fad, 0x0fcf00e0, 0x018f0faf, 0x0fc800fa,
-	0x01780fb1, 0x0fc30114, 0x015f0fb5, 0x0fbf012d,
-	0x01490fb7, 0x0fb70149, 0x012d0fbf, 0x0fb5015f,
-	0x01140fc3, 0x0fb10178, 0x00fa0fc8, 0x0faf018f,
-	0x00e00fcf, 0x0fad01a4, 0x00c60fd6, 0x0fad01b7,
-	0x00ae0fda, 0x0fae01ca, 0x00950fe1, 0x0fae01dc,
-	0x00800fe6, 0x0fb101e9, 0x00680fed, 0x0fb601f5,
-	0x00540ff1, 0x0fbe01fd, 0x00420ff6, 0x0fc50203,
-	0x00300ffa, 0x0fce0208, 0x00210ffc, 0x0fd9020a,
-	0x00130000, 0x0fe40209, 0x00080000, 0x0ff20206,
-	0x02000000, 0x00000000, 0x02040ff2, 0x0000000a,
-	0x02040fe4, 0x00000018, 0x02010fda, 0x0ffc0029,
-	0x01fc0fcf, 0x0ffa003b, 0x01f30fc7, 0x0ff60050,
-	0x01e90fc0, 0x0ff20065, 0x01dc0fba, 0x0fee007c,
-	0x01cc0fb6, 0x0fe80096, 0x01ba0fb4, 0x0fe400ae,
-	0x01a70fb4, 0x0fdd00c8, 0x018f0fb5, 0x0fda00e2,
-	0x017a0fb5, 0x0fd400fd, 0x01630fb8, 0x0fce0117,
-	0x014c0fba, 0x0fca0130, 0x01320fbf, 0x0fc70148,
-	0x011b0fc1, 0x0fc10163, 0x01010fc8, 0x0fc00177,
-	0x00e90fcd, 0x0fbd018d, 0x00d10fd1, 0x0fbc01a2,
-	0x00ba0fd7, 0x0fbb01b4, 0x00a30fdd, 0x0fbc01c4,
-	0x008e0fe1, 0x0fbd01d4, 0x00790fe7, 0x0fbe01e2,
-	0x00670feb, 0x0fc001ee, 0x00540ff1, 0x0fc501f6,
-	0x00430ff4, 0x0fcb01fe, 0x00340ff8, 0x0fd10203,
-	0x00260ffb, 0x0fd80207, 0x001a0ffd, 0x0fe10208,
-	0x000f0000, 0x0fea0207, 0x00060000, 0x0ff50205,
-	0x02000000, 0x00000000, 0x02020ff2, 0x0000000c,
-	0x02000fe4, 0x0000001c, 0x01fa0fda, 0x0ffc0030,
-	0x01f10fd0, 0x0ffa0045, 0x01e50fc8, 0x0ff6005d,
-	0x01d60fc3, 0x0ff30074, 0x01c60fbd, 0x0fef008e,
-	0x01b30fba, 0x0fe900aa, 0x019e0fb9, 0x0fe500c4,
-	0x01870fba, 0x0fe000df, 0x016f0fbb, 0x0fdd00f9,
-	0x01580fbc, 0x0fd80114, 0x01400fbf, 0x0fd3012e,
-	0x01280fc2, 0x0fd00146, 0x010f0fc6, 0x0fce015d,
-	0x00f90fc9, 0x0fc90175, 0x00e00fcf, 0x0fc90188,
-	0x00ca0fd4, 0x0fc6019c, 0x00b40fd8, 0x0fc601ae,
-	0x009f0fdd, 0x0fc501bf, 0x008b0fe3, 0x0fc601cc,
-	0x00780fe6, 0x0fc701db, 0x00660feb, 0x0fc801e7,
-	0x00560fef, 0x0fcb01f0, 0x00460ff3, 0x0fcf01f8,
-	0x00380ff6, 0x0fd401fe, 0x002c0ff9, 0x0fd90202,
-	0x00200ffc, 0x0fdf0205, 0x00160ffe, 0x0fe60206,
-	0x000c0000, 0x0fed0207, 0x00050000, 0x0ff70204,
-	0x02000000, 0x00000000, 0x01fe0ff3, 0x0000000f,
-	0x01f60fe5, 0x00000025, 0x01ea0fdb, 0x0ffd003e,
-	0x01db0fd2, 0x0ffb0058, 0x01c80fcc, 0x0ff70075,
-	0x01b50fc7, 0x0ff40090, 0x01a00fc3, 0x0ff000ad,
-	0x01880fc1, 0x0feb00cc, 0x01700fc1, 0x0fe800e7,
-	0x01550fc3, 0x0fe40104, 0x013b0fc5, 0x0fe2011e,
-	0x01240fc6, 0x0fde0138, 0x010c0fca, 0x0fda0150,
-	0x00f40fcd, 0x0fd90166, 0x00dd0fd1, 0x0fd7017b,
-	0x00c80fd4, 0x0fd40190, 0x00b20fd9, 0x0fd401a1,
-	0x009f0fdd, 0x0fd301b1, 0x008c0fe1, 0x0fd301c0,
-	0x007b0fe5, 0x0fd301cd, 0x006a0fea, 0x0fd401d8,
-	0x005c0fec, 0x0fd501e3, 0x004d0ff0, 0x0fd601ed,
-	0x00410ff3, 0x0fd801f4, 0x00340ff7, 0x0fdb01fa,
-	0x002a0ff9, 0x0fdf01fe, 0x00200ffb, 0x0fe30202,
-	0x00180ffd, 0x0fe70204, 0x00100ffe, 0x0fed0205,
-	0x00090000, 0x0ff20205, 0x00040000, 0x0ff90203,
-	0x02000000, 0x00000000, 0x02050ff5, 0x00000006,
-	0x02070fea, 0x0000000f, 0x02080fe1, 0x0ffd001a,
-	0x02070fd8, 0x0ffb0026, 0x02030fd1, 0x0ff80034,
-	0x01fe0fcb, 0x0ff40043, 0x01f60fc5, 0x0ff10054,
-	0x01ee0fc0, 0x0feb0067, 0x01e20fbe, 0x0fe70079,
-	0x01d40fbd, 0x0fe1008e, 0x01c40fbc, 0x0fdd00a3,
-	0x01b40fbb, 0x0fd700ba, 0x01a20fbc, 0x0fd100d1,
-	0x018d0fbd, 0x0fcd00e9, 0x01770fc0, 0x0fc80101,
-	0x01630fc1, 0x0fc1011b, 0x01480fc7, 0x0fbf0132,
-	0x01300fca, 0x0fba014c, 0x01170fce, 0x0fb80163,
-	0x00fd0fd4, 0x0fb5017a, 0x00e20fda, 0x0fb5018f,
-	0x00c80fdd, 0x0fb401a7, 0x00ae0fe4, 0x0fb401ba,
-	0x00960fe8, 0x0fb601cc, 0x007c0fee, 0x0fba01dc,
-	0x00650ff2, 0x0fc001e9, 0x00500ff6, 0x0fc701f3,
-	0x003b0ffa, 0x0fcf01fc, 0x00290ffc, 0x0fda0201,
-	0x00180000, 0x0fe40204, 0x000a0000, 0x0ff20204,
-	0x02000000, 0x00000000, 0x02030ff5, 0x00000008,
-	0x02030fea, 0x00000013, 0x02020fe1, 0x0ffd0020,
-	0x01fc0fd9, 0x0ffc002f, 0x01f60fd2, 0x0ff80040,
-	0x01ed0fcd, 0x0ff50051, 0x01e30fc7, 0x0ff10065,
-	0x01d70fc3, 0x0fec007a, 0x01c60fc2, 0x0fe9008f,
-	0x01b60fc1, 0x0fe300a6, 0x01a20fc1, 0x0fe000bd,
-	0x018f0fc1, 0x0fdb00d5, 0x017b0fc2, 0x0fd500ee,
-	0x01640fc4, 0x0fd20106, 0x014d0fc8, 0x0fce011d,
-	0x01370fc9, 0x0fc90137, 0x011d0fce, 0x0fc8014d,
-	0x01060fd2, 0x0fc40164, 0x00ee0fd5, 0x0fc2017b,
-	0x00d50fdb, 0x0fc1018f, 0x00bd0fe0, 0x0fc101a2,
-	0x00a60fe3, 0x0fc101b6, 0x008f0fe9, 0x0fc201c6,
-	0x007a0fec, 0x0fc301d7, 0x00650ff1, 0x0fc701e3,
-	0x00510ff5, 0x0fcd01ed, 0x00400ff8, 0x0fd201f6,
-	0x002f0ffc, 0x0fd901fc, 0x00200ffd, 0x0fe10202,
-	0x00130000, 0x0fea0203, 0x00080000, 0x0ff50203,
-	0x02000000, 0x00000000, 0x02020ff5, 0x00000009,
-	0x01ff0fea, 0x00000017, 0x01fb0fe2, 0x0ffd0026,
-	0x01f30fda, 0x0ffc0037, 0x01ea0fd3, 0x0ff8004b,
-	0x01df0fce, 0x0ff5005e, 0x01d10fc9, 0x0ff20074,
-	0x01c10fc6, 0x0fed008c, 0x01ae0fc5, 0x0fea00a3,
-	0x019b0fc5, 0x0fe500bb, 0x01850fc6, 0x0fe200d3,
-	0x01700fc6, 0x0fde00ec, 0x015a0fc8, 0x0fd90105,
-	0x01430fca, 0x0fd6011d, 0x012b0fcd, 0x0fd30135,
-	0x01150fcf, 0x0fcf014d, 0x00fc0fd4, 0x0fce0162,
-	0x00e50fd8, 0x0fcc0177, 0x00cf0fdb, 0x0fca018c,
-	0x00b80fe0, 0x0fc9019f, 0x00a20fe5, 0x0fca01af,
-	0x008e0fe8, 0x0fcb01bf, 0x00790fec, 0x0fcb01d0,
-	0x00670fef, 0x0fcd01dd, 0x00550ff4, 0x0fd001e7,
-	0x00440ff7, 0x0fd501f0, 0x00350ffa, 0x0fda01f7,
-	0x00270ffc, 0x0fdf01fe, 0x001b0ffe, 0x0fe70200,
-	0x00100000, 0x0fee0202, 0x00060000, 0x0ff70203,
-	0x02000000, 0x00000000, 0x01ff0ff5, 0x0000000c,
-	0x01f80fea, 0x0000001e, 0x01ef0fe2, 0x0ffd0032,
-	0x01e20fdb, 0x0ffc0047, 0x01d30fd5, 0x0ff9005f,
-	0x01c20fd1, 0x0ff60077, 0x01b00fcd, 0x0ff30090,
-	0x019b0fcb, 0x0fef00ab, 0x01850fcb, 0x0fec00c4,
-	0x016e0fcc, 0x0fe800de, 0x01550fcd, 0x0fe600f8,
-	0x013f0fce, 0x0fe20111, 0x01280fd0, 0x0fdf0129,
-	0x01110fd2, 0x0fdd0140, 0x00f90fd6, 0x0fdb0156,
-	0x00e40fd8, 0x0fd8016c, 0x00cd0fdd, 0x0fd8017e,
-	0x00b80fe0, 0x0fd60192, 0x00a40fe3, 0x0fd601a3,
-	0x00910fe7, 0x0fd501b3, 0x007f0feb, 0x0fd601c0,
-	0x006e0fed, 0x0fd701ce, 0x005d0ff1, 0x0fd701db,
-	0x004f0ff3, 0x0fd901e5, 0x00400ff7, 0x0fdc01ed,
-	0x00330ff9, 0x0fe001f4, 0x00280ffb, 0x0fe301fa,
-	0x001d0ffd, 0x0fe801fe, 0x00140ffe, 0x0fed0201,
-	0x000c0000, 0x0ff20202, 0x00050000, 0x0ff90202,
-	0x02000000, 0x00000000, 0x02040ff7, 0x00000005,
-	0x02070fed, 0x0000000c, 0x02060fe6, 0x0ffe0016,
-	0x02050fdf, 0x0ffc0020, 0x02020fd9, 0x0ff9002c,
-	0x01fe0fd4, 0x0ff60038, 0x01f80fcf, 0x0ff30046,
-	0x01f00fcb, 0x0fef0056, 0x01e70fc8, 0x0feb0066,
-	0x01db0fc7, 0x0fe60078, 0x01cc0fc6, 0x0fe3008b,
-	0x01bf0fc5, 0x0fdd009f, 0x01ae0fc6, 0x0fd800b4,
-	0x019c0fc6, 0x0fd400ca, 0x01880fc9, 0x0fcf00e0,
-	0x01750fc9, 0x0fc900f9, 0x015d0fce, 0x0fc6010f,
-	0x01460fd0, 0x0fc20128, 0x012e0fd3, 0x0fbf0140,
-	0x01140fd8, 0x0fbc0158, 0x00f90fdd, 0x0fbb016f,
-	0x00df0fe0, 0x0fba0187, 0x00c40fe5, 0x0fb9019e,
-	0x00aa0fe9, 0x0fba01b3, 0x008e0fef, 0x0fbd01c6,
-	0x00740ff3, 0x0fc301d6, 0x005d0ff6, 0x0fc801e5,
-	0x00450ffa, 0x0fd001f1, 0x00300ffc, 0x0fda01fa,
-	0x001c0000, 0x0fe40200, 0x000c0000, 0x0ff20202,
-	0x02000000, 0x00000000, 0x02030ff7, 0x00000006,
-	0x02020fee, 0x00000010, 0x02000fe7, 0x0ffe001b,
-	0x01fe0fdf, 0x0ffc0027, 0x01f70fda, 0x0ffa0035,
-	0x01f00fd5, 0x0ff70044, 0x01e70fd0, 0x0ff40055,
-	0x01dd0fcd, 0x0fef0067, 0x01d00fcb, 0x0fec0079,
-	0x01bf0fcb, 0x0fe8008e, 0x01af0fca, 0x0fe500a2,
-	0x019f0fc9, 0x0fe000b8, 0x018c0fca, 0x0fdb00cf,
-	0x01770fcc, 0x0fd800e5, 0x01620fce, 0x0fd400fc,
-	0x014d0fcf, 0x0fcf0115, 0x01350fd3, 0x0fcd012b,
-	0x011d0fd6, 0x0fca0143, 0x01050fd9, 0x0fc8015a,
-	0x00ec0fde, 0x0fc60170, 0x00d30fe2, 0x0fc60185,
-	0x00bb0fe5, 0x0fc5019b, 0x00a30fea, 0x0fc501ae,
-	0x008c0fed, 0x0fc601c1, 0x00740ff2, 0x0fc901d1,
-	0x005e0ff5, 0x0fce01df, 0x004b0ff8, 0x0fd301ea,
-	0x00370ffc, 0x0fda01f3, 0x00260ffd, 0x0fe201fb,
-	0x00170000, 0x0fea01ff, 0x00090000, 0x0ff50202,
-	0x02000000, 0x00000000, 0x02010ff7, 0x00000008,
-	0x01ff0fee, 0x00000013, 0x01fb0fe7, 0x0ffe0020,
-	0x01f60fe0, 0x0ffc002e, 0x01ed0fda, 0x0ffa003f,
-	0x01e40fd6, 0x0ff7004f, 0x01d80fd2, 0x0ff40062,
-	0x01ca0fcf, 0x0ff00077, 0x01bb0fcd, 0x0fed008b,
-	0x01a90fcd, 0x0fe900a1, 0x01960fcd, 0x0fe600b7,
-	0x01830fcd, 0x0fe200ce, 0x016d0fcf, 0x0fde00e6,
-	0x01580fd0, 0x0fdb00fd, 0x01410fd3, 0x0fd80114,
-	0x012c0fd4, 0x0fd4012c, 0x01140fd8, 0x0fd30141,
-	0x00fd0fdb, 0x0fd00158, 0x00e60fde, 0x0fcf016d,
-	0x00ce0fe2, 0x0fcd0183, 0x00b70fe6, 0x0fcd0196,
-	0x00a10fe9, 0x0fcd01a9, 0x008b0fed, 0x0fcd01bb,
-	0x00770ff0, 0x0fcf01ca, 0x00620ff4, 0x0fd201d8,
-	0x004f0ff7, 0x0fd601e4, 0x003f0ffa, 0x0fda01ed,
-	0x002e0ffc, 0x0fe001f6, 0x00200ffe, 0x0fe701fb,
-	0x00130000, 0x0fee01ff, 0x00080000, 0x0ff70201,
-	0x02000000, 0x00000000, 0x01ff0ff7, 0x0000000a,
-	0x01f90fee, 0x00000019, 0x01f10fe7, 0x0ffe002a,
-	0x01e60fe1, 0x0ffd003c, 0x01d90fdc, 0x0ffa0051,
-	0x01cc0fd8, 0x0ff70065, 0x01bb0fd5, 0x0ff5007b,
-	0x01a80fd3, 0x0ff10094, 0x01950fd2, 0x0fef00aa,
-	0x01800fd2, 0x0feb00c3, 0x016a0fd3, 0x0fe900da,
-	0x01540fd3, 0x0fe600f3, 0x013f0fd5, 0x0fe2010a,
-	0x01280fd7, 0x0fe00121, 0x01100fda, 0x0fde0138,
-	0x00fb0fdb, 0x0fdb014f, 0x00e40fdf, 0x0fdb0162,
-	0x00ce0fe2, 0x0fd90177, 0x00b90fe4, 0x0fd8018b,
-	0x00a50fe8, 0x0fd8019b, 0x00910fec, 0x0fd801ab,
-	0x007e0fee, 0x0fd801bc, 0x006c0ff2, 0x0fd901c9,
-	0x005c0ff4, 0x0fda01d6, 0x004b0ff7, 0x0fdd01e1,
-	0x003c0ff9, 0x0fe001eb, 0x002f0ffb, 0x0fe401f2,
-	0x00230ffd, 0x0fe801f8, 0x00180ffe, 0x0fed01fd,
-	0x000e0000, 0x0ff20200, 0x00060000, 0x0ff90201,
-	0x02000000, 0x00000000, 0x02030ff9, 0x00000004,
-	0x02050ff2, 0x00000009, 0x02050fed, 0x0ffe0010,
-	0x02040fe7, 0x0ffd0018, 0x02020fe3, 0x0ffb0020,
-	0x01fe0fdf, 0x0ff9002a, 0x01fa0fdb, 0x0ff70034,
-	0x01f40fd8, 0x0ff30041, 0x01ed0fd6, 0x0ff0004d,
-	0x01e30fd5, 0x0fec005c, 0x01d80fd4, 0x0fea006a,
-	0x01cd0fd3, 0x0fe5007b, 0x01c00fd3, 0x0fe1008c,
-	0x01b10fd3, 0x0fdd009f, 0x01a10fd4, 0x0fd900b2,
-	0x01900fd4, 0x0fd400c8, 0x017b0fd7, 0x0fd100dd,
-	0x01660fd9, 0x0fcd00f4, 0x01500fda, 0x0fca010c,
-	0x01380fde, 0x0fc60124, 0x011e0fe2, 0x0fc5013b,
-	0x01040fe4, 0x0fc30155, 0x00e70fe8, 0x0fc10170,
-	0x00cc0feb, 0x0fc10188, 0x00ad0ff0, 0x0fc301a0,
-	0x00900ff4, 0x0fc701b5, 0x00750ff7, 0x0fcc01c8,
-	0x00580ffb, 0x0fd201db, 0x003e0ffd, 0x0fdb01ea,
-	0x00250000, 0x0fe501f6, 0x000f0000, 0x0ff301fe,
-	0x02000000, 0x00000000, 0x02020ff9, 0x00000005,
-	0x02020ff2, 0x0000000c, 0x02010fed, 0x0ffe0014,
-	0x01fe0fe8, 0x0ffd001d, 0x01fa0fe3, 0x0ffb0028,
-	0x01f40fe0, 0x0ff90033, 0x01ed0fdc, 0x0ff70040,
-	0x01e50fd9, 0x0ff3004f, 0x01db0fd7, 0x0ff1005d,
-	0x01ce0fd7, 0x0fed006e, 0x01c00fd6, 0x0feb007f,
-	0x01b30fd5, 0x0fe70091, 0x01a30fd6, 0x0fe300a4,
-	0x01920fd6, 0x0fe000b8, 0x017e0fd8, 0x0fdd00cd,
-	0x016c0fd8, 0x0fd800e4, 0x01560fdb, 0x0fd600f9,
-	0x01400fdd, 0x0fd20111, 0x01290fdf, 0x0fd00128,
-	0x01110fe2, 0x0fce013f, 0x00f80fe6, 0x0fcd0155,
-	0x00de0fe8, 0x0fcc016e, 0x00c40fec, 0x0fcb0185,
-	0x00ab0fef, 0x0fcb019b, 0x00900ff3, 0x0fcd01b0,
-	0x00770ff6, 0x0fd101c2, 0x005f0ff9, 0x0fd501d3,
-	0x00470ffc, 0x0fdb01e2, 0x00320ffd, 0x0fe201ef,
-	0x001e0000, 0x0fea01f8, 0x000c0000, 0x0ff501ff,
-	0x02000000, 0x00000000, 0x02010ff9, 0x00000006,
-	0x02000ff2, 0x0000000e, 0x01fd0fed, 0x0ffe0018,
-	0x01f80fe8, 0x0ffd0023, 0x01f20fe4, 0x0ffb002f,
-	0x01eb0fe0, 0x0ff9003c, 0x01e10fdd, 0x0ff7004b,
-	0x01d60fda, 0x0ff4005c, 0x01c90fd9, 0x0ff2006c,
-	0x01bc0fd8, 0x0fee007e, 0x01ab0fd8, 0x0fec0091,
-	0x019b0fd8, 0x0fe800a5, 0x018b0fd8, 0x0fe400b9,
-	0x01770fd9, 0x0fe200ce, 0x01620fdb, 0x0fdf00e4,
-	0x014f0fdb, 0x0fdb00fb, 0x01380fde, 0x0fda0110,
-	0x01210fe0, 0x0fd70128, 0x010a0fe2, 0x0fd5013f,
-	0x00f30fe6, 0x0fd30154, 0x00da0fe9, 0x0fd3016a,
-	0x00c30feb, 0x0fd20180, 0x00aa0fef, 0x0fd20195,
-	0x00940ff1, 0x0fd301a8, 0x007b0ff5, 0x0fd501bb,
-	0x00650ff7, 0x0fd801cc, 0x00510ffa, 0x0fdc01d9,
-	0x003c0ffd, 0x0fe101e6, 0x002a0ffe, 0x0fe701f1,
-	0x00190000, 0x0fee01f9, 0x000a0000, 0x0ff701ff,
-	0x02000000, 0x00000000, 0x01ff0ff9, 0x00000008,
-	0x01fb0ff2, 0x00000013, 0x01f50fed, 0x0ffe0020,
-	0x01ed0fe8, 0x0ffd002e, 0x01e30fe4, 0x0ffb003e,
-	0x01d80fe1, 0x0ff9004e, 0x01cb0fde, 0x0ff70060,
-	0x01bc0fdc, 0x0ff40074, 0x01ac0fdb, 0x0ff20087,
-	0x019a0fdb, 0x0fef009c, 0x01870fdb, 0x0fed00b1,
-	0x01740fdb, 0x0fea00c7, 0x01600fdc, 0x0fe700dd,
-	0x014b0fdd, 0x0fe500f3, 0x01350fdf, 0x0fe30109,
-	0x01200fe0, 0x0fe00120, 0x01090fe3, 0x0fdf0135,
-	0x00f30fe5, 0x0fdd014b, 0x00dd0fe7, 0x0fdc0160,
-	0x00c70fea, 0x0fdb0174, 0x00b10fed, 0x0fdb0187,
-	0x009c0fef, 0x0fdb019a, 0x00870ff2, 0x0fdb01ac,
-	0x00740ff4, 0x0fdc01bc, 0x00600ff7, 0x0fde01cb,
-	0x004e0ff9, 0x0fe101d8, 0x003e0ffb, 0x0fe401e3,
-	0x002e0ffd, 0x0fe801ed, 0x00200ffe, 0x0fed01f5,
-	0x00130000, 0x0ff201fb, 0x00080000, 0x0ff901ff,
-	0x02000000, 0x00000000, 0x02060ff2, 0x00000008,
-	0x02090fe4, 0x00000013, 0x020a0fd9, 0x0ffc0021,
-	0x02080fce, 0x0ffa0030, 0x02030fc5, 0x0ff60042,
-	0x01fd0fbe, 0x0ff10054, 0x01f50fb6, 0x0fed0068,
-	0x01e90fb1, 0x0fe60080, 0x01dc0fae, 0x0fe10095,
-	0x01ca0fae, 0x0fda00ae, 0x01b70fad, 0x0fd600c6,
-	0x01a40fad, 0x0fcf00e0, 0x018f0faf, 0x0fc800fa,
-	0x01780fb1, 0x0fc30114, 0x015f0fb5, 0x0fbf012d,
-	0x01490fb7, 0x0fb70149, 0x012d0fbf, 0x0fb5015f,
-	0x01140fc3, 0x0fb10178, 0x00fa0fc8, 0x0faf018f,
-	0x00e00fcf, 0x0fad01a4, 0x00c60fd6, 0x0fad01b7,
-	0x00ae0fda, 0x0fae01ca, 0x00950fe1, 0x0fae01dc,
-	0x00800fe6, 0x0fb101e9, 0x00680fed, 0x0fb601f5,
-	0x00540ff1, 0x0fbe01fd, 0x00420ff6, 0x0fc50203,
-	0x00300ffa, 0x0fce0208, 0x00210ffc, 0x0fd9020a,
-	0x00130000, 0x0fe40209, 0x00080000, 0x0ff20206,
-	0x02000000, 0x00000000, 0x02040ff2, 0x0000000a,
-	0x02040fe4, 0x00000018, 0x02010fda, 0x0ffc0029,
-	0x01fc0fcf, 0x0ffa003b, 0x01f30fc7, 0x0ff60050,
-	0x01e90fc0, 0x0ff20065, 0x01dc0fba, 0x0fee007c,
-	0x01cc0fb6, 0x0fe80096, 0x01ba0fb4, 0x0fe400ae,
-	0x01a70fb4, 0x0fdd00c8, 0x018f0fb5, 0x0fda00e2,
-	0x017a0fb5, 0x0fd400fd, 0x01630fb8, 0x0fce0117,
-	0x014c0fba, 0x0fca0130, 0x01320fbf, 0x0fc70148,
-	0x011b0fc1, 0x0fc10163, 0x01010fc8, 0x0fc00177,
-	0x00e90fcd, 0x0fbd018d, 0x00d10fd1, 0x0fbc01a2,
-	0x00ba0fd7, 0x0fbb01b4, 0x00a30fdd, 0x0fbc01c4,
-	0x008e0fe1, 0x0fbd01d4, 0x00790fe7, 0x0fbe01e2,
-	0x00670feb, 0x0fc001ee, 0x00540ff1, 0x0fc501f6,
-	0x00430ff4, 0x0fcb01fe, 0x00340ff8, 0x0fd10203,
-	0x00260ffb, 0x0fd80207, 0x001a0ffd, 0x0fe10208,
-	0x000f0000, 0x0fea0207, 0x00060000, 0x0ff50205,
-	0x02000000, 0x00000000, 0x02020ff2, 0x0000000c,
-	0x02000fe4, 0x0000001c, 0x01fa0fda, 0x0ffc0030,
-	0x01f10fd0, 0x0ffa0045, 0x01e50fc8, 0x0ff6005d,
-	0x01d60fc3, 0x0ff30074, 0x01c60fbd, 0x0fef008e,
-	0x01b30fba, 0x0fe900aa, 0x019e0fb9, 0x0fe500c4,
-	0x01870fba, 0x0fe000df, 0x016f0fbb, 0x0fdd00f9,
-	0x01580fbc, 0x0fd80114, 0x01400fbf, 0x0fd3012e,
-	0x01280fc2, 0x0fd00146, 0x010f0fc6, 0x0fce015d,
-	0x00f90fc9, 0x0fc90175, 0x00e00fcf, 0x0fc90188,
-	0x00ca0fd4, 0x0fc6019c, 0x00b40fd8, 0x0fc601ae,
-	0x009f0fdd, 0x0fc501bf, 0x008b0fe3, 0x0fc601cc,
-	0x00780fe6, 0x0fc701db, 0x00660feb, 0x0fc801e7,
-	0x00560fef, 0x0fcb01f0, 0x00460ff3, 0x0fcf01f8,
-	0x00380ff6, 0x0fd401fe, 0x002c0ff9, 0x0fd90202,
-	0x00200ffc, 0x0fdf0205, 0x00160ffe, 0x0fe60206,
-	0x000c0000, 0x0fed0207, 0x00050000, 0x0ff70204,
-	0x02000000, 0x00000000, 0x01fe0ff3, 0x0000000f,
-	0x01f60fe5, 0x00000025, 0x01ea0fdb, 0x0ffd003e,
-	0x01db0fd2, 0x0ffb0058, 0x01c80fcc, 0x0ff70075,
-	0x01b50fc7, 0x0ff40090, 0x01a00fc3, 0x0ff000ad,
-	0x01880fc1, 0x0feb00cc, 0x01700fc1, 0x0fe800e7,
-	0x01550fc3, 0x0fe40104, 0x013b0fc5, 0x0fe2011e,
-	0x01240fc6, 0x0fde0138, 0x010c0fca, 0x0fda0150,
-	0x00f40fcd, 0x0fd90166, 0x00dd0fd1, 0x0fd7017b,
-	0x00c80fd4, 0x0fd40190, 0x00b20fd9, 0x0fd401a1,
-	0x009f0fdd, 0x0fd301b1, 0x008c0fe1, 0x0fd301c0,
-	0x007b0fe5, 0x0fd301cd, 0x006a0fea, 0x0fd401d8,
-	0x005c0fec, 0x0fd501e3, 0x004d0ff0, 0x0fd601ed,
-	0x00410ff3, 0x0fd801f4, 0x00340ff7, 0x0fdb01fa,
-	0x002a0ff9, 0x0fdf01fe, 0x00200ffb, 0x0fe30202,
-	0x00180ffd, 0x0fe70204, 0x00100ffe, 0x0fed0205,
-	0x00090000, 0x0ff20205, 0x00040000, 0x0ff90203,
-	0x02000000, 0x00000000, 0x02050ff5, 0x00000006,
-	0x02070fea, 0x0000000f, 0x02080fe1, 0x0ffd001a,
-	0x02070fd8, 0x0ffb0026, 0x02030fd1, 0x0ff80034,
-	0x01fe0fcb, 0x0ff40043, 0x01f60fc5, 0x0ff10054,
-	0x01ee0fc0, 0x0feb0067, 0x01e20fbe, 0x0fe70079,
-	0x01d40fbd, 0x0fe1008e, 0x01c40fbc, 0x0fdd00a3,
-	0x01b40fbb, 0x0fd700ba, 0x01a20fbc, 0x0fd100d1,
-	0x018d0fbd, 0x0fcd00e9, 0x01770fc0, 0x0fc80101,
-	0x01630fc1, 0x0fc1011b, 0x01480fc7, 0x0fbf0132,
-	0x01300fca, 0x0fba014c, 0x01170fce, 0x0fb80163,
-	0x00fd0fd4, 0x0fb5017a, 0x00e20fda, 0x0fb5018f,
-	0x00c80fdd, 0x0fb401a7, 0x00ae0fe4, 0x0fb401ba,
-	0x00960fe8, 0x0fb601cc, 0x007c0fee, 0x0fba01dc,
-	0x00650ff2, 0x0fc001e9, 0x00500ff6, 0x0fc701f3,
-	0x003b0ffa, 0x0fcf01fc, 0x00290ffc, 0x0fda0201,
-	0x00180000, 0x0fe40204, 0x000a0000, 0x0ff20204,
-	0x02000000, 0x00000000, 0x02030ff5, 0x00000008,
-	0x02030fea, 0x00000013, 0x02020fe1, 0x0ffd0020,
-	0x01fc0fd9, 0x0ffc002f, 0x01f60fd2, 0x0ff80040,
-	0x01ed0fcd, 0x0ff50051, 0x01e30fc7, 0x0ff10065,
-	0x01d70fc3, 0x0fec007a, 0x01c60fc2, 0x0fe9008f,
-	0x01b60fc1, 0x0fe300a6, 0x01a20fc1, 0x0fe000bd,
-	0x018f0fc1, 0x0fdb00d5, 0x017b0fc2, 0x0fd500ee,
-	0x01640fc4, 0x0fd20106, 0x014d0fc8, 0x0fce011d,
-	0x01370fc9, 0x0fc90137, 0x011d0fce, 0x0fc8014d,
-	0x01060fd2, 0x0fc40164, 0x00ee0fd5, 0x0fc2017b,
-	0x00d50fdb, 0x0fc1018f, 0x00bd0fe0, 0x0fc101a2,
-	0x00a60fe3, 0x0fc101b6, 0x008f0fe9, 0x0fc201c6,
-	0x007a0fec, 0x0fc301d7, 0x00650ff1, 0x0fc701e3,
-	0x00510ff5, 0x0fcd01ed, 0x00400ff8, 0x0fd201f6,
-	0x002f0ffc, 0x0fd901fc, 0x00200ffd, 0x0fe10202,
-	0x00130000, 0x0fea0203, 0x00080000, 0x0ff50203,
-	0x02000000, 0x00000000, 0x02020ff5, 0x00000009,
-	0x01ff0fea, 0x00000017, 0x01fb0fe2, 0x0ffd0026,
-	0x01f30fda, 0x0ffc0037, 0x01ea0fd3, 0x0ff8004b,
-	0x01df0fce, 0x0ff5005e, 0x01d10fc9, 0x0ff20074,
-	0x01c10fc6, 0x0fed008c, 0x01ae0fc5, 0x0fea00a3,
-	0x019b0fc5, 0x0fe500bb, 0x01850fc6, 0x0fe200d3,
-	0x01700fc6, 0x0fde00ec, 0x015a0fc8, 0x0fd90105,
-	0x01430fca, 0x0fd6011d, 0x012b0fcd, 0x0fd30135,
-	0x01150fcf, 0x0fcf014d, 0x00fc0fd4, 0x0fce0162,
-	0x00e50fd8, 0x0fcc0177, 0x00cf0fdb, 0x0fca018c,
-	0x00b80fe0, 0x0fc9019f, 0x00a20fe5, 0x0fca01af,
-	0x008e0fe8, 0x0fcb01bf, 0x00790fec, 0x0fcb01d0,
-	0x00670fef, 0x0fcd01dd, 0x00550ff4, 0x0fd001e7,
-	0x00440ff7, 0x0fd501f0, 0x00350ffa, 0x0fda01f7,
-	0x00270ffc, 0x0fdf01fe, 0x001b0ffe, 0x0fe70200,
-	0x00100000, 0x0fee0202, 0x00060000, 0x0ff70203,
-	0x02000000, 0x00000000, 0x01ff0ff5, 0x0000000c,
-	0x01f80fea, 0x0000001e, 0x01ef0fe2, 0x0ffd0032,
-	0x01e20fdb, 0x0ffc0047, 0x01d30fd5, 0x0ff9005f,
-	0x01c20fd1, 0x0ff60077, 0x01b00fcd, 0x0ff30090,
-	0x019b0fcb, 0x0fef00ab, 0x01850fcb, 0x0fec00c4,
-	0x016e0fcc, 0x0fe800de, 0x01550fcd, 0x0fe600f8,
-	0x013f0fce, 0x0fe20111, 0x01280fd0, 0x0fdf0129,
-	0x01110fd2, 0x0fdd0140, 0x00f90fd6, 0x0fdb0156,
-	0x00e40fd8, 0x0fd8016c, 0x00cd0fdd, 0x0fd8017e,
-	0x00b80fe0, 0x0fd60192, 0x00a40fe3, 0x0fd601a3,
-	0x00910fe7, 0x0fd501b3, 0x007f0feb, 0x0fd601c0,
-	0x006e0fed, 0x0fd701ce, 0x005d0ff1, 0x0fd701db,
-	0x004f0ff3, 0x0fd901e5, 0x00400ff7, 0x0fdc01ed,
-	0x00330ff9, 0x0fe001f4, 0x00280ffb, 0x0fe301fa,
-	0x001d0ffd, 0x0fe801fe, 0x00140ffe, 0x0fed0201,
-	0x000c0000, 0x0ff20202, 0x00050000, 0x0ff90202,
-	0x02000000, 0x00000000, 0x02040ff7, 0x00000005,
-	0x02070fed, 0x0000000c, 0x02060fe6, 0x0ffe0016,
-	0x02050fdf, 0x0ffc0020, 0x02020fd9, 0x0ff9002c,
-	0x01fe0fd4, 0x0ff60038, 0x01f80fcf, 0x0ff30046,
-	0x01f00fcb, 0x0fef0056, 0x01e70fc8, 0x0feb0066,
-	0x01db0fc7, 0x0fe60078, 0x01cc0fc6, 0x0fe3008b,
-	0x01bf0fc5, 0x0fdd009f, 0x01ae0fc6, 0x0fd800b4,
-	0x019c0fc6, 0x0fd400ca, 0x01880fc9, 0x0fcf00e0,
-	0x01750fc9, 0x0fc900f9, 0x015d0fce, 0x0fc6010f,
-	0x01460fd0, 0x0fc20128, 0x012e0fd3, 0x0fbf0140,
-	0x01140fd8, 0x0fbc0158, 0x00f90fdd, 0x0fbb016f,
-	0x00df0fe0, 0x0fba0187, 0x00c40fe5, 0x0fb9019e,
-	0x00aa0fe9, 0x0fba01b3, 0x008e0fef, 0x0fbd01c6,
-	0x00740ff3, 0x0fc301d6, 0x005d0ff6, 0x0fc801e5,
-	0x00450ffa, 0x0fd001f1, 0x00300ffc, 0x0fda01fa,
-	0x001c0000, 0x0fe40200, 0x000c0000, 0x0ff20202,
-	0x02000000, 0x00000000, 0x02030ff7, 0x00000006,
-	0x02020fee, 0x00000010, 0x02000fe7, 0x0ffe001b,
-	0x01fe0fdf, 0x0ffc0027, 0x01f70fda, 0x0ffa0035,
-	0x01f00fd5, 0x0ff70044, 0x01e70fd0, 0x0ff40055,
-	0x01dd0fcd, 0x0fef0067, 0x01d00fcb, 0x0fec0079,
-	0x01bf0fcb, 0x0fe8008e, 0x01af0fca, 0x0fe500a2,
-	0x019f0fc9, 0x0fe000b8, 0x018c0fca, 0x0fdb00cf,
-	0x01770fcc, 0x0fd800e5, 0x01620fce, 0x0fd400fc,
-	0x014d0fcf, 0x0fcf0115, 0x01350fd3, 0x0fcd012b,
-	0x011d0fd6, 0x0fca0143, 0x01050fd9, 0x0fc8015a,
-	0x00ec0fde, 0x0fc60170, 0x00d30fe2, 0x0fc60185,
-	0x00bb0fe5, 0x0fc5019b, 0x00a30fea, 0x0fc501ae,
-	0x008c0fed, 0x0fc601c1, 0x00740ff2, 0x0fc901d1,
-	0x005e0ff5, 0x0fce01df, 0x004b0ff8, 0x0fd301ea,
-	0x00370ffc, 0x0fda01f3, 0x00260ffd, 0x0fe201fb,
-	0x00170000, 0x0fea01ff, 0x00090000, 0x0ff50202,
-	0x02000000, 0x00000000, 0x02010ff7, 0x00000008,
-	0x01ff0fee, 0x00000013, 0x01fb0fe7, 0x0ffe0020,
-	0x01f60fe0, 0x0ffc002e, 0x01ed0fda, 0x0ffa003f,
-	0x01e40fd6, 0x0ff7004f, 0x01d80fd2, 0x0ff40062,
-	0x01ca0fcf, 0x0ff00077, 0x01bb0fcd, 0x0fed008b,
-	0x01a90fcd, 0x0fe900a1, 0x01960fcd, 0x0fe600b7,
-	0x01830fcd, 0x0fe200ce, 0x016d0fcf, 0x0fde00e6,
-	0x01580fd0, 0x0fdb00fd, 0x01410fd3, 0x0fd80114,
-	0x012c0fd4, 0x0fd4012c, 0x01140fd8, 0x0fd30141,
-	0x00fd0fdb, 0x0fd00158, 0x00e60fde, 0x0fcf016d,
-	0x00ce0fe2, 0x0fcd0183, 0x00b70fe6, 0x0fcd0196,
-	0x00a10fe9, 0x0fcd01a9, 0x008b0fed, 0x0fcd01bb,
-	0x00770ff0, 0x0fcf01ca, 0x00620ff4, 0x0fd201d8,
-	0x004f0ff7, 0x0fd601e4, 0x003f0ffa, 0x0fda01ed,
-	0x002e0ffc, 0x0fe001f6, 0x00200ffe, 0x0fe701fb,
-	0x00130000, 0x0fee01ff, 0x00080000, 0x0ff70201,
-	0x02000000, 0x00000000, 0x01ff0ff7, 0x0000000a,
-	0x01f90fee, 0x00000019, 0x01f10fe7, 0x0ffe002a,
-	0x01e60fe1, 0x0ffd003c, 0x01d90fdc, 0x0ffa0051,
-	0x01cc0fd8, 0x0ff70065, 0x01bb0fd5, 0x0ff5007b,
-	0x01a80fd3, 0x0ff10094, 0x01950fd2, 0x0fef00aa,
-	0x01800fd2, 0x0feb00c3, 0x016a0fd3, 0x0fe900da,
-	0x01540fd3, 0x0fe600f3, 0x013f0fd5, 0x0fe2010a,
-	0x01280fd7, 0x0fe00121, 0x01100fda, 0x0fde0138,
-	0x00fb0fdb, 0x0fdb014f, 0x00e40fdf, 0x0fdb0162,
-	0x00ce0fe2, 0x0fd90177, 0x00b90fe4, 0x0fd8018b,
-	0x00a50fe8, 0x0fd8019b, 0x00910fec, 0x0fd801ab,
-	0x007e0fee, 0x0fd801bc, 0x006c0ff2, 0x0fd901c9,
-	0x005c0ff4, 0x0fda01d6, 0x004b0ff7, 0x0fdd01e1,
-	0x003c0ff9, 0x0fe001eb, 0x002f0ffb, 0x0fe401f2,
-	0x00230ffd, 0x0fe801f8, 0x00180ffe, 0x0fed01fd,
-	0x000e0000, 0x0ff20200, 0x00060000, 0x0ff90201,
-	0x02000000, 0x00000000, 0x02030ff9, 0x00000004,
-	0x02050ff2, 0x00000009, 0x02050fed, 0x0ffe0010,
-	0x02040fe7, 0x0ffd0018, 0x02020fe3, 0x0ffb0020,
-	0x01fe0fdf, 0x0ff9002a, 0x01fa0fdb, 0x0ff70034,
-	0x01f40fd8, 0x0ff30041, 0x01ed0fd6, 0x0ff0004d,
-	0x01e30fd5, 0x0fec005c, 0x01d80fd4, 0x0fea006a,
-	0x01cd0fd3, 0x0fe5007b, 0x01c00fd3, 0x0fe1008c,
-	0x01b10fd3, 0x0fdd009f, 0x01a10fd4, 0x0fd900b2,
-	0x01900fd4, 0x0fd400c8, 0x017b0fd7, 0x0fd100dd,
-	0x01660fd9, 0x0fcd00f4, 0x01500fda, 0x0fca010c,
-	0x01380fde, 0x0fc60124, 0x011e0fe2, 0x0fc5013b,
-	0x01040fe4, 0x0fc30155, 0x00e70fe8, 0x0fc10170,
-	0x00cc0feb, 0x0fc10188, 0x00ad0ff0, 0x0fc301a0,
-	0x00900ff4, 0x0fc701b5, 0x00750ff7, 0x0fcc01c8,
-	0x00580ffb, 0x0fd201db, 0x003e0ffd, 0x0fdb01ea,
-	0x00250000, 0x0fe501f6, 0x000f0000, 0x0ff301fe,
-	0x02000000, 0x00000000, 0x02020ff9, 0x00000005,
-	0x02020ff2, 0x0000000c, 0x02010fed, 0x0ffe0014,
-	0x01fe0fe8, 0x0ffd001d, 0x01fa0fe3, 0x0ffb0028,
-	0x01f40fe0, 0x0ff90033, 0x01ed0fdc, 0x0ff70040,
-	0x01e50fd9, 0x0ff3004f, 0x01db0fd7, 0x0ff1005d,
-	0x01ce0fd7, 0x0fed006e, 0x01c00fd6, 0x0feb007f,
-	0x01b30fd5, 0x0fe70091, 0x01a30fd6, 0x0fe300a4,
-	0x01920fd6, 0x0fe000b8, 0x017e0fd8, 0x0fdd00cd,
-	0x016c0fd8, 0x0fd800e4, 0x01560fdb, 0x0fd600f9,
-	0x01400fdd, 0x0fd20111, 0x01290fdf, 0x0fd00128,
-	0x01110fe2, 0x0fce013f, 0x00f80fe6, 0x0fcd0155,
-	0x00de0fe8, 0x0fcc016e, 0x00c40fec, 0x0fcb0185,
-	0x00ab0fef, 0x0fcb019b, 0x00900ff3, 0x0fcd01b0,
-	0x00770ff6, 0x0fd101c2, 0x005f0ff9, 0x0fd501d3,
-	0x00470ffc, 0x0fdb01e2, 0x00320ffd, 0x0fe201ef,
-	0x001e0000, 0x0fea01f8, 0x000c0000, 0x0ff501ff,
-	0x02000000, 0x00000000, 0x02010ff9, 0x00000006,
-	0x02000ff2, 0x0000000e, 0x01fd0fed, 0x0ffe0018,
-	0x01f80fe8, 0x0ffd0023, 0x01f20fe4, 0x0ffb002f,
-	0x01eb0fe0, 0x0ff9003c, 0x01e10fdd, 0x0ff7004b,
-	0x01d60fda, 0x0ff4005c, 0x01c90fd9, 0x0ff2006c,
-	0x01bc0fd8, 0x0fee007e, 0x01ab0fd8, 0x0fec0091,
-	0x019b0fd8, 0x0fe800a5, 0x018b0fd8, 0x0fe400b9,
-	0x01770fd9, 0x0fe200ce, 0x01620fdb, 0x0fdf00e4,
-	0x014f0fdb, 0x0fdb00fb, 0x01380fde, 0x0fda0110,
-	0x01210fe0, 0x0fd70128, 0x010a0fe2, 0x0fd5013f,
-	0x00f30fe6, 0x0fd30154, 0x00da0fe9, 0x0fd3016a,
-	0x00c30feb, 0x0fd20180, 0x00aa0fef, 0x0fd20195,
-	0x00940ff1, 0x0fd301a8, 0x007b0ff5, 0x0fd501bb,
-	0x00650ff7, 0x0fd801cc, 0x00510ffa, 0x0fdc01d9,
-	0x003c0ffd, 0x0fe101e6, 0x002a0ffe, 0x0fe701f1,
-	0x00190000, 0x0fee01f9, 0x000a0000, 0x0ff701ff,
-	0x02000000, 0x00000000, 0x01ff0ff9, 0x00000008,
-	0x01fb0ff2, 0x00000013, 0x01f50fed, 0x0ffe0020,
-	0x01ed0fe8, 0x0ffd002e, 0x01e30fe4, 0x0ffb003e,
-	0x01d80fe1, 0x0ff9004e, 0x01cb0fde, 0x0ff70060,
-	0x01bc0fdc, 0x0ff40074, 0x01ac0fdb, 0x0ff20087,
-	0x019a0fdb, 0x0fef009c, 0x01870fdb, 0x0fed00b1,
-	0x01740fdb, 0x0fea00c7, 0x01600fdc, 0x0fe700dd,
-	0x014b0fdd, 0x0fe500f3, 0x01350fdf, 0x0fe30109,
-	0x01200fe0, 0x0fe00120, 0x01090fe3, 0x0fdf0135,
-	0x00f30fe5, 0x0fdd014b, 0x00dd0fe7, 0x0fdc0160,
-	0x00c70fea, 0x0fdb0174, 0x00b10fed, 0x0fdb0187,
-	0x009c0fef, 0x0fdb019a, 0x00870ff2, 0x0fdb01ac,
-	0x00740ff4, 0x0fdc01bc, 0x00600ff7, 0x0fde01cb,
-	0x004e0ff9, 0x0fe101d8, 0x003e0ffb, 0x0fe401e3,
-	0x002e0ffd, 0x0fe801ed, 0x00200ffe, 0x0fed01f5,
-	0x00130000, 0x0ff201fb, 0x00080000, 0x0ff901ff
-};
-
-
-
-#if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_MAGNA_OLED_VIDEO_QHD_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT)
-static uint32 vg_qseed_table2_DMB[] = {
 	0x02000000, 0x00000000, 0x01ff0ff9, 0x00000008,
 	0x01fb0ff2, 0x00000013, 0x01f50fed, 0x0ffe0020,
 	0x01ed0fe8, 0x0ffd002e, 0x01e30fe4, 0x0ffb003e,
@@ -1644,7 +1120,8 @@
 	0x0fb20fee, 0x0f46031a, 0x0f980ff3, 0x0f4b032a,
 	0x0f800ffa, 0x0f4f0337, 0x0f6d0ffe, 0x0f57033e
 };
-#endif
+
+
 #define MDP4_QSEED_TABLE0_OFF 0x8100
 #define MDP4_QSEED_TABLE1_OFF 0x8200
 #define MDP4_QSEED_TABLE2_OFF 0x9000
@@ -1699,75 +1176,6 @@
 
 }
 
-#if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_CMD_QHD_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_MAGNA_OLED_VIDEO_QHD_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT)
-void mdp4_vg_qseed_init_VideoPlay(int vp_num)
-{
-	uint32 *off;
-	int i, voff;
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-
-	voff = MDP4_VIDEO_OFF * vp_num;
-
-	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
-						MDP4_QSEED_TABLE1_OFF);
-	for (i = 0; i < (sizeof(vg_qseed_table1) / sizeof(uint32)); i++) {
-		outpdw(off, vg_qseed_table1[i]);
-		off++;
-		if (!((uint32)off & 0x3FF))
-			wmb();
-	}
-
-	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
-						MDP4_QSEED_TABLE2_OFF);
-	for (i = 0; i < (sizeof(vg_qseed_table2) / sizeof(uint32)); i++) {
-		outpdw(off, vg_qseed_table2[i]);
-		off++;
-		if (!((uint32)off & 0x3FF))
-			wmb();
-	}
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-
-}
-
-void mdp4_vg_qseed_init_DMB(int vp_num)
-{
-	uint32 *off;
-	int i, voff;
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
-
-	voff = MDP4_VIDEO_OFF * vp_num;
-
-	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
-						MDP4_QSEED_TABLE1_OFF);
-	for (i = 0; i < (sizeof(vg_qseed_table1) / sizeof(uint32)); i++) {
-		outpdw(off, vg_qseed_table1[i]);
-		off++;
-		if (!((uint32)off & 0x3FF))
-			wmb();
-	}
-
-	off = (uint32 *)(MDP_BASE + MDP4_VIDEO_BASE + voff +
-						MDP4_QSEED_TABLE2_OFF);
-	for (i = 0; i < (sizeof(vg_qseed_table2_DMB) / sizeof(uint32)); i++) {
-		outpdw(off, vg_qseed_table2_DMB[i]);
-		off++;
-		if (!((uint32)off & 0x3FF))
-			wmb();
-	}
-
-	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
-
-}
-#endif
-
 void mdp4_mixer_blend_init(mixer_num)
 {
 	unsigned char *overlay_base;
@@ -3149,8 +2557,7 @@
 			if (mdp_iommu_split_domain) {
 				if (ion_map_iommu(mfd->iclient, buf->ihdl,
 					DISPLAY_READ_DOMAIN, GEN_POOL, SZ_4K,
-					buffer_size * 2, &read_addr, &len,
-					0, 0)) {
+					0, &read_addr, &len, 0, 0)) {
 					pr_err("ion_map_iommu() read failed\n");
 					return -ENOMEM;
 				}
@@ -3164,17 +2571,16 @@
 				} else {
 					if (ion_map_iommu(mfd->iclient,
 						buf->ihdl, DISPLAY_WRITE_DOMAIN,
-						GEN_POOL, SZ_4K,
-						buffer_size * 2, &addr, &len,
+						GEN_POOL, SZ_4K, 0, &addr, &len,
 						0, 0)) {
-						pr_err("split ion_map_iommu() failed\n");
+						pr_err("ion_map_iommu() failed\n");
 						return -ENOMEM;
 					}
 				}
 			} else {
 				if (ion_map_iommu(mfd->iclient, buf->ihdl,
 					DISPLAY_READ_DOMAIN, GEN_POOL, SZ_4K,
-					buffer_size * 2, &addr, &len, 0, 0)) {
+					0, &addr, &len, 0, 0)) {
 					pr_err("ion_map_iommu() write failed\n");
 					return -ENOMEM;
 				}
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mdp4_video_enhance.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mdp4_video_enhance.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mdp4_video_tuning.h
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_wfd_writeback_panel.c msm/mdp4_wfd_writeback_panel.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp4_wfd_writeback_panel.c	2012-07-16 10:04:32.207489769 -0700
+++ msm/mdp4_wfd_writeback_panel.c	2012-05-19 18:38:37.632909378 -0700
@@ -37,8 +37,8 @@
 static struct msm_fb_panel_data writeback_msm_panel_data = {
 	.panel_info = {
 		.type = WRITEBACK_PANEL,
-		.xres = 1920,
-		.yres = 1080,
+		.xres = 1280,
+		.yres = 720,
 		.pdest = DISPLAY_3,
 		.wait_cycle = 0,
 		.bpp = 24,
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp.c msm/mdp.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp.c	2012-08-13 16:39:47.800233556 -0700
+++ msm/mdp.c	2012-08-14 12:32:48.899338839 -0700
@@ -50,10 +50,9 @@
 static struct clk *mdp_lut_clk;
 int mdp_rev;
 int mdp_iommu_split_domain;
-u32 mdp_max_clk = 200000000;
 
 static struct platform_device *mdp_init_pdev;
-static struct regulator *footswitch;
+static struct regulator *footswitch, *hdmi_pll_fs;
 static unsigned int mdp_footswitch_on;
 
 struct completion mdp_ppp_comp;
@@ -146,7 +145,7 @@
 static struct early_suspend early_suspend;
 #endif
 
-static int mdp_irq;
+static u32 mdp_irq;
 
 static uint32 mdp_prim_panel_type = NO_PANEL;
 #ifndef CONFIG_FB_MSM_MDP22
@@ -480,8 +479,7 @@
 }
 
 DEFINE_MUTEX(mdp_lut_push_sem);
-
-int mdp_lut_i;
+static int mdp_lut_i;
 static int mdp_lut_hw_update(struct fb_cmap *cmap)
 {
 	int i;
@@ -512,8 +510,8 @@
 	return 0;
 }
 
-int mdp_lut_push;
-int mdp_lut_push_i;
+static int mdp_lut_push;
+static int mdp_lut_push_i;
 static int mdp_lut_update_nonlcdc(struct fb_info *info, struct fb_cmap *cmap)
 {
 	int ret;
@@ -677,6 +675,7 @@
 		goto error_extra;
 
 	INIT_WORK(&mgmt->mdp_histogram_worker, mdp_hist_read_work);
+	mgmt->hist = NULL;
 
 	mdp_hist_mgmt_array[index] = mgmt;
 	return 0;
@@ -1326,11 +1325,16 @@
 int mdp_ppp_pipe_wait(void)
 {
 	int ret = 1;
+	boolean wait;
+	unsigned long flag;
 
 	/* wait 5 seconds for the operation to complete before declaring
 	the MDP hung */
+	spin_lock_irqsave(&mdp_spin_lock, flag);
+	wait = mdp_ppp_waiting;
+	spin_unlock_irqrestore(&mdp_spin_lock, flag);
 
-	if (mdp_ppp_waiting == TRUE) {
+	if (wait == TRUE) {
 		ret = wait_for_completion_interruptible_timeout(&mdp_ppp_comp,
 								5 * HZ);
 
@@ -1406,6 +1410,7 @@
 
 void mdp_pipe_kickoff(uint32 term, struct msm_fb_data_type *mfd)
 {
+	unsigned long flag;
 	/* complete all the writes before starting */
 	wmb();
 
@@ -1419,7 +1424,9 @@
 
 		mdp_enable_irq(term);
 		INIT_COMPLETION(mdp_ppp_comp);
+		spin_lock_irqsave(&mdp_spin_lock, flag);
 		mdp_ppp_waiting = TRUE;
+		spin_unlock_irqrestore(&mdp_spin_lock, flag);
 		outpdw(MDP_BASE + 0x30, 0x1000);
 		wait_for_completion_killable(&mdp_ppp_comp);
 		mdp_disable_irq(term);
@@ -1475,9 +1482,11 @@
 		outpdw(MDP_BASE + 0x0004, 0);
 	} else if (term == MDP_OVERLAY1_TERM) {
 		mdp_pipe_ctrl(MDP_OVERLAY1_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+		mdp_lut_enable();
 		outpdw(MDP_BASE + 0x0008, 0);
 	} else if (term == MDP_OVERLAY2_TERM) {
 		mdp_pipe_ctrl(MDP_OVERLAY2_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+		mdp_lut_enable();
 		outpdw(MDP_BASE + 0x00D0, 0);
 	}
 #else
@@ -1922,8 +1931,9 @@
 {
 	int i;
 
-	for (i = 0; i < MDP_MAX_BLOCK; i++)
+	for (i = 0; i < MDP_MAX_BLOCK; i++) {
 		mdp_debug[i] = 0;
+	}
 
 	/* initialize spin lock and workqueue */
 	spin_lock_init(&mdp_spin_lock);
@@ -2077,6 +2087,17 @@
 	return ret;
 }
 
+#ifdef CONFIG_FB_MSM_MDP303
+unsigned is_mdp4_hw_reset(void)
+{
+	return 0;
+}
+void mdp4_hw_init(void)
+{
+	/* empty */
+}
+#endif
+
 static int mdp_on(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -2108,6 +2129,7 @@
 		vsync_cntrl.dev = mfd->fbi->dev;
 
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+
 	ret = panel_next_on(pdev);
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
@@ -2158,6 +2180,33 @@
 				__func__, mdp_hw_revision);
 }
 
+#ifdef CONFIG_FB_MSM_MDP40
+static void configure_mdp_core_clk_table(uint32 min_clk_rate)
+{
+	uint8 count;
+	uint32 current_rate;
+	if (mdp_clk && mdp_pdata && mdp_pdata->mdp_core_clk_table) {
+		min_clk_rate = clk_round_rate(mdp_clk, min_clk_rate);
+		if (clk_set_rate(mdp_clk, min_clk_rate) < 0)
+			printk(KERN_ERR "%s: clk_set_rate failed\n",
+							 __func__);
+		else {
+			count = 0;
+			current_rate = clk_get_rate(mdp_clk);
+			while (count < mdp_pdata->num_mdp_clk) {
+				if (mdp_pdata->mdp_core_clk_table[count]
+						< current_rate) {
+					mdp_pdata->
+					mdp_core_clk_table[count] =
+							current_rate;
+				}
+				count++;
+			}
+		}
+	}
+}
+#endif
+
 #ifdef CONFIG_MSM_BUS_SCALING
 static uint32_t mdp_bus_scale_handle;
 int mdp_bus_scale_update_request(uint32_t index)
@@ -2168,7 +2217,7 @@
 		return -EINVAL;
 	}
 	if (mdp_bus_scale_handle < 1) {
-		printk(KERN_ERR "%s invalid bus handle\n", __func__);
+		pr_debug("%s invalid bus handle\n", __func__);
 		return -EINVAL;
 	}
 	return msm_bus_scale_client_update_request(mdp_bus_scale_handle,
@@ -2176,22 +2225,27 @@
 }
 #endif
 DEFINE_MUTEX(mdp_clk_lock);
-int mdp_set_core_clk(u32 rate)
+int mdp_set_core_clk(uint16 perf_level)
 {
 	int ret = -EINVAL;
-	if (mdp_clk)
-		ret = clk_set_rate(mdp_clk, rate);
-	if (ret)
-		pr_err("%s unable to set mdp clk rate", __func__);
-	else
-		pr_debug("%s mdp clk rate to be set %d: actual rate %ld\n",
-			__func__, rate, clk_get_rate(mdp_clk));
-	return ret;
+	if (mdp_clk && mdp_pdata
+		 && mdp_pdata->mdp_core_clk_table) {
+		if (perf_level > mdp_pdata->num_mdp_clk)
+			printk(KERN_ERR "%s invalid perf level\n", __func__);
+		else {
+			mutex_lock(&mdp_clk_lock);
+			ret = clk_set_rate(mdp_clk,
+				mdp_pdata->
+				mdp_core_clk_table[mdp_pdata->num_mdp_clk
+						 - perf_level]);
+			mutex_unlock(&mdp_clk_lock);
+			if (ret) {
+				printk(KERN_ERR "%s unable to set mdp_core_clk rate\n",
+					__func__);
+			}
 }
-
-int mdp_clk_round_rate(u32 rate)
-{
-	return clk_round_rate(mdp_clk, rate);
+	}
+	return ret;
 }
 
 unsigned long mdp_get_core_clk(void)
@@ -2206,6 +2260,25 @@
 	return clk_rate;
 }
 
+unsigned long mdp_perf_level2clk_rate(uint32 perf_level)
+{
+	unsigned long clk_rate = 0;
+
+	if (mdp_pdata && mdp_pdata->mdp_core_clk_table) {
+		if (perf_level > mdp_pdata->num_mdp_clk) {
+			printk(KERN_ERR "%s invalid perf level\n", __func__);
+			clk_rate = mdp_get_core_clk();
+		} else {
+			clk_rate = mdp_pdata->
+				mdp_core_clk_table[mdp_pdata->num_mdp_clk
+					- perf_level];
+		}
+	} else
+		clk_rate = mdp_get_core_clk();
+
+	return clk_rate;
+}
+
 static int mdp_irq_clk_setup(struct platform_device *pdev,
 	char cont_splashScreen)
 {
@@ -2222,12 +2295,37 @@
 	}
 	disable_irq(mdp_irq);
 
-	footswitch = regulator_get(NULL, "fs_mdp");
-	if (IS_ERR(footswitch))
+	hdmi_pll_fs = regulator_get(&pdev->dev, "hdmi_pll_fs");
+	if (IS_ERR(hdmi_pll_fs)) {
+		hdmi_pll_fs = NULL;
+	} else {
+		if (mdp_rev != MDP_REV_44) {
+			ret = regulator_set_voltage(hdmi_pll_fs, 1800000,
+				1800000);
+			if (ret) {
+				pr_err("set_voltage failed for hdmi_pll_fs, ret=%d\n",
+					ret);
+			}
+		}
+	}
+
+	footswitch = regulator_get(&pdev->dev, "vdd");
+	if (IS_ERR(footswitch)) {
 		footswitch = NULL;
-	else {
+	} else {
+		if (hdmi_pll_fs)
+			regulator_enable(hdmi_pll_fs);
+
 		regulator_enable(footswitch);
 		mdp_footswitch_on = 1;
+
+		if (mdp_rev == MDP_REV_42 && !cont_splashScreen) {
+			regulator_disable(footswitch);
+			msleep(20);
+			regulator_enable(footswitch);
+		}
+		if (hdmi_pll_fs)
+			regulator_disable(hdmi_pll_fs);
 	}
 
 	mdp_clk = clk_get(&pdev->dev, "core_clk");
@@ -2242,7 +2340,7 @@
 	if (IS_ERR(mdp_pclk))
 		mdp_pclk = NULL;
 
-	if (mdp_rev == MDP_REV_42) {
+	if (mdp_rev >= MDP_REV_42) {
 		mdp_lut_clk = clk_get(&pdev->dev, "lut_clk");
 		if (IS_ERR(mdp_lut_clk)) {
 			ret = PTR_ERR(mdp_lut_clk);
@@ -2256,25 +2354,21 @@
 	}
 
 #ifdef CONFIG_FB_MSM_MDP40
-
-	if (mdp_pdata)
-		mdp_max_clk = mdp_pdata->mdp_max_clk;
-	else
-		pr_err("%s cannot get mdp max clk!\n", __func__);
-
-	if (!mdp_max_clk)
-		pr_err("%s mdp max clk is zero!\n", __func__);
-
+	/*
+	 * mdp_clk should greater than mdp_pclk always
+	 */
+	if (mdp_pdata && mdp_pdata->mdp_core_clk_rate) {
 	if (cont_splashScreen)
 		mdp_clk_rate = clk_get_rate(mdp_clk);
 	else
-		mdp_clk_rate = mdp_max_clk;
+			mdp_clk_rate = mdp_pdata->mdp_core_clk_rate;
 
 	mutex_lock(&mdp_clk_lock);
 	clk_set_rate(mdp_clk, mdp_clk_rate);
 	if (mdp_lut_clk != NULL)
 		clk_set_rate(mdp_lut_clk, mdp_clk_rate);
 	mutex_unlock(&mdp_clk_lock);
+	}
 
 	MSM_FB_DEBUG("mdp_clk: mdp_clk=%d\n", (int)clk_get_rate(mdp_clk));
 #endif
@@ -2371,6 +2465,7 @@
 		if (mdp_pdata->cont_splash_enabled) {
 			mfd->cont_splash_done = 0;
 			if (!contSplash_update_done) {
+				if (mfd->panel.type == MIPI_VIDEO_PANEL)
 				mdp_pipe_ctrl(MDP_CMD_BLOCK,
 					MDP_BLOCK_POWER_ON, FALSE);
 				contSplash_update_done = 1;
@@ -2393,6 +2488,8 @@
 		mfd->ov1_wb_buf->size = 0;
 		mfd->mem_hid = 0;
 	}
+	mfd->ov0_blt_state  = 0;
+	mfd->use_ov0_blt = 0 ;
 
 	/* initialize Post Processing data*/
 	mdp_hist_lut_init();
@@ -2448,6 +2545,8 @@
 			mfd->dma = &dma2_data;
 			mfd->lut_update = mdp_lut_update_nonlcdc;
 			mfd->do_histogram = mdp_do_histogram;
+			mfd->start_histogram = mdp_histogram_start;
+			mfd->stop_histogram = mdp_histogram_stop;
 		} else {
 			mfd->dma_fnc = mdp_dma_s_update;
 			mfd->dma = &dma_s_data;
@@ -2489,11 +2588,14 @@
 	case MIPI_VIDEO_PANEL:
 #ifndef CONFIG_FB_MSM_MDP303
 		mipi = &mfd->panel_info.mipi;
+		configure_mdp_core_clk_table((mipi->dsi_pclk_rate) * 23 / 20);
 		mdp4_dsi_vsync_init(0);
 		mfd->hw_refresh = TRUE;
 		mfd->dma_fnc = mdp4_dsi_video_overlay;
 		mfd->lut_update = mdp_lut_update_lcdc;
 		mfd->do_histogram = mdp_do_histogram;
+		mfd->start_histogram = mdp_histogram_start;
+		mfd->stop_histogram = mdp_histogram_stop;
 		if (mfd->panel_info.pdest == DISPLAY_1) {
 			if_no = PRIMARY_INTF_SEL;
 			mfd->dma = &dma2_data;
@@ -2508,6 +2610,8 @@
 		mfd->hw_refresh = TRUE;
 		mfd->dma_fnc = mdp_dsi_video_update;
 		mfd->do_histogram = mdp_do_histogram;
+		mfd->start_histogram = mdp_histogram_start;
+		mfd->stop_histogram = mdp_histogram_stop;
 		mfd->vsync_ctrl = mdp_dma_video_vsync_ctrl;
 		if (mfd->panel_info.pdest == DISPLAY_1)
 			mfd->dma = &dma2_data;
@@ -2528,6 +2632,7 @@
 #ifndef CONFIG_FB_MSM_MDP303
 		mfd->dma_fnc = mdp4_dsi_cmd_overlay;
 		mipi = &mfd->panel_info.mipi;
+		configure_mdp_core_clk_table((mipi->dsi_pclk_rate) * 3 / 2);
 		mdp4_dsi_rdptr_init(0);
 		if (mfd->panel_info.pdest == DISPLAY_1) {
 			if_no = PRIMARY_INTF_SEL;
@@ -2538,6 +2643,8 @@
 		}
 		mfd->lut_update = mdp_lut_update_nonlcdc;
 		mfd->do_histogram = mdp_do_histogram;
+		mfd->start_histogram = mdp_histogram_start;
+		mfd->stop_histogram = mdp_histogram_stop;
 		mdp4_display_intf_sel(if_no, DSI_CMD_INTF);
 
 		mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
@@ -2550,6 +2657,8 @@
 
 		mfd->dma_fnc = mdp_dma2_update;
 		mfd->do_histogram = mdp_do_histogram;
+		mfd->start_histogram = mdp_histogram_start;
+		mfd->stop_histogram = mdp_histogram_stop;
 		mfd->vsync_ctrl = mdp_dma_vsync_ctrl;
 		if (mfd->panel_info.pdest == DISPLAY_1)
 			mfd->dma = &dma2_data;
@@ -2593,6 +2702,8 @@
 #ifndef CONFIG_FB_MSM_MDP22
 		mfd->lut_update = mdp_lut_update_lcdc;
 		mfd->do_histogram = mdp_do_histogram;
+		mfd->start_histogram = mdp_histogram_start;
+		mfd->stop_histogram = mdp_histogram_stop;
 #endif
 #ifdef CONFIG_FB_MSM_OVERLAY
 		mfd->dma_fnc = mdp4_lcdc_overlay;
@@ -2602,6 +2713,8 @@
 
 #ifdef CONFIG_FB_MSM_MDP40
 		mdp4_lcdc_vsync_init(0);
+		configure_mdp_core_clk_table((mfd->panel_info.clk_rate)
+								* 23 / 20);
 		if (mfd->panel.type == HDMI_PANEL) {
 			mfd->dma = &dma_e_data;
 			mdp4_display_intf_sel(EXTERNAL_INTF_SEL, LCDC_RGB_INTF);
@@ -2696,8 +2809,9 @@
 	platform_set_drvdata(msm_fb_dev, mfd);
 
 	rc = platform_device_add(msm_fb_dev);
-	if (rc)
+	if (rc) {
 		goto mdp_probe_err;
+	}
 
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
@@ -2725,6 +2839,9 @@
 		return;
 	}
 
+	if (hdmi_pll_fs)
+		regulator_enable(hdmi_pll_fs);
+
 	if (on && !mdp_footswitch_on) {
 		pr_debug("Enable MDP FS\n");
 		regulator_enable(footswitch);
@@ -2735,6 +2852,9 @@
 		mdp_footswitch_on = 0;
 	}
 
+	if (hdmi_pll_fs)
+		regulator_disable(hdmi_pll_fs);
+
 	mutex_unlock(&mdp_suspend_mutex);
 }
 
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_debugfs.c msm/mdp_debugfs.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_debugfs.c	2012-08-13 16:39:47.804233556 -0700
+++ msm/mdp_debugfs.c	2012-08-13 09:41:28.988949812 -0700
@@ -434,6 +434,7 @@
 	dlen -= len;
 	len = snprintf(bp, dlen, "play:  %08lu\t",
 					mdp4_stat.overlay_play[1]);
+
 	bp += len;
 	dlen -= len;
 	len = snprintf(bp, dlen, "commit:  %08lu\n\n",
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_dma.c msm/mdp_dma.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_dma.c	2012-08-08 11:46:04.953978767 -0700
+++ msm/mdp_dma.c	2012-08-14 12:32:48.901338838 -0700
@@ -481,8 +481,6 @@
 void mdp_dma2_update(struct msm_fb_data_type *mfd)
 #endif
 {
-	if (!mfd)
-		return;
 	unsigned long flag;
 
 	down(&mfd->dma->mutex);
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_dma_dsi_video.c msm/mdp_dma_dsi_video.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_dma_dsi_video.c	2012-08-08 11:46:04.952978767 -0700
+++ msm/mdp_dma_dsi_video.c	2012-08-14 12:32:48.901338838 -0700
@@ -26,6 +26,7 @@
 #include "mdp.h"
 #include "msm_fb.h"
 #include "mdp4.h"
+#include "mipi_dsi.h"
 
 #define DSI_VIDEO_BASE	0xF0000
 #define DMA_P_BASE      0x90000
@@ -129,6 +130,7 @@
 	/* MDP cmd block enable */
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 
+
 	/* starting address */
 	MDP_OUTP(MDP_BASE + DMA_P_BASE + 0x8, (uint32) buf);
 
@@ -192,6 +194,13 @@
 	ctrl_polarity =	(data_en_polarity << 2) |
 		(vsync_polarity << 1) | (hsync_polarity);
 
+	if (!(mfd->cont_splash_done)) {
+		mdp_pipe_ctrl(MDP_CMD_BLOCK,
+			MDP_BLOCK_POWER_OFF, FALSE);
+		MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE, 0);
+		mipi_dsi_controller_cfg(0);
+	}
+
 	MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE + 0x4, hsync_ctrl);
 	MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE + 0x8, vsync_period);
 	MDP_OUTP(MDP_BASE + DSI_VIDEO_BASE + 0xc, vsync_pulse_width);
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_dma_lcdc.c msm/mdp_dma_lcdc.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_dma_lcdc.c	2012-08-08 11:46:04.951978767 -0700
+++ msm/mdp_dma_lcdc.c	2012-08-14 12:32:48.901338838 -0700
@@ -250,6 +250,12 @@
 	ctrl_polarity =
 	    (data_en_polarity << 2) | (vsync_polarity << 1) | (hsync_polarity);
 
+	if (!(mfd->cont_splash_done)) {
+		mdp_pipe_ctrl(MDP_CMD_BLOCK,
+			MDP_BLOCK_POWER_OFF, FALSE);
+		MDP_OUTP(MDP_BASE + timer_base, 0);
+	}
+
 	MDP_OUTP(MDP_BASE + timer_base + 0x4, hsync_ctrl);
 	MDP_OUTP(MDP_BASE + timer_base + 0x8, vsync_period);
 	MDP_OUTP(MDP_BASE + timer_base + 0xc, vsync_pulse_width * hsync_period);
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_dma_s.c msm/mdp_dma_s.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_dma_s.c	2012-07-31 13:23:02.834696266 -0700
+++ msm/mdp_dma_s.c	2012-05-19 18:38:37.633909378 -0700
@@ -135,8 +135,6 @@
 
 void mdp_dma_s_update(struct msm_fb_data_type *mfd)
 {
-	if (!mfd)
-		return;
 	down(&mfd->dma->mutex);
 	if ((mfd) && (!mfd->dma->busy) && (mfd->panel_power_on)) {
 		down(&mfd->sem);
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp.h msm/mdp.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp.h	2012-08-13 16:39:47.801233556 -0700
+++ msm/mdp.h	2012-08-14 12:32:48.899338839 -0700
@@ -46,10 +46,6 @@
 extern struct mdp_csc_cfg mdp_csc_convert[4];
 extern struct workqueue_struct *mdp_hist_wq;
 
-extern int mdp_lut_i;
-extern int mdp_lut_push;
-extern int mdp_lut_push_i;
-extern struct mutex mdp_lut_push_sem;
 extern uint32 mdp_intr_mask;
 
 #define MDP4_REVISION_V1		0
@@ -770,7 +766,7 @@
 int mdp_dsi_video_on(struct platform_device *pdev);
 int mdp_dsi_video_off(struct platform_device *pdev);
 void mdp_dsi_video_update(struct msm_fb_data_type *mfd);
-void mdp3_dsi_cmd_dma_busy_wait(struct msm_fb_data_type *mfd)
+void mdp3_dsi_cmd_dma_busy_wait(struct msm_fb_data_type *mfd);
 static inline int mdp4_dsi_cmd_off(struct platform_device *pdev)
 {
 	return 0;
@@ -815,9 +811,7 @@
 void mdp_disable_irq_nosync(uint32 term);
 int mdp_get_bytes_per_pixel(uint32_t format,
 				 struct msm_fb_data_type *mfd);
-int mdp_set_core_clk(u32 rate);
-int mdp_clk_round_rate(u32 rate);
-
+int mdp_set_core_clk(uint16 perf_level);
 unsigned long mdp_get_core_clk(void);
 unsigned long mdp_perf_level2clk_rate(uint32 perf_level);
 
@@ -879,8 +873,6 @@
 }
 #endif
 
-void mdp_vid_quant_set(void);
-
 #ifndef CONFIG_FB_MSM_MDP40
 static inline void mdp_dsi_cmd_overlay_suspend(struct msm_fb_data_type *mfd)
 {
@@ -899,4 +891,12 @@
 	unsigned long srcp0_addr, unsigned long srcp0_size,
 	unsigned long srcp1_addr, unsigned long srcp1_size);
 
+#ifdef CONFIG_FB_MSM_DTV
+void mdp_vid_quant_set(void);
+#else
+static inline void mdp_vid_quant_set(void)
+{
+	/* empty */
+}
+#endif
 #endif /* MDP_H */
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_ppp.c msm/mdp_ppp.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_ppp.c	2012-08-08 11:51:20.197957210 -0700
+++ msm/mdp_ppp.c	2012-08-14 12:32:39.540339478 -0700
@@ -1429,7 +1429,7 @@
 		iBuf.mdpImg.mdpOp |= MDPOP_DITHER;
 
 	if (req->flags & MDP_BLEND_FG_PREMULT) {
-#ifdef CONFIG_FB_MSM_MDP31
+#if defined(CONFIG_FB_MSM_MDP31) || defined(CONFIG_FB_MSM_MDP303)
 		iBuf.mdpImg.mdpOp |= MDPOP_FG_PM_ALPHA;
 #else
 		put_img(p_src_file, *src_ihdl);
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_ppp_v20.c msm/mdp_ppp_v20.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_ppp_v20.c	2012-08-08 09:32:42.788525955 -0700
+++ msm/mdp_ppp_v20.c	2012-08-14 12:32:39.540339478 -0700
@@ -2403,6 +2403,9 @@
 			   uint32 width,
 			   uint32 height, int bpp, MDPIBUF *iBuf, int layer)
 {
+	if (iBuf->mdpImg.imgType == MDP_Y_CBCR_H2V2_ADRENO && layer == 0)
+		*src0 += (x + y * ALIGN(width, 32)) * bpp;
+	else
 	*src0 += (x + y * width) * bpp;
 
 	/* if it's dest/bg buffer, we need to adjust it for rotation */
@@ -2414,8 +2417,13 @@
 		 * MDP_Y_CBCR_H2V2/MDP_Y_CRCB_H2V2 cosite for now
 		 * we need to shift x direction same as y dir for offsite
 		 */
-		*src1 +=
-		    ((x / h_slice) * h_slice +
+		if (iBuf->mdpImg.imgType == MDP_Y_CBCR_H2V2_ADRENO
+							&& layer == 0)
+			*src1 += ((x / h_slice) * h_slice + ((y == 0) ? 0 :
+			(((y + 1) / v_slice - 1) * (ALIGN(width/2, 32) * 2))))
+									* bpp;
+		else
+			*src1 += ((x / h_slice) * h_slice +
 		     ((y == 0) ? 0 : ((y + 1) / v_slice - 1) * width)) * bpp;
 
 		/* if it's dest/bg buffer, we need to adjust it for rotation */
@@ -2429,6 +2437,72 @@
 			uint32 *tpVal,
 			uint32 perPixelAlpha, uint32 *pppop_reg_ptr)
 {
+	if (mdp_rev == MDP_REV_303) {
+		int bg_alpha;
+
+		*alpha = iBuf->mdpImg.alpha;
+		*tpVal = iBuf->mdpImg.tpVal;
+
+		if (iBuf->mdpImg.mdpOp & MDPOP_FG_PM_ALPHA) {
+			if (perPixelAlpha) {
+				*pppop_reg_ptr |= PPP_OP_ROT_ON |
+						  PPP_OP_BLEND_ON |
+						  PPP_OP_BLEND_CONSTANT_ALPHA;
+			} else {
+				if ((iBuf->mdpImg.mdpOp & MDPOP_ALPHAB)
+					&& (iBuf->mdpImg.alpha == 0xff)) {
+					iBuf->mdpImg.mdpOp &= ~(MDPOP_ALPHAB);
+				}
+
+				if ((iBuf->mdpImg.mdpOp & MDPOP_ALPHAB)
+				   || (iBuf->mdpImg.mdpOp & MDPOP_TRANSP)) {
+
+					*pppop_reg_ptr |= PPP_OP_ROT_ON |
+						PPP_OP_BLEND_ON |
+						PPP_OP_BLEND_CONSTANT_ALPHA |
+						PPP_OP_BLEND_ALPHA_BLEND_NORMAL;
+				}
+			}
+
+			bg_alpha = PPP_BLEND_BG_USE_ALPHA_SEL |
+				PPP_BLEND_BG_ALPHA_REVERSE;
+
+			if (perPixelAlpha) {
+				bg_alpha |= PPP_BLEND_BG_SRCPIXEL_ALPHA;
+			} else {
+				bg_alpha |= PPP_BLEND_BG_CONSTANT_ALPHA;
+				bg_alpha |= iBuf->mdpImg.alpha << 24;
+			}
+			outpdw(MDP_BASE + 0x70010, bg_alpha);
+
+			if (iBuf->mdpImg.mdpOp & MDPOP_TRANSP)
+				*pppop_reg_ptr |= PPP_BLEND_CALPHA_TRNASP;
+		} else if (perPixelAlpha) {
+				*pppop_reg_ptr |= PPP_OP_ROT_ON |
+						  PPP_OP_BLEND_ON |
+						  PPP_OP_BLEND_SRCPIXEL_ALPHA;
+				outpdw(MDP_BASE + 0x70010, 0);
+			} else {
+				if ((iBuf->mdpImg.mdpOp & MDPOP_ALPHAB)
+					&& (iBuf->mdpImg.alpha == 0xff)) {
+						iBuf->mdpImg.mdpOp &=
+							~(MDPOP_ALPHAB);
+				}
+
+				if ((iBuf->mdpImg.mdpOp & MDPOP_ALPHAB)
+				   || (iBuf->mdpImg.mdpOp & MDPOP_TRANSP)) {
+					*pppop_reg_ptr |= PPP_OP_ROT_ON |
+						PPP_OP_BLEND_ON |
+						PPP_OP_BLEND_CONSTANT_ALPHA |
+						PPP_OP_BLEND_ALPHA_BLEND_NORMAL;
+				}
+
+				if (iBuf->mdpImg.mdpOp & MDPOP_TRANSP)
+					*pppop_reg_ptr |=
+						PPP_BLEND_CALPHA_TRNASP;
+				outpdw(MDP_BASE + 0x70010, 0);
+			}
+	} else {
 	if (perPixelAlpha) {
 		*pppop_reg_ptr |= PPP_OP_ROT_ON |
 		    PPP_OP_BLEND_ON | PPP_OP_BLEND_SRCPIXEL_ALPHA;
@@ -2463,4 +2537,5 @@
 			}
 		}
 	}
+	}
 }
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_vsync.c msm/mdp_vsync.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mdp_vsync.c	2012-08-13 16:39:47.804233556 -0700
+++ msm/mdp_vsync.c	2012-08-14 12:32:48.901338838 -0700
@@ -284,7 +284,7 @@
 	 * external vsync source pulse width and
 	 * polarity flip
 	 */
-	MDP_OUTP(MDP_BASE + MDP_PRIM_VSYNC_OUT_CTRL, BIT(0)|BIT(30));
+	MDP_OUTP(MDP_BASE + MDP_PRIM_VSYNC_OUT_CTRL, BIT(0));
 #ifdef CONFIG_FB_MSM_MDP40
 	if (mdp_hw_revision < MDP4_REVISION_V2_1) {
 		MDP_OUTP(MDP_BASE +	MDP_SEC_VSYNC_OUT_CTRL, BIT(0));
Only in msm: mdss
Only in msm: mhl
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mhl_api.h msm/mhl_api.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mhl_api.h	2012-07-16 10:04:32.209489768 -0700
+++ msm/mhl_api.h	2012-08-14 12:32:39.563339479 -0700
@@ -14,29 +14,7 @@
 #ifndef __MHL_API_H__
 #define __MHL_API_H__
 
-#ifndef __LINUX_USB_GADGET_FSERIAL_H__
-#define __LINUX_USB_GADGET_FSERIAL_H__
-
-#include <linux/platform_device.h>
-
-enum transport_type {
-	USB_GADGET_FSERIAL_TRANSPORT_TTY,
-	USB_GADGET_FSERIAL_TRANSPORT_SDIO,
-	USB_GADGET_FSERIAL_TRANSPORT_SMD,
-};
-
-#define GSERIAL_NO_PORTS 2
-struct usb_gadget_fserial_platform_data {
-	enum transport_type	transport[GSERIAL_NO_PORTS];
-	unsigned		no_ports;
-};
-
-struct usb_gadget_facm_pdata {
-	enum transport_type	transport[GSERIAL_NO_PORTS];
-	unsigned		no_ports;
-};
-
-#ifdef CONFIG_MHL
+#ifdef CONFIG_FB_MSM_HDMI_MHL_8334
 bool mhl_is_connected(void);
 #else
 static bool mhl_is_connected(void)
@@ -45,5 +23,4 @@
 }
 #endif
 
-#endif /* __LINUX_USB_GADGET_FSERIAL_H__ */
 #endif /* __MHL_API_H__ */
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mhl_v1
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mhl_v2
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_boeot_tft_video_wsvga_pt.c
Only in msm: mipi_chimei_wuxga.c
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_chimei_wxga_pt.c msm/mipi_chimei_wxga_pt.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_chimei_wxga_pt.c	2012-08-08 09:32:42.789525955 -0700
+++ msm/mipi_chimei_wxga_pt.c	2012-08-14 12:32:39.582339477 -0700
@@ -121,7 +121,7 @@
 	pinfo->lcdc.hsync_skew = 0;
 
 	/* Backlight levels - controled via PMIC pwm gpio */
-	pinfo->bl_max = 15;
+	pinfo->bl_max = PWM_LEVEL;
 	pinfo->bl_min = 1;
 
 	/* mipi - general */
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_dsi.c msm/mipi_dsi.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_dsi.c	2012-08-08 09:32:42.804525955 -0700
+++ msm/mipi_dsi.c	2012-08-13 09:41:28.990949812 -0700
@@ -34,11 +34,8 @@
 #include "mipi_dsi.h"
 #include "mdp.h"
 #include "mdp4.h"
-#if defined(CONFIG_MIPI_SAMSUNG_ESD_REFRESH)
-#include "mipi_samsung_esd_refresh.h"
-#endif
 
-int dsi_irq;
+u32 dsi_irq;
 u32 esc_byte_ratio;
 
 static boolean tlmm_settings = FALSE;
@@ -71,7 +68,6 @@
 	int ret = 0;
 	struct msm_fb_data_type *mfd;
 	struct msm_panel_info *pinfo;
-	uint32 dsi_ctrl;
 
 	mfd = platform_get_drvdata(pdev);
 	pinfo = &mfd->panel_info;
@@ -109,9 +105,7 @@
 	mipi_dsi_clk_disable();
 
 	/* disbale dsi engine */
-	dsi_ctrl = MIPI_INP(MIPI_DSI_BASE + 0x0000);
-	dsi_ctrl &= ~0x01;
-	MIPI_OUTP(MIPI_DSI_BASE + 0x0000, dsi_ctrl);
+	MIPI_OUTP(MIPI_DSI_BASE + 0x0000, 0);
 
 	mipi_dsi_phy_ctrl(0);
 
@@ -121,10 +115,7 @@
 	mipi_dsi_unprepare_clocks();
 	if (mipi_dsi_pdata && mipi_dsi_pdata->dsi_power_save)
 		mipi_dsi_pdata->dsi_power_save(0);
-#if defined(CONFIG_FB_MSM_MIPI_PANEL_POWERON_LP11)
-	if (mipi_dsi_pdata && mipi_dsi_pdata->dsi_client_power_save)
-		mipi_dsi_pdata->dsi_client_power_save(0);
-#endif /* CONFIG_FB_MSM_MIPI_PANEL_POWERON_LP11 */
+
 	if (mdp_rev >= MDP_REV_41)
 		mutex_unlock(&mfd->dma->ov_mutex);
 	else
@@ -157,13 +148,6 @@
 
 	if (mipi_dsi_pdata && mipi_dsi_pdata->dsi_power_save)
 		mipi_dsi_pdata->dsi_power_save(1);
-#if defined(CONFIG_FB_MSM_MIPI_PANEL_POWERON_LP11)
-	/*
-	 * Fix for floating state of VDD line in toshiba chip
-	 * */
-	if (mipi_dsi_pdata && mipi_dsi_pdata->dsi_client_power_save)
-		mipi_dsi_pdata->dsi_client_power_save(1);
-#endif /* CONFIG_FB_MSM_MIPI_PANEL_POWERON_LP11 */
 
 	cont_splash_clk_ctrl(0);
 	mipi_dsi_prepare_clocks();
@@ -251,32 +235,6 @@
 	}
 
 	mipi_dsi_host_init(mipi);
-#if defined(CONFIG_FB_MSM_MIPI_PANEL_POWERON_LP11)
-	/*
-	 * For TC358764 D2L IC, one of the requirement for power on
-	 * is to maintain an LP11 state in data and clock lanes during
-	 * power enabling and reset assertion. This change is to
-	 * achieve that.
-	 * */
-	if (mipi_dsi_pdata && mipi_dsi_pdata->dsi_client_power_save) {
-		u32 tmp_reg0c, tmp_rega8;
-		mipi_dsi_pdata->dsi_client_reset();
-		udelay(200);
-		/* backup register values */
-		tmp_reg0c = MIPI_INP(MIPI_DSI_BASE + 0x000c);
-		tmp_rega8 = MIPI_INP(MIPI_DSI_BASE + 0xA8);
-		/* Clear HS  mode assertion and related flags */
-		MIPI_OUTP(MIPI_DSI_BASE + 0x0c, 0x8000);
-		MIPI_OUTP(MIPI_DSI_BASE + 0xA8, 0x0);
-		wmb();
-		mdelay(5);
-		/* restore previous values */
-		MIPI_OUTP(MIPI_DSI_BASE + 0x0c, tmp_reg0c);
-		MIPI_OUTP(MIPI_DSI_BASE + 0xa8, tmp_rega8);
-		wmb();
-	}
-#endif /* CONFIG_FB_MSM_MIPI_PANEL_POWERON_LP11 */
-
 
 	if (mipi->force_clk_lane_hs) {
 		u32 tmp;
@@ -305,7 +263,8 @@
 						gpio_direction_input(
 							vsync_gpio);
 					else
-						pr_err("%s: unable to request gpio=%d\n",
+						pr_err("%s: unable to \
+							request gpio=%d\n",
 							__func__, vsync_gpio);
 				} else if (mdp_rev == MDP_REV_303) {
 					if (!tlmm_settings && gpio_request(
@@ -319,7 +278,9 @@
 							GPIO_CFG_ENABLE);
 
 						if (ret) {
-							pr_err("%s: unable to config tlmm = %d\n",
+							pr_err(
+							"%s: unable to config \
+							tlmm = %d\n",
 							__func__, vsync_gpio);
 						}
 						tlmm_settings = TRUE;
@@ -328,7 +289,9 @@
 							vsync_gpio);
 					} else {
 						if (!tlmm_settings) {
-							pr_err("%s: unable to request gpio=%d\n",
+							pr_err(
+							"%s: unable to request \
+							gpio=%d\n",
 							__func__, vsync_gpio);
 						}
 					}
@@ -608,9 +571,6 @@
 		goto mipi_dsi_probe_err;
 
 	pdev_list[pdev_list_cnt++] = pdev;
-#if defined(CONFIG_MIPI_SAMSUNG_ESD_REFRESH)
-	register_mipi_dev(pdev);
-#endif
 
 return 0;
 
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_dsi.h msm/mipi_dsi.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_dsi.h	2012-08-08 09:32:42.804525955 -0700
+++ msm/mipi_dsi.h	2012-08-13 09:41:28.990949812 -0700
@@ -15,8 +15,6 @@
 #define MIPI_DSI_H
 
 #include <mach/scm-io.h>
-#include "msm_fb_def.h"
-#include "msm_fb.h"
 #include <linux/list.h>
 
 #ifdef BIT
@@ -124,11 +122,10 @@
 #define DSI_CMD_TRIGGER_SW		0x04
 #define DSI_CMD_TRIGGER_SW_SEOF		0x05	/* cmd dma only */
 #define DSI_CMD_TRIGGER_SW_TE		0x06
-#define MIPI_DSI_TX_TIMEOUT_MS	(HZ * 40/1000)/*40ms*/
 
 extern struct device dsi_dev;
 extern int mipi_dsi_clk_on;
-extern int dsi_irq;
+extern u32 dsi_irq;
 extern u32 esc_byte_ratio;
 
 extern void  __iomem *periph_base;
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_dsi_host.c msm/mipi_dsi_host.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_dsi_host.c	2012-08-13 16:39:47.805233556 -0700
+++ msm/mipi_dsi_host.c	2012-08-14 12:32:48.902338839 -0700
@@ -877,15 +877,10 @@
 	if (pinfo->data_lane0)
 		dsi_ctrl |= BIT(4);
 
-#if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT) ||\
-	defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_WVGA_PT_PANEL)
-	/* send commands in High Speed Mode */
-	MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x10000000);
-#else
 	/* from frame buffer, low power mode */
 	/* DSI_COMMAND_MODE_DMA_CTRL */
 	MIPI_OUTP(MIPI_DSI_BASE + 0x38, 0x14000000);
-#endif
+
 	data = 0;
 	if (pinfo->te_sel)
 		data |= BIT(31);
@@ -1057,6 +1052,7 @@
 			__func__, current->pid);
 }
 
+
 void mipi_dsi_cmd_mdp_start(void)
 {
 	unsigned long flag;
@@ -1218,10 +1214,7 @@
 		mipi_dsi_cmd_dma_add(tp, cm);
 		mipi_dsi_cmd_dma_tx(tp);
 		if (cm->wait)
-			if (cm->wait >= 20)
 				msleep(cm->wait);
-			else
-				mdelay(cm->wait);
 		cm++;
 	}
 
@@ -1414,7 +1407,7 @@
 	wmb();
 	spin_unlock_irqrestore(&dsi_mdp_lock, flags);
 
-	wait_for_completion_timeout(&dsi_dma_comp, MIPI_DSI_TX_TIMEOUT_MS);
+	wait_for_completion(&dsi_dma_comp);
 
 	dma_unmap_single(&dsi_dev, tp->dmap, tp->len, DMA_TO_DEVICE);
 	tp->dmap = 0;
@@ -1543,6 +1536,7 @@
 		mipi_dsi_mdp_stat_inc(STAT_DSI_ERROR);
 		mipi_dsi_error();
 	}
+
 	if (isr & DSI_INTR_VIDEO_DONE) {
 		/*
 		* do something  here
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_magna_oled_video_qhd_pt.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_novatek_boe_hydis_cmd_wvga_pt.c
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_novatek.c msm/mipi_novatek.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_novatek.c	2012-08-08 09:32:42.820525953 -0700
+++ msm/mipi_novatek.c	2012-08-14 12:32:39.582339477 -0700
@@ -11,168 +11,15 @@
  *
  */
 
-#include <linux/lcd.h>
 #ifdef CONFIG_SPI_QUP
 #include <linux/spi/spi.h>
 #endif
-#if defined(CONFIG_MACH_GOGH)
-#include <linux/interrupt.h>
-#include <linux/workqueue.h>
-#endif
+#include <linux/leds.h>
 #include "msm_fb.h"
 #include "mipi_dsi.h"
 #include "mipi_novatek.h"
 #include "mdp4.h"
-#if defined(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT)
-#include "mdp4_video_enhance.h"
-#endif
-#if defined(CONFIG_MACH_GOGH)
-static struct delayed_work  det_work;
-static void mipi_novatek_disp_set_backlight(struct msm_fb_data_type *mfd);
-static void blenable_work_func(struct work_struct *work);
-#endif
-
-static char led_pwm1[2] = {0x51, 0x0};	/* DTYPE_DCS_WRITE1 */
-
-static struct dsi_cmd_desc novatek_cmd_backlight_cmds[] = {
-	{DTYPE_DCS_LWRITE, 1, 0, 0, 1, sizeof(led_pwm1), led_pwm1},
-};
-
-
-#if defined(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) || \
-	defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT)
-static struct mipi_novatek_driver_data msd;
-int is_lcd_connected = 1;
-
-
-
-static char manufacture_id1[2] = {0xDA, 0x00}; /* DTYPE_DCS_READ */
-static char manufacture_id2[2] = {0xDB, 0x00}; /* DTYPE_DCS_READ */
-static char manufacture_id3[2] = {0xDC, 0x00}; /* DTYPE_DCS_READ */
-
-
-static struct dsi_cmd_desc novatek_manufacture_id1_cmd = {
-	DTYPE_DCS_READ, 1, 0, 1, 5, sizeof(manufacture_id1), manufacture_id1};
-static struct dsi_cmd_desc novatek_manufacture_id2_cmd = {
-	DTYPE_DCS_READ, 1, 0, 1, 5, sizeof(manufacture_id2), manufacture_id2};
-static struct dsi_cmd_desc novatek_manufacture_id3_cmd = {
-	DTYPE_DCS_READ, 1, 0, 1, 5, sizeof(manufacture_id3), manufacture_id3};
-
-static uint32 mipi_novatek_disp_manufacture_id(struct msm_fb_data_type *mfd)
-{
-	struct dsi_buf *rp, *tp;
-	struct dsi_cmd_desc *cmd;
-	uint32 id;
-
-	tp = &msd.novatek_tx_buf;
-	rp = &msd.novatek_rx_buf;
-	mipi_dsi_buf_init(rp);
-	mipi_dsi_buf_init(tp);
-
-	cmd = &novatek_manufacture_id1_cmd;
-	mipi_dsi_cmds_rx(mfd, tp, rp, cmd, 1);
-	pr_info("%s: manufacture_id1=%x\n", __func__, *rp->data);
-	id = *((unsigned char *)rp->data);
-	id <<= 8;
-
-	mipi_dsi_buf_init(rp);
-	mipi_dsi_buf_init(tp);
-	cmd = &novatek_manufacture_id2_cmd;
-	mipi_dsi_cmds_rx(mfd, tp, rp, cmd, 1);
-	pr_info("%s: manufacture_id2=%x\n", __func__, *rp->data);
-	id |= *((unsigned char *)rp->data);
-	id <<= 8;
-
-	mipi_dsi_buf_init(rp);
-	mipi_dsi_buf_init(tp);
-	cmd = &novatek_manufacture_id3_cmd;
-	mipi_dsi_cmds_rx(mfd, tp, rp, cmd, 1);
-	pr_info("%s: manufacture_id3=%x\n", __func__, *rp->data);
-	id |= *((unsigned char *)rp->data);
-
-	pr_info("%s: manufacture_id=%x\n", __func__, id);
-	return id;
-}
-
-static int mipi_novatek_disp_send_cmd(struct msm_fb_data_type *mfd,
-				       enum mipi_novatek_cmd_list cmd,
-				       unsigned char lock)
-{
-	struct dsi_cmd_desc *cmd_desc;
-	int cmd_size = 0;
 
-	if (lock)
-		mutex_lock(&mfd->dma->ov_mutex);
-
-	switch (cmd) {
-	case PANEL_READY_TO_ON:
-#if defined(CONFIG_MACH_GOGH)
-		if (msd.mpd->manufacture_id != JASPER_MANUFACTURE_ID) {
-			cmd_desc = msd.mpd->ready_to_on_boe.cmd;
-			cmd_size = msd.mpd->ready_to_on_boe.size;
-		} else {
-			cmd_desc = msd.mpd->ready_to_on_hydis.cmd;
-			cmd_size = msd.mpd->ready_to_on_hydis.size;
-		}
-#else
-			cmd_desc = msd.mpd->ready_to_on_hydis.cmd;
-			cmd_size = msd.mpd->ready_to_on_hydis.size;
-#endif
-		break;
-	case PANEL_READY_TO_OFF:
-		cmd_desc = msd.mpd->ready_to_off.cmd;
-		cmd_size = msd.mpd->ready_to_off.size;
-		break;
-	case PANEL_ON:
-		cmd_desc = msd.mpd->on.cmd;
-		cmd_size = msd.mpd->on.size;
-		break;
-	case PANEL_OFF:
-		cmd_desc = msd.mpd->off.cmd;
-		cmd_size = msd.mpd->off.size;
-		break;
-	case PANEL_LATE_ON:
-		cmd_desc = msd.mpd->late_on.cmd;
-		cmd_size = msd.mpd->late_on.size;
-		break;
-	case PANEL_EARLY_OFF:
-		cmd_desc = msd.mpd->early_off.cmd;
-		cmd_size = msd.mpd->early_off.size;
-		break;
-
-	default:
-		goto unknown_command;
-		;
-	}
-
-	if (!cmd_size)
-		goto unknown_command;
-
-	if (lock) {
-		mipi_dsi_cmds_tx(mfd, &msd.novatek_tx_buf, cmd_desc, cmd_size);
-
-		mutex_unlock(&mfd->dma->ov_mutex);
-	} else {
-		mipi_dsi_cmds_tx(mfd, &msd.novatek_tx_buf, cmd_desc, cmd_size);
-	}
-
-	return 0;
-
-unknown_command:
-	if (lock)
-		mutex_unlock(&mfd->dma->ov_mutex);
-
-	return 0;
-}
-
-
-#endif
-
-
-
-#if !defined(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) && \
-	!defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT)
 
 static struct mipi_dsi_panel_platform_data *mipi_novatek_pdata;
 
@@ -180,12 +27,13 @@
 static struct dsi_buf novatek_rx_buf;
 static int mipi_novatek_lcd_init(void);
 
+static int wled_trigger_initialized;
+
 #define MIPI_DSI_NOVATEK_SPI_DEVICE_NAME	"dsi_novatek_3d_panel_spi"
 #define HPCI_FPGA_READ_CMD	0x84
 #define HPCI_FPGA_WRITE_CMD	0x04
-static char led_pwm2[2] = {0x53, 0x24}; /* DTYPE_DCS_WRITE1 */
-static char led_pwm3[2] = {0x55, 0x00}; /* DTYPE_DCS_WRITE1 */
-#if (defined(CONFIG_SPI_QUP))
+
+#ifdef CONFIG_SPI_QUP
 static struct spi_device *panel_3d_spi_client;
 
 static void novatek_fpga_write(uint8 addr, uint16 value)
@@ -372,7 +220,7 @@
 static char exit_sleep[2] = {0x11, 0x00}; /* DTYPE_DCS_WRITE */
 static char display_off[2] = {0x28, 0x00}; /* DTYPE_DCS_WRITE */
 static char display_on[2] = {0x29, 0x00}; /* DTYPE_DCS_WRITE */
-static char normal_mode_on[2] = {0x13, 0x00}; /* DTYPE_DCS_WRITE */
+
 
 
 static char rgb_888[2] = {0x3A, 0x77}; /* DTYPE_DCS_WRITE1 */
@@ -415,6 +263,32 @@
 		sizeof(led_pwm3), led_pwm3},
 };
 
+static struct dsi_cmd_desc novatek_cmd_on_cmds[] = {
+	{DTYPE_DCS_WRITE, 1, 0, 0, 50,
+		sizeof(sw_reset), sw_reset},
+	{DTYPE_DCS_WRITE, 1, 0, 0, 10,
+		sizeof(exit_sleep), exit_sleep},
+	{DTYPE_DCS_WRITE, 1, 0, 0, 10,
+		sizeof(display_on), display_on},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, 50,
+		sizeof(novatek_f4), novatek_f4},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, 50,
+		sizeof(novatek_8c), novatek_8c},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, 50,
+		sizeof(novatek_ff), novatek_ff},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, 10,
+		sizeof(set_num_of_lanes), set_num_of_lanes},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, 50,
+		sizeof(set_width), set_width},
+	{DTYPE_DCS_LWRITE, 1, 0, 0, 50,
+		sizeof(set_height), set_height},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, 10,
+		sizeof(rgb_888), rgb_888},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, 1,
+		sizeof(led_pwm2), led_pwm2},
+	{DTYPE_DCS_WRITE1, 1, 0, 0, 1,
+		sizeof(led_pwm3), led_pwm3},
+};
 
 static struct dsi_cmd_desc novatek_display_off_cmds[] = {
 	{DTYPE_DCS_WRITE, 1, 0, 0, 10,
@@ -555,6 +429,8 @@
 	return 0;
 }
 
+DEFINE_LED_TRIGGER(bkl_led_trigger);
+
 #ifdef CONFIG_FB_MSM_MDP303
 void mdp4_backlight_put_level(int cndx, int level)
 {
@@ -565,11 +441,13 @@
 static void mipi_novatek_set_backlight(struct msm_fb_data_type *mfd)
 {
 	struct mipi_panel_info *mipi;
-	static int bl_level_old;
 
-	mipi  = &mfd->panel_info.mipi;
-	if (bl_level_old == mfd->bl_level)
+	if ((mipi_novatek_pdata->enable_wled_bl_ctrl)
+	    && (wled_trigger_initialized)) {
+		led_trigger_event(bkl_led_trigger, mfd->bl_level);
 		return;
+	}
+	mipi  = &mfd->panel_info.mipi;
 
 	mdp4_backlight_put_level(0, mfd->bl_level);
 }
@@ -631,7 +509,6 @@
 		if (dlane_swap)
 			mipi->dlane_swap = dlane_swap;
 	}
-
 	return 0;
 }
 
@@ -751,7 +628,6 @@
 
 static int mipi_novatek_lcd_init(void)
 {
-
 #ifdef CONFIG_SPI_QUP
 	int ret;
 	ret = spi_register_driver(&panel_3d_spi_driver);
@@ -763,322 +639,12 @@
 		pr_info("%s: SUCCESS (SPI)\n", __func__);
 #endif
 
+	led_trigger_register_simple("bkl_trigger", &bkl_led_trigger);
+	pr_info("%s: SUCCESS (WLED TRIGGER)\n", __func__);
+	wled_trigger_initialized = 1;
+
 	mipi_dsi_buf_alloc(&novatek_tx_buf, DSI_BUF_SIZE);
 	mipi_dsi_buf_alloc(&novatek_rx_buf, DSI_BUF_SIZE);
 
 	return platform_driver_register(&this_driver);
 }
-#endif
-
-
-#if defined(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) || \
-	defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT)
-
-
-static int mipi_novatek_disp_on(struct platform_device *pdev)
-{
-	struct msm_fb_data_type *mfd;
-	struct mipi_panel_info *mipi;
-	static int first_power_on;
-	int id_count = 0;
-
-	mfd = platform_get_drvdata(pdev);
-	if (unlikely(!mfd))
-		return -ENODEV;
-	if (unlikely(mfd->key != MFD_KEY))
-		return -EINVAL;
-
-	mipi = &mfd->panel_info.mipi;
-#if defined(CONFIG_MACH_GOGH)
-	if (first_power_on == 0) {
-		do {
-			msd.mpd->manufacture_id =
-				mipi_novatek_disp_manufacture_id(mfd);
-			id_count++;
-		} while (id_count < 3 && !msd.mpd->manufacture_id);
-		if (id_count >= 3 && !msd.mpd->manufacture_id) {
-			pr_info("Lcd is not connected\n");
-			is_lcd_connected = 0;
-		}
-		first_power_on++;
-	}
-#endif
-	mipi_novatek_disp_send_cmd(mfd, PANEL_READY_TO_ON, false);
-#if defined(CONFIG_MACH_GOGH)
-	INIT_DELAYED_WORK(&det_work, blenable_work_func);
-	schedule_delayed_work(&det_work, msecs_to_jiffies(100));
-#endif
-	if (mipi->mode == DSI_VIDEO_MODE)
-		mipi_novatek_disp_send_cmd(mfd, PANEL_ON, false);
-
-#if !defined(CONFIG_HAS_EARLYSUSPEND)
-	mipi_novatek_disp_send_cmd(mfd, PANEL_LATE_ON, false);
-#endif/* CONFIG_HAS_EARLYSUSPEND */
-#if defined(CONFIG_MIPI_SAMSUNG_ESD_REFRESH)
-	set_esd_enable();
-#endif
-	pr_info("%s:Display on completed\n", __func__);
-return 0;
-}
-
-static int mipi_novatek_disp_off(struct platform_device *pdev)
-{
-	struct msm_fb_data_type *mfd;
-
-#if defined(CONFIG_MIPI_SAMSUNG_ESD_REFRESH)
-	set_esd_disable();
-#endif
-	mfd = platform_get_drvdata(pdev);
-	if (unlikely(!mfd))
-		return -ENODEV;
-	if (unlikely(mfd->key != MFD_KEY))
-		return -EINVAL;
-
-	mipi_novatek_disp_send_cmd(mfd, PANEL_READY_TO_OFF, false);
-	mipi_novatek_disp_send_cmd(mfd, PANEL_OFF, false);
-	pr_info("%s:Display off completed\n", __func__);
-	return 0;
-}
-
-#if defined(CONFIG_HAS_EARLYSUSPEND)
-static void mipi_novatek_disp_early_suspend(struct early_suspend *h)
-{
-	struct msm_fb_data_type *mfd;
-
-	mfd = platform_get_drvdata(msd.msm_pdev);
-	if (unlikely(!mfd)) {
-		pr_info("%s NO PDEV.\n", __func__);
-		return;
-	}
-	if (unlikely(mfd->key != MFD_KEY)) {
-		pr_info("%s MFD_KEY is not matched.\n", __func__);
-		return;
-	}
-
-	mipi_novatek_disp_send_cmd(mfd, PANEL_EARLY_OFF, true);
-#if defined(CONFIG_MIPI_SAMSUNG_ESD_REFRESH)
-	set_esd_disable();
-#endif
-	pr_info("%s:Display suspend completed\n", __func__);
-}
-
-static void mipi_novatek_disp_late_resume(struct early_suspend *h)
-{
-	struct msm_fb_data_type *mfd;
-
-	mfd = platform_get_drvdata(msd.msm_pdev);
-	if (unlikely(!mfd)) {
-		pr_info("%s NO PDEV.\n", __func__);
-		return;
-	}
-	if (unlikely(mfd->key != MFD_KEY)) {
-		pr_info("%s MFD_KEY is not matched.\n", __func__);
-		return;
-	}
-
-	mipi_novatek_disp_send_cmd(mfd, PANEL_LATE_ON, true);
-	pr_info("%s:Display resume completed\n", __func__);
-}
-#endif
-#if defined(CONFIG_MIPI_SAMSUNG_ESD_REFRESH)
-void set_esd_refresh(boolean stat)
-{
-	msd.esd_refresh = stat;
-}
-#endif
-static void mipi_novatek_disp_set_backlight(struct msm_fb_data_type *mfd)
-{
-	struct mipi_panel_info *mipi;
-	static int bl_level_old;
-	pr_info("%s Back light level:%d\n", __func__, mfd->bl_level);
-
-#if defined(CONFIG_MIPI_SAMSUNG_ESD_REFRESH)
-	if (msd.esd_refresh == true) {
-		pr_debug("ESD Refresh on going cannot set backlight\n");
-		return ;
-	}
-#endif
-	mipi  = &mfd->panel_info.mipi;
-	if (bl_level_old == mfd->bl_level)
-		return;
-
-	mutex_lock(&mfd->dma->ov_mutex);
-#if !defined(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) && \
-	!defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT)
-
-	if (mdp4_overlay_dsi_state_get() <= ST_DSI_SUSPEND) {
-		mutex_unlock(&mfd->dma->ov_mutex);
-		return;
-	}
-#endif
-
-#ifdef CONFIG_FB_MSM_BACKLIGHT_AAT1402IUQ
-	/*
-	 *  The current Apexq backlight control circuit will be replaced with a
-	 *  new one , hence implementing only full on and off state for apexq
-	 *  board.
-	 */
-	led_pwm1[1] = ((mfd->bl_level != 0x0) ? 0xFF : 0x00);
-#else
-	led_pwm1[1] = (unsigned char)
-		(msd.mpd->set_brightness_level(mfd->bl_level));
-#endif
-	mipi_dsi_cmds_tx(mfd, &msd.novatek_tx_buf, novatek_cmd_backlight_cmds,
-			ARRAY_SIZE(novatek_cmd_backlight_cmds));
-	bl_level_old = mfd->bl_level;
-	mutex_unlock(&mfd->dma->ov_mutex);
-	return;
-}
-#if defined(CONFIG_MACH_GOGH)
-static void blenable_work_func(struct work_struct *work)
-{
-	struct msm_fb_data_type *mfd;
-	pr_info("%s :backlight made on after 100msec\n", __func__);
-	mfd = platform_get_drvdata(msd.msm_pdev);
-	if (!mfd->bl_level)
-		mfd->bl_level = 0x6C;
-	mipi_novatek_disp_set_backlight(mfd);
-}
-#endif
-#if defined(CONFIG_LCD_CLASS_DEVICE)
-static ssize_t mipi_novatek_lcdtype_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
-{
-	char temp[20];
-
-	snprintf(temp, strnlen(msd.mpd->panel_name, 20) + 1,
-						msd.mpd->panel_name);
-	strncat(buf, temp, 20);
-	return strnlen(buf, 20);
-}
-static struct lcd_ops mipi_novatek_disp_props;
-
-static DEVICE_ATTR(lcd_type, S_IRUGO, mipi_novatek_lcdtype_show, NULL);
-#endif
-
-static int __devinit mipi_novatek_disp_probe(struct platform_device *pdev)
-{
-	struct platform_device *msm_fb_added_dev;
-
-#if defined(CONFIG_LCD_CLASS_DEVICE)
-	int ret;
-	struct lcd_device *lcd_device;
-#endif
-
-	msd.dstat.acl_on = false;
-	if (pdev->id == 0) {
-		msd.mipi_novatek_disp_pdata = pdev->dev.platform_data;
-		return 0;
-	}
-
-	msm_fb_added_dev = msm_fb_add_device(pdev);
-
-#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_LCD_CLASS_DEVICE)
-	msd.msm_pdev = msm_fb_added_dev;
-#endif
-
-#if defined(CONFIG_HAS_EARLYSUSPEND)
-	msd.early_suspend.suspend = mipi_novatek_disp_early_suspend;
-	msd.early_suspend.resume = mipi_novatek_disp_late_resume;
-	msd.early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
-	register_early_suspend(&msd.early_suspend);
-
-#endif
-
-#if defined(CONFIG_LCD_CLASS_DEVICE)
-	lcd_device = lcd_device_register("panel", &pdev->dev, NULL,
-					&mipi_novatek_disp_props);
-
-	if (IS_ERR(lcd_device)) {
-		ret = PTR_ERR(lcd_device);
-		printk(KERN_ERR "lcd : failed to register device\n");
-		return ret;
-	}
-
-	ret = sysfs_create_file(&lcd_device->dev.kobj,
-					&dev_attr_lcd_type.attr);
-	if (ret) {
-		pr_info("sysfs create fail-%s\n",
-				dev_attr_lcd_type.attr.name);
-	}
-#endif
-#if defined(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT)
-	init_mdnie_class();
-#endif
-	pr_info("%s:Display probe completed\n", __func__);
-	return 0;
-}
-
-static struct platform_driver this_driver = {
-	.probe  = mipi_novatek_disp_probe,
-	.driver = {
-		.name   = "mipi_novatek_nt35510",
-	},
-};
-
-static struct msm_fb_panel_data novatek_panel_data = {
-	.on		= mipi_novatek_disp_on,
-	.off		= mipi_novatek_disp_off,
-	.set_backlight	= mipi_novatek_disp_set_backlight,
-};
-
-static int ch_used[3];
-
-int mipi_novatek_disp_device_register(struct msm_panel_info *pinfo,
-					u32 channel, u32 panel,
-					struct mipi_panel_data *mpd)
-{
-	struct platform_device *pdev = NULL;
-	int ret = 0;
-
-	if ((channel >= 3) || ch_used[channel])
-		return -ENODEV;
-
-	ch_used[channel] = TRUE;
-
-	pdev = platform_device_alloc("mipi_novatek_nt35510",
-					   (panel << 8)|channel);
-	if (!pdev)
-		return -ENOMEM;
-
-	novatek_panel_data.panel_info = *pinfo;
-	msd.mpd = mpd;
-	if (!msd.mpd) {
-		printk(KERN_ERR
-		  "%s: get mipi_panel_data failed!\n", __func__);
-		goto err_device_put;
-	}
-	mpd->msd = &msd;
-	ret = platform_device_add_data(pdev, &novatek_panel_data,
-		sizeof(novatek_panel_data));
-	if (ret) {
-		printk(KERN_ERR
-		  "%s: platform_device_add_data failed!\n", __func__);
-		goto err_device_put;
-	}
-
-	ret = platform_device_add(pdev);
-	if (ret) {
-		printk(KERN_ERR
-		  "%s: platform_device_register failed!\n", __func__);
-		goto err_device_put;
-	}
-
-	return ret;
-
-err_device_put:
-	platform_device_put(pdev);
-	return ret;
-}
-
-static int __init mipi_novatek_disp_init(void)
-{
-	mipi_dsi_buf_alloc(&msd.novatek_tx_buf, DSI_BUF_SIZE);
-	mipi_dsi_buf_alloc(&msd.novatek_rx_buf, DSI_BUF_SIZE);
-
-	return platform_driver_register(&this_driver);
-}
-module_init(mipi_novatek_disp_init);
-
-#endif
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_novatek_cmd_wvga_pt.c
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_novatek.h msm/mipi_novatek.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_novatek.h	2012-07-16 10:04:32.212489770 -0700
+++ msm/mipi_novatek.h	2012-05-19 18:38:37.642909375 -0700
@@ -15,89 +15,8 @@
 #define MIPI_NOVATEK_BLUE_H
 
 #define NOVATEK_TWO_LANE
-#include "mipi_dsi.h"
 
-#if defined(CONFIG_MACH_APEXQ) || defined(CONFIG_MACH_GOGH)
-#define MAX_BL_LEVEL 225
-#define MAX_GAMMA_VALUE 25
-#define MIN_BL_LEVEL 30
-#define INDEX_OFFSET 1
-#else
-#define MAX_BL_LEVEL 250
-#define MAX_GAMMA_VALUE 49
-#define MIN_BL_LEVEL 0
-#define INDEX_OFFSET 0
-#endif
-#define JASPER_MANUFACTURE_ID 0x556CC0
-
-enum mipi_novatek_cmd_list {
-	PANEL_READY_TO_ON,
-	PANEL_READY_TO_OFF,
-	PANEL_ON,
-	PANEL_OFF,
-	PANEL_LATE_ON,
-	PANEL_EARLY_OFF,
-
-};
-
-struct cmd_set {
-	struct dsi_cmd_desc *cmd;
-	int size;
-};
-
-struct mipi_panel_data {
-	const char panel_name[20];
-	struct cmd_set ready_to_on_hydis;
-	struct cmd_set ready_to_on_boe;
-	struct cmd_set ready_to_off;
-	struct cmd_set on;
-	struct cmd_set off;
-	struct cmd_set late_on;
-	struct cmd_set early_off;
-	struct mipi_novatek_driver_data *msd;
-	int (*set_brightness_level)(int bl_level);
-	unsigned int manufacture_id;
-
-
-};
-
-struct display_status {
-	unsigned char acl_on;
-	unsigned char gamma_mode; /* 1: 1.9 gamma, 0: 2.2 gamma */
-	unsigned char is_smart_dim_loaded;
-	unsigned char is_elvss_loaded;
-};
-
-
-struct mipi_novatek_driver_data {
-	struct dsi_buf novatek_tx_buf;
-	struct dsi_buf novatek_rx_buf;
-	struct msm_panel_common_pdata *mipi_novatek_disp_pdata;
-	struct mipi_panel_data *mpd;
-	struct display_status dstat;
-#if defined(CONFIG_HAS_EARLYSUSPEND)
-	struct early_suspend early_suspend;
-#endif
-#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_LCD_CLASS_DEVICE)
-	struct platform_device *msm_pdev;
-#endif
-#if defined(CONFIG_MIPI_SAMSUNG_ESD_REFRESH)
-	boolean esd_refresh;
-#endif
-
-};
-#if defined(CONFIG_MIPI_SAMSUNG_ESD_REFRESH)
-extern void set_esd_refresh(boolean stat);
-extern void set_esd_enable();
-extern void set_esd_disable();
-#endif
-#if defined(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) || \
-	defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT)
-int mipi_novatek_disp_device_register(struct msm_panel_info *pinfo,
-					u32 channel, u32 panel,
-					struct mipi_panel_data *mpd);
-#else
 int mipi_novatek_device_register(struct msm_panel_info *pinfo,
 					u32 channel, u32 panel);
-#endif
+
 #endif  /* MIPI_NOVATEK_BLUE_H */
Only in msm: mipi_NT35510.c
Only in msm: mipi_NT35510_cmd_wvga_pt.c
Only in msm: mipi_NT35510.h
Only in msm: mipi_NT35510_video_wvga_pt.c
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_renesas.c msm/mipi_renesas.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_renesas.c	2012-08-08 09:32:42.835525952 -0700
+++ msm/mipi_renesas.c	2012-08-14 12:32:39.582339477 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1138,7 +1138,7 @@
 	mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_display_on_cmds,
 			ARRAY_SIZE(renesas_display_on_cmds));
 
-	if (cpu_is_msm7x25a() || cpu_is_msm7x25aa()) {
+	if (cpu_is_msm7x25a() || cpu_is_msm7x25aa() || cpu_is_msm7x25ab()) {
 		mipi_dsi_cmds_tx(&renesas_tx_buf, renesas_hvga_on_cmds,
 			ARRAY_SIZE(renesas_hvga_on_cmds));
 	}
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_renesas_cmd_fwvga_pt.c msm/mipi_renesas_cmd_fwvga_pt.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_renesas_cmd_fwvga_pt.c	2012-07-16 10:04:32.213489770 -0700
+++ msm/mipi_renesas_cmd_fwvga_pt.c	2012-08-14 12:32:39.582339477 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -93,7 +93,7 @@
 	pinfo.lcdc.border_clr = 0;	/* blk */
 	pinfo.lcdc.underflow_clr = 0xff;	/* blue */
 	pinfo.lcdc.hsync_skew = 0;
-	pinfo.bl_max = 100;
+	pinfo.bl_max = 255;
 	pinfo.bl_min = 1;
 	pinfo.fb_num = 2;
 
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_renesas_video_fwvga_pt.c msm/mipi_renesas_video_fwvga_pt.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_renesas_video_fwvga_pt.c	2012-07-16 10:04:32.213489770 -0700
+++ msm/mipi_renesas_video_fwvga_pt.c	2012-08-14 12:32:39.583339476 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -105,7 +105,7 @@
 	pinfo.lcdc.border_clr = 0;	/* blk */
 	pinfo.lcdc.underflow_clr = 0xff;	/* blue */
 	pinfo.lcdc.hsync_skew = 0;
-	pinfo.bl_max = 100;
+	pinfo.bl_max = 255;
 	pinfo.bl_min = 1;
 	pinfo.fb_num = 2;
 
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_samsung_esd_refresh.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_samsung_esd_refresh.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_samsung_oled.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_samsung_oled_cmd_qhd_pt.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_samsung_oled.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_samsung_oled_video_hd_pt.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_samsung_oled_video_wvga_pt.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: mipi_samsung_tft_video_wxga_pt.c
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_tc358764_dsi2lvds.c msm/mipi_tc358764_dsi2lvds.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_tc358764_dsi2lvds.c	2012-08-08 09:32:42.854525952 -0700
+++ msm/mipi_tc358764_dsi2lvds.c	2012-08-14 12:32:39.583339476 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -68,10 +68,9 @@
 #include <linux/i2c.h>
 #include <linux/delay.h>
 #include <linux/pwm.h>
-
-#include <linux/interrupt.h>
-#include <linux/workqueue.h>
+#include <linux/gpio.h>
 #include "msm_fb.h"
+#include "mdp4.h"
 #include "mipi_dsi.h"
 #include "mipi_tc358764_dsi2lvds.h"
 
@@ -189,36 +188,12 @@
 #define DEBUG01		0x05A4	/* LVDS Data */
 
 /* PWM */
-#if defined(CONFIG_FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT_PANEL) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT_PANEL)
-#define PWM_FREQ_HZ	(5*1000)	/* 33 KHZ */
-#define PWM_LEVEL 200
-#else
-#define PWM_FREQ_HZ	(66*1000)	/* 66 KHZ */
-#define PWM_LEVEL 15
-#endif
+static u32 d2l_pwm_freq_hz = (3.921*1000);
+
+#define PWM_FREQ_HZ	(d2l_pwm_freq_hz)
 #define PWM_PERIOD_USEC (USEC_PER_SEC / PWM_FREQ_HZ)
 #define PWM_DUTY_LEVEL (PWM_PERIOD_USEC / PWM_LEVEL)
 
-#if defined(CONFIG_FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT_PANEL) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT_PANEL)
-#define PWM_DUTY_MAX   PWM_DUTY_LEVEL
-
-#define DUTY_DIM 5
-#define DUTY_MIN 8
-#define DUTY_25  20
-#define DUTY_DEFAULT 70
-#define DUTY_MAX 189
-
-/* Backlight levels */
-#define BRIGHTNESS_OFF   0
-#define BRIGHTNESS_DIM   20
-#define BRIGHTNESS_MIN   30
-#define BRIGHTNESS_25   86
-#define BRIGHTNESS_DEFAULT  140
-#define BRIGHTNESS_MAX   255
-#endif
-
 #define CMD_DELAY 100
 #define DSI_MAX_LANES 4
 #define KHZ 1000
@@ -241,15 +216,21 @@
 static struct dsi_buf d2l_rx_buf;
 static int led_pwm;
 static struct pwm_device *bl_pwm;
-static int initial_powerseq;
+static struct pwm_device *tn_pwm;
 static int bl_level;
-#if defined(CONFIG_FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT)
-static struct delayed_work  det_work;
-#endif
 static u32 d2l_gpio_out_mask;
 static u32 d2l_gpio_out_val;
+static u32 d2l_3d_gpio_enable;
+static u32 d2l_3d_gpio_mode;
+static int d2l_enable_3d;
+static struct i2c_client *d2l_i2c_client;
+static struct i2c_driver d2l_i2c_slave_driver;
+
 static int mipi_d2l_init(void);
+static int mipi_d2l_enable_3d(struct msm_fb_data_type *mfd,
+			      bool enable, bool mode);
+static u32 d2l_i2c_read_reg(struct i2c_client *client, u16 reg);
+static u32 d2l_i2c_write_reg(struct i2c_client *client, u16 reg, u32 val);
 
 /**
  * Read a bridge register
@@ -269,7 +250,7 @@
 	mipi_dsi_buf_init(&d2l_tx_buf);
 	mipi_dsi_buf_init(&d2l_rx_buf);
 
-	/* mutex had been acquried at dsi_on */
+	/* mutex had been acquired at mipi_dsi_on */
 	len = mipi_dsi_cmds_rx(mfd, &d2l_tx_buf, &d2l_rx_buf,
 			       &cmd_read_reg, len);
 
@@ -280,7 +261,6 @@
 
 	pr_debug("%s: reg=0x%x.data=0x%08x.\n", __func__, reg, data);
 
-
 	return data;
 }
 
@@ -289,9 +269,9 @@
  *
  * @param mfd
  *
- * @return register data value
+ * @return int
  */
-static u32 mipi_d2l_write_reg(struct msm_fb_data_type *mfd, u16 reg, u32 data)
+static int mipi_d2l_write_reg(struct msm_fb_data_type *mfd, u16 reg, u32 data)
 {
 	struct wr_cmd_payload payload;
 	struct dsi_cmd_desc cmd_write_reg = {
@@ -306,30 +286,34 @@
 
 	pr_debug("%s: reg=0x%x. data=0x%x.\n", __func__, reg, data);
 
-	return data;
+	return 0;
 }
 
-/*
+static void mipi_d2l_read_status(struct msm_fb_data_type *mfd)
+{
+	mipi_d2l_read_reg(mfd, DSI_LANESTATUS0);	/* 0x214 */
+	mipi_d2l_read_reg(mfd, DSI_LANESTATUS1);	/* 0x218 */
+	mipi_d2l_read_reg(mfd, DSI_INTSTATUS);		/* 0x220 */
+	mipi_d2l_read_reg(mfd, SYSSTAT);		/* 0x500 */
+}
+
+static void mipi_d2l_read_status_via_i2c(struct i2c_client *client)
+{
+	u32 tmp = 0;
+
+	tmp = d2l_i2c_read_reg(client, DSIERRCNT);
+	d2l_i2c_write_reg(client, DSIERRCNT, 0xFFFF0000);
+
+	d2l_i2c_read_reg(client, DSI_LANESTATUS0);	/* 0x214 */
+	d2l_i2c_read_reg(client, DSI_LANESTATUS1);	/* 0x218 */
+	d2l_i2c_read_reg(client, DSI_INTSTATUS);	/* 0x220 */
+	d2l_i2c_read_reg(client, SYSSTAT);		/* 0x500 */
+
+	d2l_i2c_write_reg(client, DSIERRCNT, tmp);
+}
+/**
  * Init the D2L bridge via the DSI interface for Video.
  *
- *	Register		Addr	Value
- *  ===================================================
- *  PPI_TX_RX_TA		0x013C	0x00040004
- *  PPI_LPTXTIMECNT	        0x0114	0x00000004
- *  PPI_D0S_CLRSIPOCOUNT	0x0164	0x00000003
- *  PPI_D1S_CLRSIPOCOUNT	0x0168	0x00000003
- *  PPI_D2S_CLRSIPOCOUNT	0x016C	0x00000003
- *  PPI_D3S_CLRSIPOCOUNT	0x0170	0x00000003
- *  PPI_LANEENABLE	        0x0134	0x0000001F
- *  DSI_LANEENABLE	        0x0210	0x0000001F
- *  PPI_STARTPPI	        0x0104	0x00000001
- *  DSI_STARTDSI	        0x0204	0x00000001
- *  VPCTRL			0x0450	0x01000120
- *  HTIM1			0x0454	0x002C0028
- *  VTIM1			0x045C	0x001E0008
- *  VFUEN			0x0464	0x00000001
- *  LVCFG			0x049C	0x00000001
- *
  * VPCTRL.EVTMODE (0x20) configuration bit is needed to determine whether
  * video timing information is delivered in pulse mode or event mode.
  * In pulse mode, both Sync Start and End packets are required.
@@ -337,15 +321,29 @@
  *
  * @param mfd
  *
- * @return register data value
+ * @return int
  */
 static int mipi_d2l_dsi_init_sequence(struct msm_fb_data_type *mfd)
 {
 	struct mipi_panel_info *mipi = &mfd->panel_info.mipi;
 	u32 lanes_enable;
 	u32 vpctrl;
-	u32 htime1 = 0x002C0028;
-	u32 vtime1 = 0x001E0008;
+	u32 htime1;
+	u32 vtime1;
+	u32 htime2;
+	u32 vtime2;
+	u32 ppi_tx_rx_ta; /* BTA Bus-Turn-Around */
+	u32 lvcfg;
+	u32 hbpr;	/* Horizontal Back Porch */
+	u32 hpw;	/* Horizontal Pulse Width */
+	u32 vbpr;	/* Vertical Back Porch */
+	u32 vpw;	/* Vertical Pulse Width */
+
+	u32 hfpr;	/* Horizontal Front Porch */
+	u32 hsize;	/* Horizontal Active size */
+	u32 vfpr;	/* Vertical Front Porch */
+	u32 vsize;	/* Vertical Active size */
+	bool vesa_rgb888 = false;
 
 	lanes_enable = 0x01; /* clock-lane enable */
 	lanes_enable |= (mipi->data_lane0 << 1);
@@ -363,48 +361,59 @@
 		return -EINVAL;
 	}
 
+	if (mfd->panel_info.clk_rate > 800*1000*1000) {
+		pr_err("%s.unsupported clk_rate %d.\n",
+		       __func__, mfd->panel_info.clk_rate);
+		return -EINVAL;
+	}
+
+	pr_debug("%s.xres=%d.yres=%d.fps=%d.dst_format=%d.\n",
+		__func__,
+		 mfd->panel_info.xres,
+		 mfd->panel_info.yres,
+		 mfd->panel_info.mipi.frame_rate,
+		 mfd->panel_info.mipi.dst_format);
+
+	hbpr = mfd->panel_info.lcdc.h_back_porch;
+	hpw	= mfd->panel_info.lcdc.h_pulse_width;
+	vbpr = mfd->panel_info.lcdc.v_back_porch;
+	vpw	= mfd->panel_info.lcdc.v_pulse_width;
+
+	htime1 = (hbpr << 16) + hpw;
+	vtime1 = (vbpr << 16) + vpw;
+
+	hfpr = mfd->panel_info.lcdc.h_front_porch;
+	hsize = mfd->panel_info.xres;
+	vfpr = mfd->panel_info.lcdc.v_front_porch;
+	vsize = mfd->panel_info.yres;
+
+	htime2 = (hfpr << 16) + hsize;
+	vtime2 = (vfpr << 16) + vsize;
+
+	lvcfg = 0x0003; /* PCLK=DCLK/3, Dual Link, LVEN */
+	vpctrl = 0x01000120; /* Output RGB888 , Event-Mode , */
+	ppi_tx_rx_ta = 0x00040004;
+
+	if (mfd->panel_info.xres == 1366) {
+		ppi_tx_rx_ta = 0x00040004;
+		lvcfg = 0x01; /* LVEN */
+		vesa_rgb888 = true;
+	}
+
+	if (mfd->panel_info.xres == 1200) {
+		lvcfg = 0x0103; /* PCLK=DCLK/4, Dual Link, LVEN */
+		vesa_rgb888 = true;
+	}
+
 	pr_debug("%s.htime1=0x%x.\n", __func__, htime1);
 	pr_debug("%s.vtime1=0x%x.\n", __func__, vtime1);
 	pr_debug("%s.vpctrl=0x%x.\n", __func__, vpctrl);
-	pr_debug("%s.lanes_enable=0x%x.\n", __func__, lanes_enable);
+	pr_debug("%s.lvcfg=0x%x.\n", __func__, lvcfg);
 
-
-
-#if defined(CONFIG_FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT)
-	/* VESA format instead of JEIDA format for RGB888 */
-	mipi_d2l_write_reg(mfd, LVMX0003, 0x03020100);
-	mipi_d2l_write_reg(mfd, LVMX0407, 0x08050704);
-	mipi_d2l_write_reg(mfd, LVMX0811, 0x0F0E0A09);
-	mipi_d2l_write_reg(mfd, LVMX1215, 0x100D0C0B);
-	mipi_d2l_write_reg(mfd, LVMX1619, 0x12111716);
-	mipi_d2l_write_reg(mfd, LVMX2023, 0x1B151413);
-	mipi_d2l_write_reg(mfd, LVMX2427, 0x061A1918);
-
-	mipi_d2l_write_reg(mfd, PPI_TX_RX_TA, 0x00030005); /* BTA */
-	mipi_d2l_write_reg(mfd, PPI_LPTXTIMECNT, 0x00000003);
-	mipi_d2l_write_reg(mfd, PPI_D0S_CLRSIPOCOUNT, 0x00000002);
-	mipi_d2l_write_reg(mfd, PPI_D1S_CLRSIPOCOUNT, 0x00000002);
-	mipi_d2l_write_reg(mfd, PPI_D2S_CLRSIPOCOUNT, 0x00000002);
-	mipi_d2l_write_reg(mfd, PPI_D3S_CLRSIPOCOUNT, 0x00000002);
-	mipi_d2l_write_reg(mfd, PPI_LANEENABLE, 0x0000001F);
-	mipi_d2l_write_reg(mfd, DSI_LANEENABLE, 0x0000001F);
-	mipi_d2l_write_reg(mfd, PPI_STARTPPI, 0x00000001);
-	mipi_d2l_write_reg(mfd, DSI_STARTDSI, 0x00000001);
-
-	mipi_d2l_write_reg(mfd, VPCTRL, 0x03F00121); /* RGB888 + Event mode */
-	mipi_d2l_write_reg(mfd, HTIM1, 0x00140114);
-	mipi_d2l_write_reg(mfd, HTIM2, 0x00340400);
-	mipi_d2l_write_reg(mfd, VTIM1, 0x0022000A);
-	mipi_d2l_write_reg(mfd, VTIM1, 0x00150258);
-	mipi_d2l_write_reg(mfd, VFUEN, 0x00000001);
-	mipi_d2l_write_reg(mfd, LVPHY0, 0x0044802D);
-	udelay(20);
-	mipi_d2l_write_reg(mfd, LVPHY0, 0x0004802D);
-	mipi_d2l_write_reg(mfd, LVCFG, 0x00000101);
-#else
 	mipi_d2l_write_reg(mfd, SYSRST, 0xFF);
 	msleep(30);
+
+	if (vesa_rgb888) {
 	/* VESA format instead of JEIDA format for RGB888 */
 	mipi_d2l_write_reg(mfd, LVMX0003, 0x03020100);
 	mipi_d2l_write_reg(mfd, LVMX0407, 0x08050704);
@@ -413,8 +422,9 @@
 	mipi_d2l_write_reg(mfd, LVMX1619, 0x12111716);
 	mipi_d2l_write_reg(mfd, LVMX2023, 0x1B151413);
 	mipi_d2l_write_reg(mfd, LVMX2427, 0x061A1918);
+	}
 
-	mipi_d2l_write_reg(mfd, PPI_TX_RX_TA, 0x00040004); /* BTA */
+	mipi_d2l_write_reg(mfd, PPI_TX_RX_TA, ppi_tx_rx_ta); /* BTA */
 	mipi_d2l_write_reg(mfd, PPI_LPTXTIMECNT, 0x00000004);
 	mipi_d2l_write_reg(mfd, PPI_D0S_CLRSIPOCOUNT, 0x00000003);
 	mipi_d2l_write_reg(mfd, PPI_D1S_CLRSIPOCOUNT, 0x00000003);
@@ -428,48 +438,14 @@
 	mipi_d2l_write_reg(mfd, VPCTRL, vpctrl); /* RGB888 + Event mode */
 	mipi_d2l_write_reg(mfd, HTIM1, htime1);
 	mipi_d2l_write_reg(mfd, VTIM1, vtime1);
+	mipi_d2l_write_reg(mfd, HTIM2, htime2);
+	mipi_d2l_write_reg(mfd, VTIM2, vtime2);
 	mipi_d2l_write_reg(mfd, VFUEN, 0x00000001);
-	mipi_d2l_write_reg(mfd, LVCFG, 0x00000001); /* Enables LVDS tx */
-#endif /* CONFIG_FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT */
-
+	mipi_d2l_write_reg(mfd, LVCFG, lvcfg); /* Enables LVDS tx */
 
 	return 0;
 }
 
-#if defined(CONFIG_FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT_PANEL) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT_PANEL)
-static int scale_pwm_dutycycle(int level)
-{
-
-	int scaled_level = 0;
-	if (level == BRIGHTNESS_OFF)
-		scaled_level = BRIGHTNESS_OFF;
-	else if (level <= BRIGHTNESS_DIM)
-		scaled_level = PWM_DUTY_MAX*DUTY_DIM;
-	else if (level <= BRIGHTNESS_MIN)
-		scaled_level = (level - BRIGHTNESS_DIM) *
-			(PWM_DUTY_MAX * DUTY_MIN - PWM_DUTY_MAX * DUTY_DIM) /
-			(BRIGHTNESS_MIN - BRIGHTNESS_DIM) +
-			PWM_DUTY_MAX * DUTY_DIM;
-	else if (level <= BRIGHTNESS_25)
-		scaled_level = (level - BRIGHTNESS_MIN) *
-			(PWM_DUTY_MAX * DUTY_25 - PWM_DUTY_MAX * DUTY_MIN) /
-			(BRIGHTNESS_25 - BRIGHTNESS_MIN) +
-			PWM_DUTY_MAX * DUTY_MIN;
-	else if (level <= BRIGHTNESS_DEFAULT)
-		scaled_level = (level - BRIGHTNESS_25) *
-			(PWM_DUTY_MAX * DUTY_DEFAULT - PWM_DUTY_MAX * DUTY_25)
-			/ (BRIGHTNESS_DEFAULT - BRIGHTNESS_25) +
-			PWM_DUTY_MAX * DUTY_25;
-	else if (level <= BRIGHTNESS_MAX)
-		scaled_level = (level - BRIGHTNESS_DEFAULT) *
-			(PWM_DUTY_MAX * DUTY_MAX - PWM_DUTY_MAX * DUTY_DEFAULT)
-			/ (BRIGHTNESS_MAX - BRIGHTNESS_DEFAULT) +
-			PWM_DUTY_MAX * DUTY_DEFAULT;
-	return scaled_level;
-}
-#endif
-
 /**
  * Set Backlight level.
  *
@@ -484,20 +460,11 @@
 
 	pr_debug("%s: level=%d.\n", __func__, level);
 
-#if defined(CONFIG_FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT_PANEL) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT_PANEL)
-	if ((pwm == NULL) || (level > BRIGHTNESS_MAX) || (level < 0)) {
-		pr_err("%s.pwm=NULL.\n", __func__);
-		return -EINVAL;
-	}
-
-	level = scale_pwm_dutycycle(level);
-#else
 	if ((pwm == NULL) || (level > PWM_LEVEL) || (level < 0)) {
 			pr_err("%s.pwm=NULL.\n", __func__);
 			return -EINVAL;
 		}
-#endif
+
 	ret = pwm_config(pwm, PWM_DUTY_LEVEL * level, PWM_PERIOD_USEC);
 	if (ret) {
 		pr_err("%s: pwm_config() failed err=%d.\n", __func__, ret);
@@ -511,24 +478,39 @@
 		return ret;
 	}
 
-
 	return 0;
 }
 
-#if defined(CONFIG_FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT)
-static void blenable_work_func(struct work_struct *work)
+/**
+ * Set TN CLK.
+ *
+ * @param pwm
+ * @param level
+ *
+ * @return int
+ */
+static int mipi_d2l_set_tn_clk(struct pwm_device *pwm, u32 usec)
 {
 	int ret = 0;
-	/* Set backlight via PWM */
-	if (bl_pwm) {
-		ret = mipi_d2l_set_backlight_level(bl_pwm, bl_level);
-		if (ret)
-			pr_err("%s.mipi_d2l_set_backlight_level.ret=%d",
+
+	pr_debug("%s: usec=%d.\n", __func__, usec);
+
+	ret = pwm_config(pwm, usec/2 , usec);
+	if (ret) {
+		pr_err("%s: pwm_config() failed err=%d.\n", __func__, ret);
+		return ret;
+	}
+
+	ret = pwm_enable(pwm);
+	if (ret) {
+		pr_err("%s: pwm_enable() failed err=%d\n",
 			       __func__, ret);
+		return ret;
 	}
+
+	return 0;
 }
-#endif
+
 /**
  * LCD ON.
  *
@@ -571,20 +553,14 @@
 		return ret;
 
 	mipi_d2l_write_reg(mfd, GPIOC, d2l_gpio_out_mask);
-	/* Set GPIOs: gpio#4=U/D=0 , gpio#3=L/R=1 , gpio#2,1=CABC=0. */
+	/* Set gpio#4=U/D=0, gpio#3=L/R=1 , gpio#2,1=CABC=0, gpio#0=NA. */
 	mipi_d2l_write_reg(mfd, GPIOO, d2l_gpio_out_val);
 
-#if defined(CONFIG_FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT_PANEL) \
-	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT_PANEL)
-	if ((bl_level == 0) && (!initial_powerseq)) {
-		bl_level = BRIGHTNESS_DEFAULT ; /* Default ON value */
-		INIT_DELAYED_WORK(&det_work, blenable_work_func);
-		schedule_delayed_work(&det_work, msecs_to_jiffies(250));
-	}
+	d2l_pwm_freq_hz = (3.921*1000);
 
-#else
-	if ((bl_level == 0) && (!initial_powerseq))
+	if (bl_level == 0)
 		bl_level = PWM_LEVEL * 2 / 3 ; /* Default ON value */
+
 	/* Set backlight via PWM */
 	if (bl_pwm) {
 		ret = mipi_d2l_set_backlight_level(bl_pwm, bl_level);
@@ -592,11 +568,16 @@
 			pr_err("%s.mipi_d2l_set_backlight_level.ret=%d",
 			       __func__, ret);
 	}
-#endif
+
+	mipi_d2l_read_status(mfd);
+
+	mipi_d2l_enable_3d(mfd, false, false);
+
+	/* Add I2C driver only after DSI-CLK is running */
+	if (d2l_i2c_client == NULL)
+		i2c_add_driver(&d2l_i2c_slave_driver);
 
 	pr_info("%s.ret=%d.\n", __func__, ret);
-	/* Set power on flag */
-	initial_powerseq = 1;
 
 	return ret;
 }
@@ -622,7 +603,7 @@
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
-	ret = mipi_d2l_set_backlight_level(bl_pwm, 0);
+	ret = mipi_d2l_set_backlight_level(bl_pwm, 1);
 
 	pr_info("%s.ret=%d.\n", __func__, ret);
 
@@ -646,6 +627,197 @@
 	.set_backlight = mipi_d2l_set_backlight,
 };
 
+static u32 d2l_i2c_read_reg(struct i2c_client *client, u16 reg)
+{
+	int rc;
+	u32 val = 0;
+	u8 buf[6];
+
+	if (client == NULL) {
+		pr_err("%s.invalid i2c client.\n", __func__);
+		return -EINVAL;
+	}
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xFF;
+
+	rc = i2c_master_send(client, buf, sizeof(reg));
+	rc = i2c_master_recv(client, buf, 4);
+
+	if (rc >= 0) {
+		val = buf[0] + (buf[1] << 8) + (buf[2] << 16) + (buf[3] << 24);
+		pr_debug("%s.reg=0x%x.val=0x%x.\n", __func__, reg, val);
+	} else
+		pr_err("%s.fail.reg=0x%x.\n", __func__, reg);
+
+	return val;
+}
+
+static u32 d2l_i2c_write_reg(struct i2c_client *client, u16 reg, u32 val)
+{
+	int rc;
+	u8 buf[6];
+
+	if (client == NULL) {
+		pr_err("%s.invalid i2c client.\n", __func__);
+		return -EINVAL;
+	}
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xFF;
+
+	buf[2] = (val >> 0) & 0xFF;
+	buf[3] = (val >> 8) & 0xFF;
+	buf[4] = (val >> 16) & 0xFF;
+	buf[5] = (val >> 24) & 0xFF;
+
+	rc = i2c_master_send(client, buf, sizeof(buf));
+
+	if (rc >= 0)
+		pr_debug("%s.reg=0x%x.val=0x%x.\n", __func__, reg, val);
+	else
+		pr_err("%s.fail.reg=0x%x.\n", __func__, reg);
+
+	return val;
+}
+
+static int __devinit d2l_i2c_slave_probe(struct i2c_client *client,
+					 const struct i2c_device_id *id)
+{
+	static const u32 i2c_funcs = I2C_FUNC_I2C;
+
+	d2l_i2c_client = client;
+
+	if (!i2c_check_functionality(client->adapter, i2c_funcs)) {
+		pr_err("%s.i2c_check_functionality failed.\n", __func__);
+		return -ENOSYS;
+	} else {
+		pr_debug("%s.i2c_check_functionality OK.\n", __func__);
+	}
+
+	d2l_i2c_read_reg(client, IDREG);
+
+	mipi_d2l_read_status_via_i2c(d2l_i2c_client);
+
+	return 0;
+}
+
+static __devexit int d2l_i2c_slave_remove(struct i2c_client *client)
+{
+	d2l_i2c_client = NULL;
+
+	return 0;
+}
+
+static const struct i2c_device_id d2l_i2c_id[] = {
+	{"tc358764-i2c", 0},
+	{}
+};
+
+static struct i2c_driver d2l_i2c_slave_driver = {
+	.driver = {
+		.name = "tc358764-i2c",
+		.owner = THIS_MODULE
+	},
+	.probe    = d2l_i2c_slave_probe,
+	.remove   = __devexit_p(d2l_i2c_slave_remove),
+	.id_table = d2l_i2c_id,
+};
+
+static int mipi_d2l_enable_3d(struct msm_fb_data_type *mfd,
+			      bool enable, bool mode)
+{
+	u32 tn_usec = 1000000 / 66; /* 66 HZ */
+
+	pr_debug("%s.enable=%d.mode=%d.\n", __func__, enable, mode);
+
+	gpio_direction_output(d2l_3d_gpio_enable, enable);
+	gpio_direction_output(d2l_3d_gpio_mode, mode);
+
+	mipi_d2l_set_tn_clk(tn_pwm, tn_usec);
+
+	return 0;
+}
+
+static ssize_t mipi_d2l_enable_3d_read(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	return snprintf((char *)buf, sizeof(buf), "%u\n", d2l_enable_3d);
+}
+
+static ssize_t mipi_d2l_enable_3d_write(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf,
+				size_t count)
+{
+	int ret = -1;
+	u32 data = 0;
+
+	if (sscanf((char *)buf, "%u", &data) != 1) {
+		dev_err(dev, "%s. Invalid input.\n", __func__);
+		ret = -EINVAL;
+	} else {
+		d2l_enable_3d = data;
+		if (data == 1) /* LANDSCAPE */
+			mipi_d2l_enable_3d(d2l_mfd, true, true);
+		else if (data == 2) /* PORTRAIT */
+			mipi_d2l_enable_3d(d2l_mfd, true, false);
+		else if (data == 0)
+			mipi_d2l_enable_3d(d2l_mfd, false, false);
+		else if (data == 9)
+			mipi_d2l_read_status_via_i2c(d2l_i2c_client);
+		else
+			pr_err("%s.Invalid value=%d.\n", __func__, data);
+	}
+
+	return count;
+}
+
+static struct device_attribute mipi_d2l_3d_barrier_attributes[] = {
+	__ATTR(enable_3d_barrier, 0666,
+	       mipi_d2l_enable_3d_read,
+	       mipi_d2l_enable_3d_write),
+};
+
+static int mipi_dsi_3d_barrier_sysfs_register(struct device *dev)
+{
+	int ret;
+
+	pr_debug("%s.d2l_3d_gpio_enable=%d.\n", __func__, d2l_3d_gpio_enable);
+	pr_debug("%s.d2l_3d_gpio_mode=%d.\n", __func__, d2l_3d_gpio_mode);
+
+	ret  = device_create_file(dev, mipi_d2l_3d_barrier_attributes);
+	if (ret) {
+		pr_err("%s.failed to create 3D sysfs.\n", __func__);
+		goto err_device_create_file;
+	}
+
+	ret = gpio_request(d2l_3d_gpio_enable, "d2l_3d_gpio_enable");
+	if (ret) {
+		pr_err("%s.failed to get d2l_3d_gpio_enable=%d.\n",
+		       __func__, d2l_3d_gpio_enable);
+		goto err_d2l_3d_gpio_enable;
+	}
+
+	ret = gpio_request(d2l_3d_gpio_mode, "d2l_3d_gpio_mode");
+	if (ret) {
+		pr_err("%s.failed to get d2l_3d_gpio_mode=%d.\n",
+		       __func__, d2l_3d_gpio_mode);
+		goto err_d2l_3d_gpio_mode;
+	}
+
+	return 0;
+
+err_d2l_3d_gpio_mode:
+	gpio_free(d2l_3d_gpio_enable);
+err_d2l_3d_gpio_enable:
+	device_remove_file(dev, mipi_d2l_3d_barrier_attributes);
+err_device_create_file:
+
+	return ret;
+}
+
 /**
  * Probe for device.
  *
@@ -666,10 +838,8 @@
 	pr_debug("%s.id=%d.\n", __func__, pdev->id);
 
 	if (pdev->id == 0) {
-		/* d2l_common_pdata = platform_get_drvdata(pdev); */
 		d2l_common_pdata = pdev->dev.platform_data;
 
-
 		if (d2l_common_pdata == NULL) {
 			pr_err("%s: no PWM gpio specified.\n", __func__);
 			return 0;
@@ -678,6 +848,8 @@
 		led_pwm = d2l_common_pdata->gpio_num[0];
 		d2l_gpio_out_mask = d2l_common_pdata->gpio_num[1] >> 8;
 		d2l_gpio_out_val = d2l_common_pdata->gpio_num[1] & 0xFF;
+		d2l_3d_gpio_enable = d2l_common_pdata->gpio_num[2];
+		d2l_3d_gpio_mode = d2l_common_pdata->gpio_num[3];
 
 		mipi_dsi_buf_alloc(&d2l_tx_buf, DSI_BUF_SIZE);
 		mipi_dsi_buf_alloc(&d2l_rx_buf, DSI_BUF_SIZE);
@@ -704,10 +876,20 @@
 
 		}
 	} else {
-		pr_info("%s. led_pwm is invalid.\n", __func__);
+		pr_err("%s. led_pwm is invalid.\n", __func__);
+	}
+
+	tn_pwm = pwm_request(1, "3D_TN_clk");
+	if (tn_pwm == NULL || IS_ERR(tn_pwm)) {
+		pr_err("%s pwm_request() failed.id=%d.tn_pwm=%d.\n",
+		       __func__, 1, (int) tn_pwm);
+		tn_pwm = NULL;
+		return -EIO;
+	} else {
+		pr_debug("%s.pwm_request() ok.pwm-id=%d.\n", __func__, 1);
+
 	}
 
-	/* pinfo = platform_get_drvdata(pdev); */
 	pinfo = pdev->dev.platform_data;
 
 	if (pinfo == NULL) {
@@ -721,6 +903,9 @@
 
 	msm_fb_add_device(pdev);
 
+	if (pinfo->is_3d_panel)
+		mipi_dsi_3d_barrier_sysfs_register(&(pdev->dev));
+
 	return ret;
 }
 
@@ -804,6 +989,9 @@
 static int mipi_d2l_init(void)
 {
 	pr_debug("%s.\n", __func__);
+
+	d2l_i2c_client = NULL;
+
 	return platform_driver_register(&d2l_driver);
 }
 
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_tc358764_dsi2lvds.h msm/mipi_tc358764_dsi2lvds.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_tc358764_dsi2lvds.h	2012-07-16 10:04:32.215489770 -0700
+++ msm/mipi_tc358764_dsi2lvds.h	2012-08-14 12:32:39.583339476 -0700
@@ -14,6 +14,8 @@
 #ifndef MIPI_TC358764_DSI2LVDS_H
 #define MIPI_TC358764_DSI2LVDS_H
 
+#define PWM_LEVEL 255
+
 int mipi_tc358764_dsi2lvds_register(struct msm_panel_info *pinfo,
 	u32 channel_id, u32 panel_id);
 #endif  /* MIPI_TC358764_DSI2LVDS_H */
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_toshiba.h msm/mipi_toshiba.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_toshiba.h	2012-07-16 10:04:32.215489770 -0700
+++ msm/mipi_toshiba.h	2012-08-14 12:32:39.583339476 -0700
@@ -23,7 +23,7 @@
 
 #define MIPI_TOSHIBA_PWM_FREQ_HZ 300
 #define MIPI_TOSHIBA_PWM_PERIOD_USEC (USEC_PER_SEC / MIPI_TOSHIBA_PWM_FREQ_HZ)
-#define MIPI_TOSHIBA_PWM_LEVEL 100
+#define MIPI_TOSHIBA_PWM_LEVEL 255
 #define MIPI_TOSHIBA_PWM_DUTY_LEVEL \
 	(MIPI_TOSHIBA_PWM_PERIOD_USEC / MIPI_TOSHIBA_PWM_LEVEL)
 
Only in msm: mipi_truly_tft540960_1_e.c
Only in msm: mipi_truly_tft540960_1_e_cmd_qhd_pt.c
Only in msm: mipi_truly_tft540960_1_e.h
Only in msm: mipi_truly_tft540960_1_e_video_qhd_pt.c
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_truly_video_wvga_pt.c msm/mipi_truly_video_wvga_pt.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/mipi_truly_video_wvga_pt.c	2012-07-16 10:04:32.215489770 -0700
+++ msm/mipi_truly_video_wvga_pt.c	2012-08-14 12:32:39.583339476 -0700
@@ -38,10 +38,8 @@
 {
 	int ret;
 
-#ifdef CONFIG_FB_MSM_MIPI_PANEL_DETECT
 	if (msm_fb_detect_client("mipi_video_truly_wvga"))
 		return 0;
-#endif
 
 	pinfo.xres = 480;
 	pinfo.yres = 800;
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_dss_io_7x27a.c msm/msm_dss_io_7x27a.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_dss_io_7x27a.c	2012-08-08 09:32:42.854525952 -0700
+++ msm/msm_dss_io_7x27a.c	2012-08-14 12:32:48.902338839 -0700
@@ -317,6 +317,24 @@
 
 void cont_splash_clk_ctrl(int enable)
 {
+	static int cont_splash_clks_enabled;
+	if (enable && !cont_splash_clks_enabled) {
+		clk_prepare_enable(dsi_ref_clk);
+		clk_prepare_enable(mdp_dsi_pclk);
+		clk_prepare_enable(dsi_byte_div_clk);
+		clk_prepare_enable(dsi_esc_clk);
+		clk_prepare_enable(dsi_pixel_clk);
+		clk_prepare_enable(dsi_clk);
+		cont_splash_clks_enabled = 1;
+	} else if (!enable && cont_splash_clks_enabled) {
+		clk_disable_unprepare(dsi_clk);
+		clk_disable_unprepare(dsi_pixel_clk);
+		clk_disable_unprepare(dsi_esc_clk);
+		clk_disable_unprepare(dsi_byte_div_clk);
+		clk_disable_unprepare(mdp_dsi_pclk);
+		clk_disable_unprepare(dsi_ref_clk);
+		cont_splash_clks_enabled = 0;
+	}
 }
 
 void mipi_dsi_prepare_clocks(void)
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_dss_io_8960.c msm/msm_dss_io_8960.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_dss_io_8960.c	2012-08-08 09:32:42.855525952 -0700
+++ msm/msm_dss_io_8960.c	2012-08-14 12:32:39.584339475 -0700
@@ -11,6 +11,7 @@
  *
  */
 #include <linux/clk.h>
+#include <mach/clk.h>
 #include "msm_fb.h"
 #include "mdp.h"
 #include "mdp4.h"
@@ -318,10 +319,6 @@
 		i++;
 		if (i > term_cnt) {
 			pr_err("DSI1 PHY NOT READY, exceeded polling TIMEOUT!\n");
-			/*adding Fatal error to check proper stack*/
-			#if defined(CONFIG_MACH_JAGUAR)
-			panic("mipi_dsi_phy_rdy_poll_timeout!!!\n");
-			#endif
 			break;
 		}
 		phy_pll_busy = MIPI_INP(MIPI_DSI_BASE + 0x280);
@@ -575,9 +572,7 @@
 		off += 4;
 	}
 
-	if (!panel_info)
-		pr_err("%s: panel_info not initialized\n", __func__);
-	else
+	if (panel_info)
 		mipi_dsi_phy_pll_config(panel_info->clk_rate);
 
 	/* pll ctrl 0 */
@@ -752,10 +747,13 @@
 
 void hdmi_msm_reset_core(void)
 {
-	hdmi_msm_set_mode(FALSE);
 	hdmi_msm_clk(0);
 	udelay(5);
 	hdmi_msm_clk(1);
+
+	clk_reset(hdmi_msm_state->hdmi_app_clk, CLK_RESET_ASSERT);
+	udelay(20);
+	clk_reset(hdmi_msm_state->hdmi_app_clk, CLK_RESET_DEASSERT);
 }
 
 void hdmi_msm_init_phy(int video_format)
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_dss_io_8x60.c msm/msm_dss_io_8x60.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_dss_io_8x60.c	2012-08-08 09:32:42.855525952 -0700
+++ msm/msm_dss_io_8x60.c	2012-08-14 12:32:39.584339475 -0700
@@ -548,7 +548,6 @@
 
 void hdmi_msm_reset_core(void)
 {
-	hdmi_msm_set_mode(FALSE);
 	hdmi_msm_clk(0);
 	udelay(5);
 	hdmi_msm_clk(1);
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_fb.c msm/msm_fb.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_fb.c	2012-08-08 11:46:04.950978767 -0700
+++ msm/msm_fb.c	2012-08-14 12:32:48.903338840 -0700
@@ -42,9 +42,6 @@
 #include <linux/leds.h>
 #include <linux/pm_runtime.h>
 
-#ifdef CONFIG_SEC_DEBUG
-#include <mach/sec_debug.h>
-#endif
 #define MSM_FB_C
 #include "msm_fb.h"
 #include "mddihosti.h"
@@ -110,6 +107,9 @@
 static int msm_fb_ioctl(struct fb_info *info, unsigned int cmd,
 			unsigned long arg);
 static int msm_fb_mmap(struct fb_info *info, struct vm_area_struct * vma);
+static int mdp_bl_scale_config(struct msm_fb_data_type *mfd,
+						struct mdp_bl_scale_data *data);
+static void msm_fb_scale_bl(__u32 *bl_lvl);
 
 #ifdef MSM_FB_ENABLE_DBGFS
 
@@ -119,6 +119,7 @@
 int msm_fb_debugfs_file_index;
 struct dentry *msm_fb_debugfs_root;
 struct dentry *msm_fb_debugfs_file[MSM_FB_MAX_DBGFS];
+static int bl_scale, bl_min_lvl;
 
 DEFINE_MUTEX(msm_fb_notify_update_sem);
 void msmfb_no_update_notify_timer_cb(unsigned long data)
@@ -277,6 +278,9 @@
 	case HDMI_PANEL:
 		ret = snprintf(buf, PAGE_SIZE, "hdmi panel\n");
 		break;
+	case LVDS_PANEL:
+		ret = snprintf(buf, PAGE_SIZE, "lvds panel\n");
+		break;
 	case DTV_PANEL:
 		ret = snprintf(buf, PAGE_SIZE, "dtv panel\n");
 		break;
@@ -373,6 +377,8 @@
 	vsync_cntrl.dev = mfd->fbi->dev;
 	mfd->panel_info.frame_count = 0;
 	mfd->bl_level = 0;
+	bl_scale = 1024;
+	bl_min_lvl = 255;
 #ifdef CONFIG_FB_MSM_OVERLAY
 	mfd->overlay_play_enable = 1;
 #endif
@@ -411,13 +417,13 @@
 
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
 
-	if (!mfd)
-		return -ENODEV;
-
 	msm_fb_remove_sysfs(pdev);
 
 	pm_runtime_disable(mfd->fbi->dev);
 
+	if (!mfd)
+		return -ENODEV;
+
 	if (mfd->key != MFD_KEY)
 		return -EINVAL;
 
@@ -576,9 +582,6 @@
 				      mfd->op_enable);
 		if (ret)
 			MSM_FB_INFO("msm_fb_resume: can't turn on display!\n");
-	} else {
-		if (pdata->power_ctrl)
-			pdata->power_ctrl(TRUE);
 	}
 
 	return ret;
@@ -634,29 +637,49 @@
 static int msm_fb_ext_suspend(struct device *dev)
 {
 	struct msm_fb_data_type *mfd = dev_get_drvdata(dev);
+	struct msm_fb_panel_data *pdata = NULL;
 	int ret = 0;
 
 	if ((!mfd) || (mfd->key != MFD_KEY))
 		return 0;
 
+	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
 	if (mfd->panel_info.type == HDMI_PANEL ||
-		mfd->panel_info.type == DTV_PANEL)
+		mfd->panel_info.type == DTV_PANEL) {
 		ret = msm_fb_suspend_sub(mfd);
 
+		/* Turn off the HPD circuitry */
+		if (pdata->power_ctrl) {
+			MSM_FB_INFO("%s: Turning off HPD circuitry\n",
+					__func__);
+			pdata->power_ctrl(FALSE);
+		}
+	}
+
 	return ret;
 }
 
 static int msm_fb_ext_resume(struct device *dev)
 {
 	struct msm_fb_data_type *mfd = dev_get_drvdata(dev);
+	struct msm_fb_panel_data *pdata = NULL;
 	int ret = 0;
 
 	if ((!mfd) || (mfd->key != MFD_KEY))
 		return 0;
 
+	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
 	if (mfd->panel_info.type == HDMI_PANEL ||
-		mfd->panel_info.type == DTV_PANEL)
+		mfd->panel_info.type == DTV_PANEL) {
+		/* Turn on the HPD circuitry */
+		if (pdata->power_ctrl) {
+			pdata->power_ctrl(TRUE);
+			MSM_FB_INFO("%s: Turning on HPD circuitry\n",
+					__func__);
+		}
+
 		ret = msm_fb_resume_sub(mfd);
+	}
 
 	return ret;
 }
@@ -730,11 +753,41 @@
 
 static int unset_bl_level, bl_updated;
 static int bl_level_old;
+static int mdp_bl_scale_config(struct msm_fb_data_type *mfd,
+						struct mdp_bl_scale_data *data)
+{
+	int ret = 0;
+	int curr_bl = mfd->bl_level;
+	bl_scale = data->scale;
+	bl_min_lvl = data->min_lvl;
+	pr_debug("%s: update scale = %d, min_lvl = %d\n", __func__, bl_scale,
+								bl_min_lvl);
+
+	/* update current backlight to use new scaling*/
+	msm_fb_set_backlight(mfd, curr_bl);
+
+	return ret;
+}
+
+static void msm_fb_scale_bl(__u32 *bl_lvl)
+{
+	__u32 temp = *bl_lvl;
+	if (temp >= bl_min_lvl) {
+		/* bl_scale is the numerator of scaling fraction (x/1024)*/
+		temp = ((*bl_lvl) * bl_scale) / 1024;
+
+		/*if less than minimum level, use min level*/
+		if (temp < bl_min_lvl)
+			temp = bl_min_lvl;
+	}
+
+	(*bl_lvl) = temp;
+}
 
 void msm_fb_set_backlight(struct msm_fb_data_type *mfd, __u32 bkl_lvl)
 {
 	struct msm_fb_panel_data *pdata;
-
+	__u32 temp = bkl_lvl;
 	if (!mfd->panel_power_on || !bl_updated) {
 		unset_bl_level = bkl_lvl;
 		return;
@@ -742,17 +795,19 @@
 		unset_bl_level = 0;
 	}
 
+	msm_fb_scale_bl(&temp);
 	pdata = (struct msm_fb_panel_data *)mfd->pdev->dev.platform_data;
 
 	if ((pdata) && (pdata->set_backlight)) {
 		down(&mfd->sem);
-		if (bl_level_old == bkl_lvl) {
+		if (bl_level_old == temp) {
 			up(&mfd->sem);
 			return;
 		}
-		mfd->bl_level = bkl_lvl;
+		mfd->bl_level = temp;
 		pdata->set_backlight(mfd);
-		bl_level_old = mfd->bl_level;
+		mfd->bl_level = bkl_lvl;
+		bl_level_old = temp;
 		up(&mfd->sem);
 	}
 }
@@ -814,9 +869,6 @@
 				mfd->panel_power_on = curr_pwr_state;
 
 			mfd->op_enable = TRUE;
-		} else {
-			if (pdata->power_ctrl)
-				pdata->power_ctrl(FALSE);
 		}
 		break;
 	}
@@ -916,19 +968,6 @@
 static int msm_fb_blank(int blank_mode, struct fb_info *info)
 {
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
-#if defined(CONFIG_MACH_JAGUAR) ||\
-	defined(CONFIG_FB_MSM_MIPI_NOVATEK_CMD_WVGA_PT) ||\
-	defined(CONFIG_FB_MSM_MIPI_NOVATEK_BOE_CMD_WVGA_PT) ||\
-	defined(CONFIG_FB_MSM_MIPI_BOEOT_TFT_VIDEO_WSVGA_PT) ||\
-	defined(CONFIG_FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WXGA_PT_PANEL)
-
-	/* it has to be removed when LDI fix the gabage screen issue. */
-	if (mfd->panel_info.pdest == DISPLAY_1 &&
-		blank_mode == FB_BLANK_POWERDOWN)
-		return 0;
-#endif
-	printk(KERN_INFO "%s blank_mode : %d mfd->op_enable : %d",
-			__func__ , blank_mode, mfd->op_enable);
 	return msm_fb_blank_sub(blank_mode, info, mfd->op_enable);
 }
 
@@ -943,110 +982,6 @@
 	return 0;
 }
 
-/* if the acutal line length is not the same as var->fix_line_length
- * the frame capture by ddms may broken. Hence we must fix here.
- */
-static ssize_t msm_fb_read(struct fb_info *info, char __user *buf,
-						size_t count, loff_t *ppos)
-{
-	unsigned long p = *ppos;
-	struct fb_var_screeninfo *var = &info->var;
-	struct fb_fix_screeninfo *fix = &info->fix;
-
-	u8 *buffer, *dst;
-	u8 __iomem *src;
-	int c, cnt = 0, err = 0;
-	unsigned long total_size;
-	int dummy_left = 0, dummy_right = 0;
-	int line_offset = 0, actual_line_length = 0;
-	int need_fix = 0, avoid_dead = 0;
-
-	total_size = info->fix.smem_len;
-
-	if (p >= total_size)
-		return 0;
-
-	if (count >= total_size)
-		count = total_size;
-
-	if (count + p > total_size)
-		count = total_size - p;
-
-	buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count,
-			 GFP_KERNEL);
-	if (!buffer)
-		return -ENOMEM;
-
-	actual_line_length = var->xres * var->bits_per_pixel / 8;
-	if (var->yoffset)
-		p = p  - (actual_line_length * var->yoffset)
-			+ (fix->line_length * var->yoffset);
-
-	src = (u8 __iomem *) (info->screen_base + p);
-
-	if (fix->line_length != actual_line_length) {
-		line_offset = (p / fix->line_length) * fix->line_length;
-		dummy_left = line_offset + actual_line_length;
-		dummy_right = line_offset + fix->line_length;
-
-		if ((p + count) > dummy_left)
-			need_fix = 1;
-	}
-
-	if (need_fix && dummy_left && dummy_right && (count < PAGE_SIZE)) {
-		c = 0;
-		cnt = 0;
-
-		while (count) {
-			while (((c + p) >= dummy_left) &&
-					((c + p) < dummy_right) &&
-					(avoid_dead < PAGE_SIZE)) {
-				avoid_dead++;
-				c++;
-			}
-
-			if ((unsigned long)(src + c) >
-				(unsigned long)(info->screen_base
-							+ total_size)) {
-				pr_info("Accessing memory address error!!\n");
-				break;
-			}
-
-			*(buffer + cnt) = *(src + c);
-			count--;
-			cnt++;
-			c++;
-
-			avoid_dead = 0;
-		}
-
-		if (copy_to_user(buf, buffer, cnt))
-				err = -EFAULT;
-
-		*ppos += c;
-	} else {
-		while (count) {
-			c  = (count > PAGE_SIZE) ? PAGE_SIZE : count;
-			dst = buffer;
-			fb_memcpy_fromfb(dst, src, c);
-			dst += c;
-			src += c;
-
-			if (copy_to_user(buf, buffer, c)) {
-				err = -EFAULT;
-				break;
-			}
-			*ppos += c;
-			buf += c;
-			cnt += c;
-			count -= c;
-		}
-	}
-	kfree(buffer);
-
-	return (err) ? err : cnt;
-}
-
 /*
  * Custom Framebuffer mmap() function for MSM driver.
  * Differs from standard mmap() function by allowing for customized
@@ -1107,7 +1042,7 @@
 	.owner = THIS_MODULE,
 	.fb_open = msm_fb_open,
 	.fb_release = msm_fb_release,
-	.fb_read = msm_fb_read,
+	.fb_read = NULL,
 	.fb_write = NULL,
 	.fb_cursor = NULL,
 	.fb_check_var = msm_fb_check_var,	/* vinfo check */
@@ -1301,7 +1236,6 @@
 	 * calculate smem_len based on max size of two supplied modes.
 	 * Only fb0 has mem. fb1 and fb2 don't have mem.
 	 */
-
 	if (!bf_supported || mfd->index == 0)
 		fix->smem_len = MAX((msm_fb_line_length(mfd->index,
 							panel_info->xres,
@@ -1328,13 +1262,6 @@
 
 	var->xres = panel_info->xres;
 	var->yres = panel_info->yres;
-#if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OLED_VIDEO_HD_PT)
-	var->height = panel_info->height;/* height of picture in mm */
-	var->width = panel_info->width;/* width of picture in mm */
-#else
-	var->height = -1;/* height of picture in mm */
-	var->width = -1;/* width of picture in mm */
-#endif
 	var->xres_virtual = panel_info->xres;
 	var->yres_virtual = panel_info->yres * mfd->fb_page +
 		((PAGE_SIZE - remainder)/fix->line_length) * mfd->fb_page;
@@ -1438,17 +1365,9 @@
 	fbi->fix.smem_start = (unsigned long)fbram_phys;
 
 	msm_iommu_map_contig_buffer(fbi->fix.smem_start,
-					DISPLAY_WRITE_DOMAIN,
-					GEN_POOL,
-					fbi->fix.smem_len * 2,
-					SZ_4K,
-					0,
-					&(mfd->display_iova));
-
-	msm_iommu_map_contig_buffer(fbi->fix.smem_start,
 					DISPLAY_READ_DOMAIN,
 					GEN_POOL,
-					fbi->fix.smem_len * 2,
+					fbi->fix.smem_len,
 					SZ_4K,
 					0,
 					&(mfd->display_iova));
@@ -1456,7 +1375,7 @@
 	msm_iommu_map_contig_buffer(fbi->fix.smem_start,
 					ROTATOR_SRC_DOMAIN,
 					GEN_POOL,
-					fbi->fix.smem_len * 2,
+					fbi->fix.smem_len,
 					SZ_4K,
 					0,
 					&(mfd->rotator_iova));
@@ -1469,22 +1388,10 @@
 
 	/* cursor memory allocation */
 	if (mfd->cursor_update) {
-		unsigned long cursor_buf_iommu = 0;
 		mfd->cursor_buf = dma_alloc_coherent(NULL,
 					MDP_CURSOR_SIZE,
 					(dma_addr_t *) &mfd->cursor_buf_phys,
 					GFP_KERNEL);
-
-		msm_iommu_map_contig_buffer((unsigned long)mfd->cursor_buf_phys,
-					    DISPLAY_READ_DOMAIN,
-					    GEN_POOL,
-					    MDP_CURSOR_SIZE,
-					    SZ_4K,
-					    0,
-					    &cursor_buf_iommu);
-		if (cursor_buf_iommu)
-			mfd->cursor_buf_phys = (void *)cursor_buf_iommu;
-
 		if (!mfd->cursor_buf)
 			mfd->cursor_update = 0;
 	}
@@ -1518,24 +1425,15 @@
 	    ("FrameBuffer[%d] %dx%d size=%d bytes is registered successfully!\n",
 	     mfd->index, fbi->var.xres, fbi->var.yres, fbi->fix.smem_len);
 
-	if (mfd->panel_info.type != DTV_PANEL) {
 #ifdef CONFIG_FB_MSM_LOGO
-#ifndef MSM_RGB_LOGO
-		if (!poweroff_charging)
-			load_565rle_image(INIT_IMAGE_FILE, bf_supported);	/*Flip buffer*/
-		else
-			pr_info("Skipping Init Image...");
-#else
-		draw_rgb888_screen();
-#endif
+	/* Flip buffer */
+	if (!load_565rle_image(INIT_IMAGE_FILE, bf_supported))
+		;
 #endif
-	}
 	ret = 0;
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
-	if (hdmi_prim_display ||
-	    (mfd->panel_info.type != DTV_PANEL &&
-	     mfd->panel_info.type != WRITEBACK_PANEL)) {
+	if (mfd->panel_info.type != DTV_PANEL) {
 		mfd->early_suspend.suspend = msmfb_early_suspend;
 		mfd->early_suspend.resume = msmfb_early_resume;
 		mfd->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB - 2;
@@ -1682,7 +1580,6 @@
 
 	if (result < 0) {
 		printk(KERN_ERR "pm_runtime: fail to wake up\n");
-		return -ENODEV;
 	}
 
 	if (info->node == 0 && !(mfd->cont_splash_done)) {	/* primary */
@@ -1698,15 +1595,11 @@
 			pr_debug("%s:%d no mdp_set_dma_pan_info %d\n",
 				__func__, __LINE__, info->node);
 
-		if (mfd->panel_info.type != DTV_PANEL) {
-			if (msm_fb_blank_sub(FB_BLANK_UNBLANK, info,
-							mfd->op_enable)) {
-				printk(KERN_ERR "msm_fb_open: "
-						"can't turn on display!\n");
+		if (msm_fb_blank_sub(FB_BLANK_UNBLANK, info, mfd->op_enable)) {
+			printk(KERN_ERR "msm_fb_open: can't turn on display!\n");
 				return -1;
 			}
 		}
-	}
 
 	mfd->ref_cnt++;
 	return 0;
@@ -3023,9 +2916,7 @@
 		if ((pdata) && (pdata->set_backlight)) {
 			down(&mfd->sem);
 			mfd->bl_level = unset_bl_level;
-#if !defined(CONFIG_MACH_GOGH)/*Backlight is set in mipi_novatek_disp_on*/
 			pdata->set_backlight(mfd);
-#endif
 			bl_level_old = unset_bl_level;
 			up(&mfd->sem);
 			bl_updated = 1;
@@ -3296,7 +3187,8 @@
 	return 0;
 }
 
-static int msmfb_handle_pp_ioctl(struct msmfb_mdp_pp *pp_ptr)
+static int msmfb_handle_pp_ioctl(struct msm_fb_data_type *mfd,
+						struct msmfb_mdp_pp *pp_ptr)
 {
 	int ret = -1;
 
@@ -3341,6 +3233,11 @@
 						&pp_ptr->data.qseed_cfg_data);
 		break;
 #endif
+	case mdp_bl_scale_cfg:
+		ret = mdp_bl_scale_config(mfd, (struct mdp_bl_scale_data *)
+				&pp_ptr->data.bl_scale_data);
+		break;
+
 	default:
 		pr_warn("Unsupported request to MDP_PP IOCTL.\n");
 		ret = -EINVAL;
@@ -3591,25 +3488,25 @@
 		if (!mfd->panel_power_on)
 			return -EPERM;
 
-		if (!mfd->do_histogram)
+		if (!mfd->start_histogram)
 			return -ENODEV;
 
 		ret = copy_from_user(&hist_req, argp, sizeof(hist_req));
 		if (ret)
 			return ret;
 
-		ret = mdp_histogram_start(&hist_req);
+		ret = mfd->start_histogram(&hist_req);
 		break;
 
 	case MSMFB_HISTOGRAM_STOP:
-		if (!mfd->do_histogram)
+		if (!mfd->stop_histogram)
 			return -ENODEV;
 
 		ret = copy_from_user(&block, argp, sizeof(int));
 		if (ret)
 			return ret;
 
-		ret = mdp_histogram_stop(info, block);
+		ret = mfd->stop_histogram(info, block);
 		break;
 
 
@@ -3663,7 +3560,7 @@
 		if (ret)
 			return ret;
 
-		ret = msmfb_handle_pp_ioctl(&mdp_pp);
+		ret = msmfb_handle_pp_ioctl(mfd, &mdp_pp);
 		break;
 
 	default:
@@ -3825,54 +3722,10 @@
 		fbi_list_index--;
 		return NULL;
 	}
-#ifdef CONFIG_SEC_DEBUG
-	if (fbi_list_index == 1) {
-		sec_getlog_supply_fbinfo((void *)(fbi->fix.smem_start),
-				ALIGN(fbi->var.xres, 32),
-				fbi->var.yres,
-				fbi->var.bits_per_pixel,
-				2);
-	}
-
-#endif
 	return this_dev;
 }
 EXPORT_SYMBOL(msm_fb_add_device);
 
-#ifdef CONFIG_SEC_DEBUG_SUBSYS
-int get_fbinfo(int fb_num, unsigned int *fb_paddr, unsigned int *xres,
-		unsigned int *yres, unsigned int *bpp,
-		unsigned char *roff, unsigned char *rlen,
-		unsigned char *goff, unsigned char *glen,
-		unsigned char *boff, unsigned char *blen,
-		unsigned char *aoff, unsigned char *alen)
-{
-	struct fb_info *info;
-
-	if (fb_num >= MAX_FBI_LIST)
-		return -1;
-
-	info = fbi_list[fb_num];
-	if (!info)
-		return -1;
-
-	*fb_paddr = (unsigned int)info->fix.smem_start;
-	*xres = ALIGN(info->var.xres, 32);
-	*yres = info->var.yres;
-	*bpp = info->var.bits_per_pixel;
-	*roff = info->var.red.offset;
-	*rlen = info->var.red.length;
-	*goff = info->var.green.offset;
-	*glen = info->var.green.length;
-	*boff = info->var.blue.offset;
-	*blen = info->var.blue.length;
-	*aoff = info->var.transp.offset;
-	*alen = info->var.transp.length;
-
-	return 0;
-}
-#endif
-
 int get_fb_phys_info(unsigned long *start, unsigned long *len, int fb_num,
 	int subsys_id)
 {
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_fb.h msm/msm_fb.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_fb.h	2012-08-13 16:39:47.819233555 -0700
+++ msm/msm_fb.h	2012-08-14 12:32:48.903338840 -0700
@@ -133,6 +133,8 @@
 			      struct fb_cmap *cmap);
 	int (*do_histogram) (struct fb_info *info,
 			      struct mdp_histogram_data *hist);
+	int (*start_histogram) (struct mdp_histogram_start_req *req);
+	int (*stop_histogram) (struct fb_info *info, uint32_t block);
 	void (*vsync_ctrl) (int enable);
 	void *cursor_buf;
 	void *cursor_buf_phys;
@@ -182,9 +184,9 @@
 	u32 ov_start;
 	u32 mem_hid;
 	u32 mdp_rev;
+	u32 use_ov0_blt, ov0_blt_state;
+	u32 use_ov1_blt, ov1_blt_state;
 	u32 writeback_state;
-	boolean resume_state;
-	boolean backlight_ctrl_ongoing;
 	bool writeback_active_cnt;
 	int cont_splash_done;
 };
@@ -210,16 +212,15 @@
 #ifdef CONFIG_FB_BACKLIGHT
 void msm_fb_config_backlight(struct msm_fb_data_type *mfd);
 #endif
-extern int poweroff_charging;
+
 void fill_black_screen(void);
 void unfill_black_screen(void);
-extern boolean mdp4_overlay_used(void);
+int msm_fb_check_frame_rate(struct msm_fb_data_type *mfd,
+				struct fb_info *info);
+
 #ifdef CONFIG_FB_MSM_LOGO
 #define INIT_IMAGE_FILE "/initlogo.rle"
 int load_565rle_image(char *filename, bool bf_supported);
-extern int draw_rgb888_screen(void);
 #endif
-int msm_fb_check_frame_rate(struct msm_fb_data_type *mfd,
-				struct fb_info *info);
 
 #endif /* MSM_FB_H */
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_fb_panel.c msm/msm_fb_panel.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_fb_panel.c	2012-07-16 10:04:32.216489770 -0700
+++ msm/msm_fb_panel.c	2012-08-14 12:32:39.585339475 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2010, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2008-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -106,6 +106,10 @@
 		snprintf(dev_name, sizeof(dev_name), "lcdc");
 		break;
 
+	case LVDS_PANEL:
+		snprintf(dev_name, sizeof(dev_name), "lvds");
+		break;
+
 	case DTV_PANEL:
 		snprintf(dev_name, sizeof(dev_name), "dtv");
 		break;
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_fb_panel.h msm/msm_fb_panel.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/msm_fb_panel.h	2012-08-08 09:32:42.856525952 -0700
+++ msm/msm_fb_panel.h	2012-08-14 12:32:39.585339475 -0700
@@ -82,6 +82,7 @@
 	uint32 xres_pad;
 	/* Pad height */
 	uint32 yres_pad;
+	boolean is_sync_active_high;
 };
 
 struct mddi_panel_info {
@@ -137,11 +138,20 @@
 	char force_clk_lane_hs;
 };
 
+enum lvds_mode {
+	LVDS_SINGLE_CHANNEL_MODE,
+	LVDS_DUAL_CHANNEL_MODE,
+};
+
+struct lvds_panel_info {
+	enum lvds_mode channel_mode;
+	/* Channel swap in dual mode */
+	char channel_swap;
+};
+
 struct msm_panel_info {
 	__u32 xres;
 	__u32 yres;
-	__u32 height;
-	__u32 width;
 	__u32 bpp;
 	__u32 mode2_xres;
 	__u32 mode2_yres;
@@ -164,6 +174,7 @@
 	struct lcd_panel_info lcd;
 	struct lcdc_panel_info lcdc;
 	struct mipi_panel_info mipi;
+	struct lvds_panel_info lvds;
 };
 
 #define MSM_FB_SINGLE_MODE_PANEL(pinfo)		\
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: s6e39a0_volt_tbl.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: s6e8aa0_volt_tbl.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: samsung_cmc624.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: samsung_cmc624.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: samsung_cmc624_tune.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: smart_dimming.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: smart_dimming.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: smart_mtp_2p2_gamma.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: smart_mtp_ea8960.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: smart_mtp_ea8960.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: smart_mtp_s6e39a0x02.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: smart_mtp_s6e39a0x02.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: smart_mtp_s6e63m0.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: smart_mtp_s6e63m0.h
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: smart_mtp_s6e8aa0x01.c
Only in /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm: smart_mtp_s6e8aa0x01.h
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.c msm/vidc/1080p/ddl/vcd_ddl.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.c	2012-08-08 09:32:42.856525952 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl.c	2012-08-14 12:32:39.585339475 -0700
@@ -471,12 +471,9 @@
 	struct ddl_encoder_data *encoder =
 		&ddl->codec_data.encoder;
 	u32 vcd_status = VCD_S_SUCCESS;
-
 	struct vcd_transc *transc;
 	transc = (struct vcd_transc *)(ddl->client_data);
-	DDL_MSG_LOW("%s: transc = 0x%x, in_use = %u",
-				 __func__, (u32)ddl->client_data, transc->in_use);
-
+	DDL_MSG_LOW("%s: transc = 0x%x", __func__, (u32)ddl->client_data);
 	if (encoder->slice_delivery_info.enable) {
 		return ddl_encode_frame_batch(ddl_handle,
 					input_frame,
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_core.h msm/vidc/1080p/ddl/vcd_ddl_core.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_core.h	2012-08-08 09:32:42.857525951 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_core.h	2012-08-14 12:32:39.586339476 -0700
@@ -30,6 +30,9 @@
 #define DDL_MAX_FRAME_WIDTH   1920
 #define DDL_MAX_FRAME_HEIGHT  1088
 
+#define DDL_MAX_VC1_FRAME_WIDTH		(DDL_MAX_FRAME_WIDTH)
+#define DDL_MAX_VC1_FRAME_HEIGHT	(1280)
+
 #define MAX_DPB_SIZE_L4PT0_MBS    DDL_KILO_BYTE(32)
 #define MAX_FRAME_SIZE_L4PT0_MBS  DDL_KILO_BYTE(8)
 
@@ -61,6 +64,7 @@
 #define DDL_VIDC_1080P_48MHZ_TIMEOUT_VALUE	(0xCB8)
 #define DDL_VIDC_1080P_133MHZ_TIMEOUT_VALUE	(0x2355)
 #define DDL_VIDC_1080P_200MHZ_TIMEOUT_VALUE	(0x3500)
+#define DDL_VIDC_1080P_MAX_TIMEOUT_MULTIPLIER  (4)
 
 #define DDL_CONTEXT_MEMORY (1024 * 15 * (VCD_MAX_NO_CLIENT + 1))
 
@@ -146,4 +150,8 @@
 #define DDL_RESL_CHANGE_INCREASED               1
 #define DDL_RESL_CHANGE_DECREASED               2
 
+#define VIDC_SM_ERR_CONCEALMENT_ENABLE				1
+#define VIDC_SM_ERR_CONCEALMENT_INTER_SLICE_MB_COPY		2
+#define VIDC_SM_ERR_CONCEALMENT_INTRA_SLICE_COLOR_CONCEALMENT	1
+
 #endif
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.h msm/vidc/1080p/ddl/vcd_ddl.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl.h	2012-08-08 09:32:42.856525952 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl.h	2012-08-14 12:32:39.585339475 -0700
@@ -84,6 +84,8 @@
 
 #define DDL_MAX_NUM_IN_INPUTFRAME_POOL          (DDL_MAX_NUM_OF_B_FRAME + 1)
 
+#define MDP_MIN_TILE_HEIGHT			96
+
 enum ddl_mem_area {
 	DDL_FW_MEM	= 0x0,
 	DDL_MM_MEM	= 0x1,
@@ -226,6 +228,7 @@
 			[DDL_MAX_NUM_BFRS_FOR_SLICE_BATCH];
 	u32 num_output_frames;
 	u32 out_frm_next_frmindex;
+	u32  first_output_frame_tag;
 };
 struct ddl_encoder_data{
 	struct ddl_codec_data_hdr   hdr;
@@ -307,6 +310,7 @@
 	u32  header_in_start;
 	u32  min_dpb_num;
 	u32  y_cb_cr_size;
+	u32  yuv_size;
 	u32  dynamic_prop_change;
 	u32  dynmic_prop_change_req;
 	u32  flush_pending;
@@ -317,6 +321,8 @@
 	u32  cont_mode;
 	u32  reconfig_detected;
 	u32  dmx_disable;
+	int avg_dec_time;
+	int dec_time_sum;
 };
 union ddl_codec_data{
 	struct ddl_codec_data_hdr  hdr;
@@ -481,4 +487,8 @@
 void ddl_get_fw_info(const unsigned char **fw_array_addr,
 	unsigned int *fw_size);
 void ddl_fw_release(struct ddl_buf_addr *);
+int ddl_vidc_decode_get_avg_time(struct ddl_client_context *ddl);
+void ddl_vidc_decode_reset_avg_time(struct ddl_client_context *ddl);
+void ddl_calc_core_proc_time(const char *func_name, u32 index,
+		struct ddl_client_context *ddl);
 #endif
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c msm/vidc/1080p/ddl/vcd_ddl_helper.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_helper.c	2012-08-08 09:32:42.857525951 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_helper.c	2012-08-14 12:32:39.586339476 -0700
@@ -16,7 +16,6 @@
 #include "vcd_ddl_shared_mem.h"
 #include "vcd_res_tracker_api.h"
 
-
 struct ddl_context *ddl_get_context(void)
 {
 	static struct ddl_context ddl_context;
@@ -169,6 +168,28 @@
 			} else if (operation == DDL_DPB_OP_MARK_FREE) {
 				dpb_mask->client_mask |= (0x1 << loopc);
 				*found_frame = *in_out_frame;
+				if ((decoder->meta_data_enable_flag) &&
+				    (in_out_frame->vcd_frm.buff_ion_handle)) {
+					struct ddl_context *ddl_context =
+						ddl_get_context();
+					unsigned long *vaddr =
+						(unsigned long *)((u32)
+						in_out_frame->vcd_frm.virtual +
+						decoder->meta_data_offset);
+					DDL_MSG_LOW("%s: Cache clean: vaddr"\
+						" (%p), offset %u, size %u",
+						__func__,
+						in_out_frame->vcd_frm.virtual,
+						decoder->meta_data_offset,
+						decoder->suffix);
+					msm_ion_do_cache_op(
+						ddl_context->video_ion_client,
+						in_out_frame->vcd_frm.\
+						buff_ion_handle,
+						vaddr,
+						(unsigned long)decoder->suffix,
+						ION_IOC_CLEAN_CACHES);
+				}
 			}
 		} else {
 			in_out_frame->vcd_frm.physical = NULL;
@@ -249,7 +270,7 @@
 	if (dpb > DDL_MAX_BUFFER_COUNT)
 		dpb = DDL_MAX_BUFFER_COUNT;
 	for (i = 0; i < dpb; i++) {
-		if (!res_trk_check_for_sec_session() &&
+		if (!(res_trk_check_for_sec_session()) &&
 			frame[i].vcd_frm.virtual) {
 			if (luma_size <= frame[i].vcd_frm.alloc_len) {
 				memset(frame[i].vcd_frm.virtual,
@@ -382,6 +403,8 @@
 		encoder->dynamic_prop_change = 0;
 		ddl_free_enc_hw_buffers(ddl);
 	}
+	ddl_pmem_free(&ddl->shared_mem[0]);
+	ddl_pmem_free(&ddl->shared_mem[1]);
 }
 
 u32 ddl_codec_type_transact(struct ddl_client_context *ddl,
@@ -654,7 +677,8 @@
 		ptr = ddl_pmem_alloc(&dec_bufs->context, buf_size.sz_context,
 			DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
+		else
 		msm_ion_do_cache_op(ddl_context->video_ion_client,
 					dec_bufs->context.alloc_handle,
 					dec_bufs->context.virtual_base_addr,
@@ -666,77 +690,77 @@
 		ptr = ddl_pmem_alloc(&dec_bufs->h264_nb_ip, buf_size.sz_nb_ip,
 			DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
 	}
 	if (buf_size.sz_vert_nb_mv > 0) {
 		dec_bufs->h264_vert_nb_mv.mem_type = DDL_MM_MEM;
 		ptr = ddl_pmem_alloc(&dec_bufs->h264_vert_nb_mv,
 			buf_size.sz_vert_nb_mv, DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
 	}
 	if (buf_size.sz_nb_dcac > 0) {
 		dec_bufs->nb_dcac.mem_type = DDL_MM_MEM;
 		ptr = ddl_pmem_alloc(&dec_bufs->nb_dcac, buf_size.sz_nb_dcac,
 			DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
 	}
 	if (buf_size.sz_upnb_mv > 0) {
 		dec_bufs->upnb_mv.mem_type = DDL_MM_MEM;
 		ptr = ddl_pmem_alloc(&dec_bufs->upnb_mv, buf_size.sz_upnb_mv,
 			DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
 	}
 	if (buf_size.sz_sub_anchor_mv > 0) {
 		dec_bufs->sub_anchor_mv.mem_type = DDL_MM_MEM;
 		ptr = ddl_pmem_alloc(&dec_bufs->sub_anchor_mv,
 			buf_size.sz_sub_anchor_mv, DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
 	}
 	if (buf_size.sz_overlap_xform > 0) {
 		dec_bufs->overlay_xform.mem_type = DDL_MM_MEM;
 		ptr = ddl_pmem_alloc(&dec_bufs->overlay_xform,
 			buf_size.sz_overlap_xform, DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
 	}
 	if (buf_size.sz_bit_plane3 > 0) {
 		dec_bufs->bit_plane3.mem_type = DDL_MM_MEM;
 		ptr = ddl_pmem_alloc(&dec_bufs->bit_plane3,
 			buf_size.sz_bit_plane3, DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
 	}
 	if (buf_size.sz_bit_plane2 > 0) {
 		dec_bufs->bit_plane2.mem_type = DDL_MM_MEM;
 		ptr = ddl_pmem_alloc(&dec_bufs->bit_plane2,
 			buf_size.sz_bit_plane2, DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
 	}
 	if (buf_size.sz_bit_plane1 > 0) {
 		dec_bufs->bit_plane1.mem_type = DDL_MM_MEM;
 		ptr = ddl_pmem_alloc(&dec_bufs->bit_plane1,
 			buf_size.sz_bit_plane1, DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
 	}
 	if (buf_size.sz_stx_parser > 0) {
 		dec_bufs->stx_parser.mem_type = DDL_MM_MEM;
 		ptr = ddl_pmem_alloc(&dec_bufs->stx_parser,
 			buf_size.sz_stx_parser, DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
 	}
 	if (buf_size.sz_desc > 0) {
 		dec_bufs->desc.mem_type = DDL_MM_MEM;
 		ptr = ddl_pmem_alloc(&dec_bufs->desc, buf_size.sz_desc,
 			DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+			goto fail_free_exit;
 		else {
 			if (!res_trk_check_for_sec_session()) {
 				memset(dec_bufs->desc.align_virtual_addr,
@@ -750,7 +774,9 @@
 			}
 		}
 	}
-	if (status)
+	return status;
+fail_free_exit:
+	status = VCD_ERR_ALLOC_FAIL;
 		ddl_free_dec_hw_buffers(ddl);
 	return status;
 }
@@ -787,7 +813,7 @@
 		sz_strm = DDL_ALIGN(ddl_get_yuv_buf_size(width, height,
 			DDL_YUV_BUF_TYPE_LINEAR) + ddl_get_yuv_buf_size(width,
 			height/2, DDL_YUV_BUF_TYPE_LINEAR), DDL_KILO_BYTE(4));
-		sz_mv = DDL_ALIGN(2 * mb_x * mb_y * 8, DDL_KILO_BYTE(2));
+		sz_mv = DDL_ALIGN(2 * mb_x * 8, DDL_KILO_BYTE(2));
 		if ((codec == VCD_CODEC_MPEG4) ||
 			(codec == VCD_CODEC_H264)) {
 			sz_col_zero = DDL_ALIGN(((mb_x * mb_y + 7) / 8) *
@@ -879,66 +905,70 @@
 			ptr = ddl_pmem_alloc(&enc_bufs->mv, buf_size.sz_mv,
 				DDL_KILO_BYTE(2));
 			if (!ptr)
-				status = VCD_ERR_ALLOC_FAIL;
+				goto fail_enc_free_exit;
 		}
 		if (buf_size.sz_col_zero > 0) {
 			enc_bufs->col_zero.mem_type = DDL_MM_MEM;
 			ptr = ddl_pmem_alloc(&enc_bufs->col_zero,
 				buf_size.sz_col_zero, DDL_KILO_BYTE(2));
 		if (!ptr)
-			status = VCD_ERR_ALLOC_FAIL;
+				goto fail_enc_free_exit;
 		}
 		if (buf_size.sz_md > 0) {
 			enc_bufs->md.mem_type = DDL_MM_MEM;
 			ptr = ddl_pmem_alloc(&enc_bufs->md, buf_size.sz_md,
 				DDL_KILO_BYTE(2));
 			if (!ptr)
-				status = VCD_ERR_ALLOC_FAIL;
+				goto fail_enc_free_exit;
 		}
 		if (buf_size.sz_pred > 0) {
-			enc_bufs->pred.mem_type = DDL_MM_MEM;
+			enc_bufs->pred.mem_type = DDL_FW_MEM;
 			ptr = ddl_pmem_alloc(&enc_bufs->pred,
 				buf_size.sz_pred, DDL_KILO_BYTE(2));
 			if (!ptr)
-				status = VCD_ERR_ALLOC_FAIL;
+				goto fail_enc_free_exit;
 		}
 		if (buf_size.sz_nbor_info > 0) {
 			enc_bufs->nbor_info.mem_type = DDL_MM_MEM;
 			ptr = ddl_pmem_alloc(&enc_bufs->nbor_info,
 				buf_size.sz_nbor_info, DDL_KILO_BYTE(2));
 			if (!ptr)
-				status = VCD_ERR_ALLOC_FAIL;
+				goto fail_enc_free_exit;
 		}
 		if (buf_size.sz_acdc_coef > 0) {
 			enc_bufs->acdc_coef.mem_type = DDL_MM_MEM;
 			ptr = ddl_pmem_alloc(&enc_bufs->acdc_coef,
 				buf_size.sz_acdc_coef, DDL_KILO_BYTE(2));
 			if (!ptr)
-				status = VCD_ERR_ALLOC_FAIL;
+				goto fail_enc_free_exit;
 		}
 		if (buf_size.sz_mb_info > 0) {
 			enc_bufs->mb_info.mem_type = DDL_MM_MEM;
 			ptr = ddl_pmem_alloc(&enc_bufs->mb_info,
 				buf_size.sz_mb_info, DDL_KILO_BYTE(2));
 			if (!ptr)
-				status = VCD_ERR_ALLOC_FAIL;
+				goto fail_enc_free_exit;
 		}
 		if (buf_size.sz_context > 0) {
 			enc_bufs->context.mem_type = DDL_MM_MEM;
 			ptr = ddl_pmem_alloc(&enc_bufs->context,
 				buf_size.sz_context, DDL_KILO_BYTE(2));
 			if (!ptr)
-				status = VCD_ERR_ALLOC_FAIL;
-			msm_ion_do_cache_op(ddl_context->video_ion_client,
+				goto fail_enc_free_exit;
+			else
+				msm_ion_do_cache_op(
+					ddl_context->video_ion_client,
 					enc_bufs->context.alloc_handle,
 					enc_bufs->context.virtual_base_addr,
 					enc_bufs->context.buffer_size,
 					ION_IOC_CLEAN_INV_CACHES);
 		}
-		if (status)
-			ddl_free_enc_hw_buffers(ddl);
 	}
 	return status;
+fail_enc_free_exit:
+	status = VCD_ERR_ALLOC_FAIL;
+	ddl_free_enc_hw_buffers(ddl);
+	return status;
 }
 
 void ddl_decoder_chroma_dpb_change(struct ddl_client_context *ddl)
@@ -1003,7 +1033,8 @@
 			(decoder->frame_size.scan_lines ==
 			decoder->client_frame_size.scan_lines) &&
 			(decoder->frame_size.stride ==
-			decoder->client_frame_size.stride))
+			decoder->client_frame_size.stride) &&
+			decoder->progressive_only)
 				need_reconfig = false;
 	}
 	return need_reconfig;
@@ -1056,8 +1087,39 @@
 void ddl_set_vidc_timeout(struct ddl_client_context *ddl)
 {
 	u32 vidc_time_out = 0;
+	s32 multiplier = 1;
+	u32 temp = DDL_VIDC_1080P_200MHZ_TIMEOUT_VALUE;
+	struct ddl_decoder_data *decoder = &ddl->codec_data.decoder;
+	struct vcd_frame_data *ip_bitstream = &(ddl->input_frame.vcd_frm);
+
 	if (ddl->codec_data.decoder.idr_only_decoding)
 		vidc_time_out = 2 * DDL_VIDC_1080P_200MHZ_TIMEOUT_VALUE;
+	else {
+		vidc_time_out = DDL_VIDC_1080P_200MHZ_TIMEOUT_VALUE;
+		multiplier = decoder->yuv_size - (ip_bitstream->data_len +
+						(ip_bitstream->data_len / 2));
+		if (multiplier <= 0) {
+			multiplier = decoder->yuv_size - ip_bitstream->data_len;
+			if (multiplier <= 0) {
+				if (ip_bitstream->data_len)
+					multiplier =
+					DDL_VIDC_1080P_MAX_TIMEOUT_MULTIPLIER;
+			}
+		}
+		if (multiplier == DDL_VIDC_1080P_MAX_TIMEOUT_MULTIPLIER)
+			vidc_time_out = vidc_time_out *
+				DDL_VIDC_1080P_MAX_TIMEOUT_MULTIPLIER;
+		else if (multiplier > 1) {
+			temp = (decoder->yuv_size * 1000) / multiplier;
+			temp = (temp * vidc_time_out) / 1000;
+			if (temp > (u32)(vidc_time_out *
+				DDL_VIDC_1080P_MAX_TIMEOUT_MULTIPLIER))
+				vidc_time_out = vidc_time_out *
+					DDL_VIDC_1080P_MAX_TIMEOUT_MULTIPLIER;
+			else
+				vidc_time_out = temp;
+		}
+	}
 	DDL_MSG_HIGH("%s Video core time out value = 0x%x",
 		 __func__, vidc_time_out);
 	vidc_sm_set_video_core_timeout_value(
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c	2012-08-08 09:32:42.857525951 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_interrupt_handler.c	2012-08-14 12:32:39.586339476 -0700
@@ -119,9 +119,8 @@
 			ddl->client_state = DDL_CLIENT_WAIT_FOR_INITCODEC;
 			ddl->instance_id = instance_id;
 			if (ddl->decoding) {
-				if (vidc_msg_timing)
 					ddl_calc_core_proc_time(__func__,
-						DEC_OP_TIME);
+						DEC_OP_TIME, ddl);
 				if (ddl->codec_data.decoder.header_in_start)
 					ddl_vidc_decode_init_codec(ddl);
 				else {
@@ -153,8 +152,7 @@
 		ddl_client_fatal_cb(ddl);
 		return true;
 	}
-	if (vidc_msg_timing)
-		ddl_calc_core_proc_time(__func__, ENC_OP_TIME);
+	ddl_calc_core_proc_time(__func__, ENC_OP_TIME, ddl);
 	ddl->cmd_state = DDL_CMD_INVALID;
 	DDL_MSG_LOW("ddl_state_transition: %s ~~> DDL_CLIENT_WAIT_FOR_FRAME",
 	ddl_get_state_string(ddl->client_state));
@@ -191,6 +189,9 @@
 			&decoder->frame_size.height);
 		progressive = seq_hdr_info->dec_progressive;
 	}
+	decoder->yuv_size = decoder->frame_size.width *
+				decoder->frame_size.height;
+	decoder->yuv_size += decoder->yuv_size / 2;
 	decoder->min_dpb_num = seq_hdr_info->min_num_dpb;
 	vidc_sm_get_min_yc_dpb_sizes(
 		&ddl->shared_mem[ddl->command_channel],
@@ -251,8 +252,7 @@
 		DDL_MSG_ERROR("STATE-CRITICAL-HDDONE");
 		ddl_client_fatal_cb(ddl);
 	} else {
-		if (vidc_msg_timing)
-			ddl_calc_core_proc_time(__func__, DEC_OP_TIME);
+		ddl_calc_core_proc_time(__func__, DEC_OP_TIME, ddl);
 		ddl->cmd_state = DDL_CMD_INVALID;
 		DDL_MSG_LOW("ddl_state_transition: %s ~~>"
 			"DDL_CLIENT_WAIT_FOR_DPB",
@@ -315,6 +315,20 @@
 					return process_further;
 				}
 			break;
+		case VCD_CODEC_VC1:
+		case VCD_CODEC_VC1_RCV:
+			if ((seq_hdr_info.img_size_x >
+					DDL_MAX_VC1_FRAME_WIDTH) ||
+				(seq_hdr_info.img_size_y >
+					DDL_MAX_VC1_FRAME_HEIGHT)) {
+				DDL_MSG_ERROR("Unsupported VC1 clip: "
+					"Resolution X=%d and Y=%d",
+					seq_hdr_info.img_size_x,
+					seq_hdr_info.img_size_y);
+					ddl_client_fatal_cb(ddl);
+					return process_further;
+			}
+			break;
 		default:
 			break;
 		}
@@ -472,10 +486,8 @@
 			DDL_MSG_LOW("ddl_state_transition: %s ~~>"
 				"DDL_CLIENT_WAIT_FOR_FRAME",
 				ddl_get_state_string(ddl->client_state));
-			if (vidc_msg_timing) {
-				ddl_calc_core_proc_time(__func__, DEC_OP_TIME);
+			ddl_calc_core_proc_time(__func__, DEC_OP_TIME, ddl);
 				ddl_reset_core_time_variables(DEC_OP_TIME);
-			}
 			ddl->client_state = DDL_CLIENT_WAIT_FOR_FRAME;
 			ddl_vidc_decode_frame_run(ddl);
 			ret_status = false;
@@ -500,8 +512,7 @@
 		DDL_MSG_ERROR("STATE-CRITICAL-ENCFRMRUN");
 		ddl_client_fatal_cb(ddl);
 	} else {
-		if (vidc_msg_timing)
-			ddl_calc_core_proc_time(__func__, ENC_OP_TIME);
+		ddl_calc_core_proc_time(__func__, ENC_OP_TIME, ddl);
 		DDL_MSG_LOW("ENC_FRM_RUN_DONE");
 		ddl->cmd_state = DDL_CMD_INVALID;
 		vidc_1080p_get_encode_frame_info(&encoder->enc_frame_info);
@@ -1085,8 +1096,7 @@
 	input_vcd_frm->offset += dec_disp_info->input_bytes_consumed;
 	input_vcd_frm->data_len -= dec_disp_info->input_bytes_consumed;
 	ddl->input_frame.frm_trans_end = frame_transact_end;
-	if (vidc_msg_timing)
-		ddl_calc_core_proc_time(__func__, DEC_IP_TIME);
+	ddl_calc_core_proc_time(__func__, DEC_IP_TIME, ddl);
 	ddl_context->ddl_callback(VCD_EVT_RESP_INPUT_DONE, VCD_S_SUCCESS,
 		&ddl->input_frame, sizeof(struct ddl_frame_data_tag),
 		(u32 *)ddl, ddl->client_data);
@@ -1259,6 +1269,9 @@
 			decoder->frame_size =
 				 output_vcd_frm->dec_op_prop.frm_size;
 			decoder->client_frame_size = decoder->frame_size;
+			decoder->yuv_size = decoder->frame_size.width *
+						decoder->frame_size.height;
+			decoder->yuv_size += decoder->yuv_size / 2;
 			decoder->y_cb_cr_size =
 				ddl_get_yuv_buffer_size(&decoder->frame_size,
 					&decoder->buf_format,
@@ -1290,8 +1303,7 @@
 		}
 		output_vcd_frm->flags |= VCD_FRAME_FLAG_ENDOFFRAME;
 		output_frame->frm_trans_end = frame_transact_end;
-		if (vidc_msg_timing)
-			ddl_calc_core_proc_time(__func__, DEC_OP_TIME);
+		ddl_calc_core_proc_time(__func__, DEC_OP_TIME, ddl);
 		ddl_process_decoder_metadata(ddl);
 		vidc_sm_get_aspect_ratio_info(
 			&ddl->shared_mem[ddl->command_channel],
@@ -1711,6 +1723,13 @@
 	(void)ddl_get_encoded_frame(output_frame,
 		encoder->codec.codec, encoder->enc_frame_info.enc_frame
 								);
+	if (!IS_ERR_OR_NULL(output_frame->buff_ion_handle)) {
+		msm_ion_do_cache_op(ddl_context->video_ion_client,
+			output_frame->buff_ion_handle,
+			(unsigned long *) output_frame->virtual,
+			(unsigned long) output_frame->alloc_len,
+			ION_IOC_INV_CACHES);
+	}
 	ddl_process_encoder_metadata(ddl);
 	ddl_vidc_encode_dynamic_property(ddl, false);
 	ddl->input_frame.frm_trans_end = false;
@@ -1782,6 +1801,27 @@
 		vidc_sm_get_frame_tags(&ddl->shared_mem
 			[ddl->command_channel],
 			&output_frame->ip_frm_tag, &bottom_frame_tag);
+
+		if (start_bfr_idx == 0) {
+			encoder->batch_frame.first_output_frame_tag =
+				output_frame->ip_frm_tag;
+			DDL_MSG_LOW("%s: first_output_frame_tag[0x%x]",
+				__func__, output_frame->ip_frm_tag);
+			if (!output_frame->ip_frm_tag) {
+				DDL_MSG_ERROR("%s: first_output_frame_tag "\
+					"is zero", __func__);
+			}
+		}
+		if (output_frame->ip_frm_tag !=
+			encoder->batch_frame.first_output_frame_tag) {
+			DDL_MSG_ERROR("%s: output_frame->ip_frm_tag[0x%x] is "\
+				"not equal to the first_output_frame_tag[0x%x]\n",
+				__func__, output_frame->ip_frm_tag,
+				encoder->batch_frame.first_output_frame_tag);
+			output_frame->ip_frm_tag =
+				encoder->batch_frame.first_output_frame_tag;
+		}
+
 		ddl_get_encoded_frame(output_frame,
 				encoder->codec.codec,
 				encoder->enc_frame_info.enc_frame);
@@ -1864,6 +1904,27 @@
 		vidc_sm_get_frame_tags(&ddl->shared_mem
 			[ddl->command_channel],
 			&output_frame->ip_frm_tag, &bottom_frame_tag);
+
+		if (start_bfr_idx == 0) {
+			encoder->batch_frame.first_output_frame_tag =
+				output_frame->ip_frm_tag;
+			DDL_MSG_LOW("%s: first_output_frame_tag[0x%x]",
+				__func__, output_frame->ip_frm_tag);
+			if (!output_frame->ip_frm_tag) {
+				DDL_MSG_ERROR("%s: first_output_frame_tag "\
+					"is zero", __func__);
+			}
+		}
+		if (output_frame->ip_frm_tag !=
+			encoder->batch_frame.first_output_frame_tag) {
+			DDL_MSG_ERROR("%s: output_frame->ip_frm_tag[0x%x] is "\
+				"not equal to the first_output_frame_tag[0x%x]\n",
+				__func__, output_frame->ip_frm_tag,
+				encoder->batch_frame.first_output_frame_tag);
+			output_frame->ip_frm_tag =
+				encoder->batch_frame.first_output_frame_tag;
+		}
+
 		ddl_get_encoded_frame(output_frame,
 				encoder->codec.codec,
 				encoder->enc_frame_info.enc_frame);
@@ -1933,6 +1994,10 @@
 				&ddl->shared_mem[ddl->command_channel],
 				&output_frame->ip_frm_tag,
 				&bottom_frame_tag);
+		if (!output_frame->ip_frm_tag) {
+			DDL_MSG_ERROR("%s: output frame tag is zero",
+				__func__);
+		}
 		ddl_get_encoded_frame(
 				output_frame,
 				encoder->codec.codec,
Only in msm/vidc/1080p/ddl: .vcd_ddl_interrupt_handler.c.swp
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c msm/vidc/1080p/ddl/vcd_ddl_properties.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_properties.c	2012-08-08 09:32:42.858525951 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_properties.c	2012-08-14 12:32:39.587339477 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -294,6 +294,11 @@
 		}
 	}
 	break;
+	case VCD_I_SET_TURBO_CLK:
+	{
+		vcd_status = VCD_S_SUCCESS;
+	}
+	break;
 	case VCD_I_BUFFER_FORMAT:
 	{
 		struct vcd_property_buffer_format *tile =
@@ -499,9 +504,8 @@
 				"Fails_as_not_in_open_state");
 		return VCD_ERR_ILLEGAL_OP;
 	}
-	} else {
+	} else
 		return vcd_status;
-	}
 
 	switch (property_hdr->prop_id) {
 	case VCD_I_FRAME_SIZE:
@@ -1595,6 +1599,7 @@
 			vcd_status = VCD_S_SUCCESS;
 		}
 	}
+	break;
 	case VCD_I_INTRA_REFRESH:
 	{
 		struct vcd_property_intra_refresh_mb_number
@@ -1860,7 +1865,7 @@
 		if (!decoder->cont_mode)
 			min_dpb = ddl_decoder_min_num_dpb(decoder);
 		else
-			min_dpb = 5;
+			min_dpb = res_trk_get_min_dpb_count();
 		frame_size = &decoder->client_frame_size;
 		output_buf_req = &decoder->client_output_buf_req;
 		input_buf_req = &decoder->client_input_buf_req;
@@ -1874,6 +1879,19 @@
 		input_buf_req = &decoder->actual_input_buf_req;
 		min_dpb = decoder->min_dpb_num;
 		y_cb_cr_size = decoder->y_cb_cr_size;
+		if ((decoder->buf_format.buffer_format ==
+			VCD_BUFFER_FORMAT_TILE_4x2) &&
+			(frame_size->height < MDP_MIN_TILE_HEIGHT)) {
+			frame_size->height = MDP_MIN_TILE_HEIGHT;
+			ddl_calculate_stride(frame_size,
+				!decoder->progressive_only);
+			y_cb_cr_size = ddl_get_yuv_buffer_size(
+				frame_size,
+				&decoder->buf_format,
+				(!decoder->progressive_only),
+				decoder->hdr.decoding, NULL);
+		} else
+			y_cb_cr_size = decoder->y_cb_cr_size;
 	}
 	memset(output_buf_req, 0,
 		sizeof(struct vcd_buffer_requirement));
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c	2012-08-08 09:32:42.858525951 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_shared_mem.c	2012-08-14 12:32:39.587339477 -0700
@@ -175,7 +175,6 @@
 #define VIDC_SM_ENC_NUM_OF_SLICE_COMP_VALUE_BMSK                  0xffffffff
 #define VIDC_SM_ENC_NUM_OF_SLICE_COMP_VALUE_SHFT                  0
 
-
 #define VIDC_SM_ALLOCATED_LUMA_DPB_SIZE_ADDR               0x0064
 #define VIDC_SM_ALLOCATED_CHROMA_DPB_SIZE_ADDR             0x0068
 #define VIDC_SM_ALLOCATED_MV_SIZE_ADDR                     0x006c
@@ -208,7 +207,7 @@
 #define VIDC_SM_MPEG4_ASPECT_RATIO_INFO_SHFT         0x0
 #define VIDC_SM_EXTENDED_PAR_ADDR                    0x00cc
 #define VIDC_SM_EXTENDED_PAR_WIDTH_BMSK              0xffff0000
-#define VIDC_SM_EXTENDED_PAR_WIDTH_SHFT              0xf
+#define VIDC_SM_EXTENDED_PAR_WIDTH_SHFT              16
 #define VIDC_SM_EXTENDED_PAR_HEIGHT_BMSK             0x0000ffff
 #define VIDC_SM_EXTENDED_PAR_HEIGHT_SHFT             0x0
 
@@ -802,13 +801,6 @@
 	consume_info);
 }
 
-void vidc_sm_set_video_core_timeout_value(struct ddl_buf_addr *shared_mem,
-        u32 timeout)
-{
-    DDL_MEM_WRITE_32(shared_mem, VIDC_SM_TIMEOUT_VALUE_ADDR,
-        timeout);
-}
-
 void vidc_sm_get_aspect_ratio_info(struct ddl_buf_addr *shared_mem,
 	struct vcd_aspect_ratio *aspect_ratio_info)
 {
@@ -874,3 +866,11 @@
     *output_buffer_size = DDL_MEM_READ_32(shared_mem,
             VIDC_SM_BATCH_OUTPUT_SIZE_ADDR);
 }
+
+void vidc_sm_set_video_core_timeout_value(struct ddl_buf_addr *shared_mem,
+	u32 timeout)
+{
+	DDL_MEM_WRITE_32(shared_mem, VIDC_SM_TIMEOUT_VALUE_ADDR,
+			timeout);
+}
+
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h	2012-08-08 09:32:42.858525951 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_shared_mem.h	2012-08-14 12:32:39.587339477 -0700
@@ -179,8 +179,6 @@
 void vidc_sm_set_decoder_stuff_bytes_consumption(
 	struct ddl_buf_addr *shared_mem,
 	enum vidc_sm_num_stuff_bytes_consume_info consume_info);
-void vidc_sm_set_video_core_timeout_value(struct ddl_buf_addr *shared_mem,
-    u32 timeout);
 void vidc_sm_get_aspect_ratio_info(struct ddl_buf_addr *shared_mem,
 	struct vcd_aspect_ratio *aspect_ratio_info);
 void vidc_sm_set_encoder_slice_batch_int_ctrl(struct ddl_buf_addr *shared_mem,
@@ -193,5 +191,6 @@
         u32 output_buffer_size);
 void vidc_sm_get_encoder_batch_output_size(struct ddl_buf_addr *shared_mem,
         u32 *output_buffer_size);
-
+void vidc_sm_set_video_core_timeout_value(struct ddl_buf_addr *shared_mem,
+	u32 timeout);
 #endif
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c msm/vidc/1080p/ddl/vcd_ddl_utils.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.c	2012-08-08 09:32:42.858525951 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_utils.c	2012-08-14 12:32:39.587339477 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -11,9 +11,9 @@
  *
  */
 #include <linux/memory_alloc.h>
+#include <linux/delay.h>
 #include <mach/msm_subsystem_map.h>
 #include <mach/peripheral-loader.h>
-#include <linux/delay.h>
 #include "vcd_ddl_utils.h"
 #include "vcd_ddl.h"
 #include "vcd_res_tracker_api.h"
@@ -371,6 +371,7 @@
 		if(res_trk_disable_iommu_clocks())
 			pr_err("Failed to disable iommu clocks\n");
 		if (IS_ERR_OR_NULL(dram_base->pil_cookie)) {
+			res_trk_disable_footswitch();
 			pr_err("pil_get failed\n");
 			return false;
 		}
@@ -425,15 +426,17 @@
 	if (!time_data->ddl_t1) {
 		time_data->ddl_t1 = act_time;
 		DDL_MSG_LOW("\n%s(): Start Time (%u)", func_name, act_time);
-	} else {
+	} else if (vidc_msg_timing) {
 		DDL_MSG_TIME("\n%s(): Timer already started! St(%u) Act(%u)",
 			func_name, time_data->ddl_t1, act_time);
 	}
 }
 
-void ddl_calc_core_proc_time(const char *func_name, u32 index)
+void ddl_calc_core_proc_time(const char *func_name, u32 index,
+			struct ddl_client_context *ddl)
 {
 	struct time_data *time_data = &proc_time[index];
+	struct ddl_decoder_data *decoder = NULL;
 	if (time_data->ddl_t1) {
 		int ddl_t2;
 		struct timeval ddl_tv;
@@ -441,10 +444,22 @@
 		ddl_t2 = (ddl_tv.tv_sec * 1000) + (ddl_tv.tv_usec / 1000);
 		time_data->ddl_ttotal += (ddl_t2 - time_data->ddl_t1);
 		time_data->ddl_count++;
-		DDL_MSG_TIME("\n%s(): cnt(%u) End Time (%u) Diff(%u) Avg(%u)",
+		if (vidc_msg_timing) {
+			DDL_MSG_TIME("\n%s(): cnt(%u) End Time (%u)"
+				"Diff(%u) Avg(%u)",
 			func_name, time_data->ddl_count, ddl_t2,
 			ddl_t2 - time_data->ddl_t1,
 			time_data->ddl_ttotal/time_data->ddl_count);
+		}
+		if ((index == DEC_OP_TIME) && (time_data->ddl_count > 2) &&
+					(time_data->ddl_count < 6)) {
+			decoder = &(ddl->codec_data.decoder);
+			decoder->dec_time_sum = decoder->dec_time_sum +
+				ddl_t2 - time_data->ddl_t1;
+			if (time_data->ddl_count == 5)
+				decoder->avg_dec_time =
+					decoder->dec_time_sum / 3;
+		}
 		time_data->ddl_t1 = 0;
 	}
 }
@@ -485,3 +500,19 @@
 	proc_time[index].ddl_ttotal = 0;
 	proc_time[index].ddl_count = 0;
 }
+
+int ddl_get_core_decode_proc_time(u32 *ddl_handle)
+{
+	int avg_time = 0;
+	struct ddl_client_context *ddl =
+		(struct ddl_client_context *) ddl_handle;
+	avg_time = ddl_vidc_decode_get_avg_time(ddl);
+	return avg_time;
+}
+
+void ddl_reset_avg_dec_time(u32 *ddl_handle)
+{
+	struct ddl_client_context *ddl =
+		(struct ddl_client_context *) ddl_handle;
+	ddl_vidc_decode_reset_avg_time(ddl);
+}
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.h msm/vidc/1080p/ddl/vcd_ddl_utils.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_utils.h	2012-08-08 09:32:42.858525951 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_utils.h	2012-08-14 12:32:39.588339477 -0700
@@ -70,8 +70,9 @@
 #define DDL_MEMSET(src, value, len) memset((src), (value), (len))
 
 void ddl_set_core_start_time(const char *func_name, u32 index);
-void ddl_calc_core_proc_time(const char *func_name, u32 index);
 void ddl_reset_core_time_variables(u32 index);
 void ddl_calc_core_proc_time_cnt(const char *func_name, u32 index, u32 count);
 void ddl_update_core_start_time(const char *func_name, u32 index);
+int ddl_get_core_decode_proc_time(u32 *ddl_handle);
+void ddl_reset_avg_dec_time(u32 *ddl_handle);
 #endif
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c msm/vidc/1080p/ddl/vcd_ddl_vidc.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/ddl/vcd_ddl_vidc.c	2012-08-08 09:32:42.858525951 -0700
+++ msm/vidc/1080p/ddl/vcd_ddl_vidc.c	2012-08-14 12:32:39.588339477 -0700
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
+/* Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -23,11 +23,6 @@
 #endif
 static unsigned int run_cnt;
 
-/* MMRND_AVRC. Start */
-#define QCIF_WIDTH   176
-#define QCIF_HEIGHT  144
-/* MMRND_AVRC. End */
-
 void ddl_vidc_core_init(struct ddl_context *ddl_context)
 {
 	struct vidc_1080P_pix_cache_config pixel_cache_config;
@@ -116,7 +111,6 @@
 	u32 pix_cache_ctrl, ctxt_mem_offset, ctxt_mem_size;
 
 	if (ddl->decoding) {
-		if (vidc_msg_timing)
 			ddl_set_core_start_time(__func__, DEC_OP_TIME);
 		vcd_codec = &(ddl->codec_data.decoder.codec.codec);
 		pix_cache_ctrl = (u32)dec_pix_cache;
@@ -202,11 +196,17 @@
 	struct vidc_1080p_dec_seq_start_param seq_start_param;
 	u32 seq_size;
 
-	if (vidc_msg_timing)
 		ddl_set_core_start_time(__func__, DEC_OP_TIME);
 	vidc_1080p_set_decode_mpeg4_pp_filter(decoder->post_filter.post_filter);
 	vidc_sm_set_concealment_color(&ddl->shared_mem[ddl->command_channel],
 		DDL_CONCEALMENT_Y_COLOR, DDL_CONCEALMENT_C_COLOR);
+
+	vidc_sm_set_error_concealment_config(
+		&ddl->shared_mem[ddl->command_channel],
+		VIDC_SM_ERR_CONCEALMENT_INTER_SLICE_MB_COPY,
+		VIDC_SM_ERR_CONCEALMENT_INTRA_SLICE_COLOR_CONCEALMENT,
+		VIDC_SM_ERR_CONCEALMENT_ENABLE);
+
 	ddl_vidc_metadata_enable(ddl);
 	vidc_sm_set_metadata_start_address(&ddl->shared_mem
 		[ddl->command_channel],
@@ -575,15 +575,6 @@
 		(DDL_FRAMERATE_SCALE(DDL_INITIAL_FRAME_RATE)
 		 != scaled_frame_rate))
 		h263_cpfc_enable = true;
-
-/* MMRND_AVRC. Start */
-	/* added for MMS plus header issue */
-	if ((encoder->codec.codec == VCD_CODEC_H263) &&
-			(encoder->frame_size.width == QCIF_WIDTH) &&
-			(encoder->frame_size.height == QCIF_HEIGHT))
-		h263_cpfc_enable = false;
-/* MMRND_AVRC. End */
-
 	vidc_sm_set_extended_encoder_control(&ddl->shared_mem
 		[ddl->command_channel], hdr_ext_control,
 		r_cframe_skip, false, 0,
@@ -876,6 +867,7 @@
 	DDL_MEMSET(encoder->batch_frame.slice_batch_in.align_virtual_addr, 0,
 		sizeof(struct vidc_1080p_enc_slice_batch_in_param));
 	encoder->batch_frame.out_frm_next_frmindex = 0;
+	encoder->batch_frame.first_output_frame_tag = 0;
 	bitstream_size = encoder->batch_frame.output_frame[0].vcd_frm.alloc_len;
 	encoder->output_buf_req.sz = bitstream_size;
 	y_addr = DDL_OFFSET(ddl_context->dram_base_b.align_physical_addr,
@@ -1001,7 +993,6 @@
 #ifdef DDL_BUF_LOG
 	ddl_list_buffers(ddl);
 #endif
-	if (vidc_msg_timing)
 		ddl_set_core_start_time(__func__, DEC_OP_TIME);
 	ddl_decoder_dpb_transact(decoder, NULL, DDL_DPB_OP_INIT);
 	if (ddl_decoder_dpb_init(ddl) == VCD_ERR_FAIL)
@@ -1049,10 +1040,8 @@
 	struct ddl_mask *dpb_mask = &ddl->codec_data.decoder.dpb_mask;
 	struct vidc_1080p_dec_frame_start_param dec_param;
 	u32 dpb_addr_y[32], index;
-	if (vidc_msg_timing) {
 		ddl_set_core_start_time(__func__, DEC_OP_TIME);
 		ddl_set_core_start_time(__func__, DEC_IP_TIME);
-	}
 	if ((!bit_stream->data_len) || (!bit_stream->physical)) {
 		ddl_vidc_decode_eos_run(ddl);
 		return;
@@ -1088,6 +1077,7 @@
 		decoder->flush_pending = false;
 	} else
 		dec_param.dpb_flush = false;
+	ddl_set_vidc_timeout(ddl);
 	vidc_sm_set_frame_tag(&ddl->shared_mem[ddl->command_channel],
 		bit_stream->ip_frm_tag);
 	if (ddl_context->pix_cache_enable) {
@@ -1176,3 +1166,18 @@
 	ddl_context->vidc_encode_frame_start[ddl->command_channel](
 						&enc_param);
 }
+
+int ddl_vidc_decode_get_avg_time(struct ddl_client_context *ddl)
+{
+	int avg_time = 0;
+	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
+	avg_time = decoder->avg_dec_time;
+	return avg_time;
+}
+
+void ddl_vidc_decode_reset_avg_time(struct ddl_client_context *ddl)
+{
+	struct ddl_decoder_data *decoder = &(ddl->codec_data.decoder);
+	decoder->avg_dec_time = 0;
+	decoder->dec_time_sum = 0;
+}
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker_api.h msm/vidc/1080p/resource_tracker/vcd_res_tracker_api.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker_api.h	2012-08-08 09:32:42.878525949 -0700
+++ msm/vidc/1080p/resource_tracker/vcd_res_tracker_api.h	2012-08-14 12:32:39.589339477 -0700
@@ -17,14 +17,6 @@
 #include "vcd_ddl.h"
 #include "vcd_ddl_utils.h"
 
-#define RESTRK_1080P_VGA_PERF_LEVEL    VCD_MIN_PERF_LEVEL
-#define RESTRK_1080P_720P_PERF_LEVEL   108000
-#define RESTRK_1080P_1080P_PERF_LEVEL  244800
-
-#define RESTRK_1080P_MIN_PERF_LEVEL RESTRK_1080P_VGA_PERF_LEVEL
-#define RESTRK_1080P_MAX_PERF_LEVEL RESTRK_1080P_1080P_PERF_LEVEL
-#define RESTRK_1080P_TURBO_PERF_LEVEL (RESTRK_1080P_MAX_PERF_LEVEL + 1)
-
 void res_trk_init(struct device *device, u32 irq);
 u32 res_trk_power_up(void);
 u32 res_trk_power_down(void);
@@ -43,6 +35,7 @@
 u32 res_trk_get_disable_fullhd(void);
 struct ion_client *res_trk_get_ion_client(void);
 u32 res_trk_get_disable_dmx(void);
+u32 res_trk_get_min_dpb_count(void);
 void res_trk_set_mem_type(enum ddl_mem_area mem_type);
 int res_trk_enable_iommu_clocks(void);
 int res_trk_disable_iommu_clocks(void);
@@ -55,5 +48,6 @@
 int res_trk_enable_footswitch(void);
 int res_trk_disable_footswitch(void);
 void res_trk_release_fw_addr(void);
+u32 res_trk_estimate_perf_level(u32 pn_perf_lvl);
 u32 res_trk_get_clk_rate(unsigned long *phclk_rate);
 #endif
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c msm/vidc/1080p/resource_tracker/vcd_res_tracker.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.c	2012-08-08 09:32:42.878525949 -0700
+++ msm/vidc/1080p/resource_tracker/vcd_res_tracker.c	2012-08-14 12:32:39.588339477 -0700
@@ -11,7 +11,7 @@
  *
  */
 #include <linux/firmware.h>
-#include <linux/pm_qos_params.h>
+#include <linux/pm_qos.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/regulator/consumer.h>
@@ -25,13 +25,11 @@
 #include "vidc.h"
 #include "vcd_res_tracker.h"
 
+#define PIL_FW_SIZE 0x200000
+
 static unsigned int vidc_clk_table[4] = {
 	48000000, 133330000, 200000000, 228570000,
 };
-
-#define PIL_FW_BASE_ADDR 0xafe00000
-#define PIL_FW_SIZE 0x200000
-
 static unsigned int restrk_mmu_subsystem[] =	{
 		MSM_SUBSYSTEM_VIDEO, MSM_SUBSYSTEM_VIDEO_FWARE};
 static struct res_trk_context resource_context;
@@ -106,18 +104,18 @@
 				pr_err(" %s() alloced addres NULL", __func__);
 				goto bail_out;
 			}
-			flags = MSM_SUBSYSTEM_MAP_IOVA|MSM_SUBSYSTEM_MAP_KADDR;
+			flags = MSM_SUBSYSTEM_MAP_IOVA |
+				MSM_SUBSYSTEM_MAP_KADDR;
 			if (alignment == DDL_KILO_BYTE(128))
 					index = 1;
 			else if (alignment > SZ_4K)
 				flags |= MSM_SUBSYSTEM_ALIGN_IOVA_8K;
-
 			addr->mapped_buffer =
 			msm_subsystem_map_buffer(
 			(unsigned long)addr->alloced_phys_addr,
 			sz, flags, &restrk_mmu_subsystem[index],
-			sizeof(restrk_mmu_subsystem[index])
-			/sizeof(unsigned int));
+			sizeof(restrk_mmu_subsystem[index])/
+				sizeof(unsigned int));
 			if (IS_ERR(addr->mapped_buffer)) {
 				pr_err(" %s() buffer map failed", __func__);
 				goto bail_out;
@@ -127,13 +125,15 @@
 				pr_err("%s() map buffers failed\n", __func__);
 				goto bail_out;
 			}
-			addr->physical_base_addr = (u8 *)mapped_buffer->iova[0];
-			addr->virtual_base_addr = mapped_buffer->vaddr;
+			addr->physical_base_addr =
+				 (u8 *)mapped_buffer->iova[0];
+			addr->virtual_base_addr =
+					mapped_buffer->vaddr;
 		} else {
-			addr->physical_base_addr = (u8 *)
-					 addr->alloced_phys_addr;
-			addr->virtual_base_addr = (u8 *)
-					addr->alloced_phys_addr;
+			addr->physical_base_addr =
+				(u8 *) addr->alloced_phys_addr;
+			addr->virtual_base_addr =
+				(u8 *)addr->alloced_phys_addr;
 		}
 		addr->align_physical_addr = (u8 *) DDL_ALIGN((u32)
 		addr->physical_base_addr, alignment);
@@ -144,7 +144,7 @@
 	}
 	return addr->virtual_base_addr;
 bail_out:
-	if (addr->mapped_buffer)
+	if (IS_ERR(addr->mapped_buffer))
 		msm_subsystem_unmap_buffer(addr->mapped_buffer);
 	return NULL;
 ion_unmap_bail_out:
@@ -158,21 +158,29 @@
 
 static void res_trk_pmem_free(struct ddl_buf_addr *addr)
 {
-	/* TODO Pmem*/
 	struct ddl_context *ddl_context;
 	ddl_context = ddl_get_context();
 	if (ddl_context->video_ion_client) {
 		if (addr && addr->alloc_handle) {
-			ion_free(ddl_context->video_ion_client, addr->alloc_handle);
+			ion_free(ddl_context->video_ion_client,
+			 addr->alloc_handle);
 			addr->alloc_handle = NULL;
 		}
+	} else {
+		if (addr->mapped_buffer)
+			msm_subsystem_unmap_buffer(addr->mapped_buffer);
+		if (addr->alloced_phys_addr)
+			free_contiguous_memory_by_paddr(
+			(unsigned long)addr->alloced_phys_addr);
 	}
+	memset(addr, 0 , sizeof(struct ddl_buf_addr));
 }
 static int res_trk_pmem_alloc
 	(struct ddl_buf_addr *addr, size_t sz, u32 alignment)
 {
 	u32 alloc_size;
 	struct ddl_context *ddl_context;
+	unsigned long fw_addr;
 	int rc = 0;
 	DBG_PMEM("\n%s() IN: Requested alloc size(%u)", __func__, (u32)sz);
 	if (!addr) {
@@ -184,19 +192,22 @@
 	res_trk_set_mem_type(addr->mem_type);
 	alloc_size = (sz + alignment);
 	if (res_trk_get_enable_ion()) {
-		if (!res_trk_is_cp_enabled() || !res_trk_check_for_sec_session()) {
+		if (!res_trk_is_cp_enabled() ||
+			 !res_trk_check_for_sec_session()) {
 			if (!ddl_context->video_ion_client)
 				ddl_context->video_ion_client =
 					res_trk_get_ion_client();
 			if (!ddl_context->video_ion_client) {
-				DDL_MSG_ERROR("%s() :DDL ION Client Invalid handle\n",
+				DDL_MSG_ERROR(
+				"%s() :DDL ION Client Invalid handle\n",
 							 __func__);
 				rc = -ENOMEM;
 				goto bail_out;
 			}
 			alloc_size = (alloc_size+4095) & ~4095;
 			addr->alloc_handle = ion_alloc(
-			ddl_context->video_ion_client, alloc_size, SZ_4K,
+					ddl_context->video_ion_client,
+					 alloc_size, SZ_4K,
 				res_trk_get_mem_type());
 			if (IS_ERR_OR_NULL(addr->alloc_handle)) {
 				DDL_MSG_ERROR("%s() :DDL ION alloc failed\n",
@@ -205,8 +216,9 @@
 				goto bail_out;
 			}
 		} else {
+			fw_addr = resource_context.vidc_platform_data->fw_addr;
 			addr->alloc_handle = NULL;
-			addr->alloced_phys_addr = PIL_FW_BASE_ADDR;
+			addr->alloced_phys_addr = fw_addr;
 			addr->buffer_size = sz;
 		}
 	} else {
@@ -331,11 +343,11 @@
 		VCDRES_MSG_LOW("%s(): Enabling the clocks\n", __func__);
 		if (resource_context.vcodec_clk &&
 			resource_context.vcodec_pclk) {
-			if (clk_enable(resource_context.vcodec_pclk)) {
+			if (clk_prepare_enable(resource_context.vcodec_pclk)) {
 				VCDRES_MSG_ERROR("vidc pclk Enable fail\n");
 				goto bail_out;
 			}
-			if (clk_enable(resource_context.vcodec_clk)) {
+			if (clk_prepare_enable(resource_context.vcodec_clk)) {
 				VCDRES_MSG_ERROR("vidc core clk Enable fail\n");
 				goto vidc_disable_pclk;
 			}
@@ -351,7 +363,7 @@
 	mutex_unlock(&resource_context.lock);
 	return true;
 vidc_disable_pclk:
-	clk_disable(resource_context.vcodec_pclk);
+	clk_disable_unprepare(resource_context.vcodec_pclk);
 bail_out:
 	mutex_unlock(&resource_context.lock);
 	return false;
@@ -367,7 +379,6 @@
 		status = false;
 	} else
 		resource_context.vcodec_clk_rate = hclk_rate;
-	pr_err("vidc hclk set rate to : %ld\n", hclk_rate);
 	mutex_unlock(&resource_context.lock);
 	return status;
 }
@@ -399,9 +410,9 @@
 		VCDRES_MSG_LOW("%s(): Disabling the clocks ...\n", __func__);
 		resource_context.clock_enabled = 0;
 		if (resource_context.vcodec_clk)
-			clk_disable(resource_context.vcodec_clk);
+			clk_disable_unprepare(resource_context.vcodec_clk);
 		if (resource_context.vcodec_pclk)
-			clk_disable(resource_context.vcodec_pclk);
+			clk_disable_unprepare(resource_context.vcodec_pclk);
 		status = true;
 	}
 	mutex_unlock(&resource_context.lock);
@@ -410,23 +421,20 @@
 
 static u32 res_trk_vidc_pwr_up(void)
 {
-	int rc = 0;
 	mutex_lock(&resource_context.lock);
 
 	if (pm_runtime_get(resource_context.device) < 0) {
 		VCDRES_MSG_ERROR("Error : pm_runtime_get failed\n");
 		goto bail_out;
 	}
-	resource_context.footswitch = regulator_get(NULL, "fs_ved");
+	if (!resource_context.footswitch)
+		resource_context.footswitch =
+			regulator_get(resource_context.device, "vdd");
 	if (IS_ERR(resource_context.footswitch)) {
 		VCDRES_MSG_ERROR("foot switch get failed\n");
 		resource_context.footswitch = NULL;
 	} else
-		rc = regulator_enable(resource_context.footswitch);
-	if (rc) {
-		VCDRES_MSG_ERROR("Error : regulator enable failed");
-		goto rel_vidc_pm_runtime;
-	}
+		regulator_enable(resource_context.footswitch);
 	if (!res_trk_get_clk())
 		goto rel_vidc_pm_runtime;
 	mutex_unlock(&resource_context.lock);
@@ -450,6 +458,7 @@
 {
 	int rc = 0;
 	mutex_lock(&resource_context.lock);
+	if (!resource_context.footswitch)
 	resource_context.footswitch = regulator_get(NULL, "fs_ved");
 	if (IS_ERR(resource_context.footswitch)) {
 		VCDRES_MSG_ERROR("foot switch get failed\n");
@@ -528,6 +537,9 @@
 	u32 bus_clk_index, client_type = 0;
 	int rc = 0;
 
+	if (dev_ctxt->turbo_mode_set)
+		return rc;
+
 	cctxt_itr = dev_ctxt->cctxt_list_head;
 	while (cctxt_itr) {
 		if (cctxt_itr->decoding)
@@ -536,6 +548,7 @@
 			enc_perf_level += cctxt_itr->reqd_perf_lvl;
 		cctxt_itr = cctxt_itr->next;
 	}
+
 	if (!enc_perf_level)
 		client_type = 1;
 	if (perf_level <= RESTRK_1080P_VGA_PERF_LEVEL)
@@ -549,6 +562,16 @@
 
 	if (dev_ctxt->reqd_perf_lvl + dev_ctxt->curr_perf_lvl == 0)
 		bus_clk_index = 2;
+	else if (resource_context.vidc_platform_data->disable_turbo
+						&& bus_clk_index == 3) {
+		VCDRES_MSG_ERROR("Warning: Turbo mode not supported "
+				" falling back to 1080p bus\n");
+		bus_clk_index = 2;
+	}
+
+	if (bus_clk_index == 3)
+		dev_ctxt->turbo_mode_set = 1;
+
 	bus_clk_index = (bus_clk_index << 1) + (client_type + 1);
 	VCDRES_MSG_LOW("%s(), bus_clk_index = %d", __func__, bus_clk_index);
 	VCDRES_MSG_LOW("%s(),context.pcl = %x", __func__, resource_context.pcl);
@@ -568,7 +591,20 @@
 			__func__, dev_ctxt);
 		return false;
 	}
+	if (dev_ctxt->turbo_mode_set &&
+			(req_perf_lvl < RESTRK_1080P_TURBO_PERF_LEVEL)) {
+		VCDRES_MSG_MED("%s(): TURBO MODE!!\n", __func__);
+		return true;
+	}
+
 	VCDRES_MSG_LOW("%s(), req_perf_lvl = %d", __func__, req_perf_lvl);
+
+	if (resource_context.vidc_platform_data->disable_turbo
+			&& req_perf_lvl > RESTRK_1080P_MAX_PERF_LEVEL) {
+		VCDRES_MSG_ERROR("%s(): Turbo not supported! dev_ctxt(%p)\n",
+			__func__, dev_ctxt);
+	}
+
 #ifdef CONFIG_MSM_BUS_SCALING
 	if (!res_trk_update_bus_perf_level(dev_ctxt, req_perf_lvl) < 0) {
 		VCDRES_MSG_ERROR("%s(): update buf perf level failed\n",
@@ -593,6 +629,15 @@
 		vidc_freq = vidc_clk_table[3];
 		*pn_set_perf_lvl = RESTRK_1080P_TURBO_PERF_LEVEL;		
 	}
+
+	if (resource_context.vidc_platform_data->disable_turbo &&
+		*pn_set_perf_lvl == RESTRK_1080P_TURBO_PERF_LEVEL) {
+		VCDRES_MSG_ERROR("Warning: Turbo mode not supported "
+				" falling back to 1080p clocks\n");
+		vidc_freq = vidc_clk_table[2];
+		*pn_set_perf_lvl = RESTRK_1080P_MAX_PERF_LEVEL;
+	}
+
 	resource_context.perf_level = *pn_set_perf_lvl;
 	VCDRES_MSG_MED("VIDC: vidc_freq = %u, req_perf_lvl = %u\n",
 		vidc_freq, req_perf_lvl);
@@ -609,7 +654,6 @@
 	}
 #endif
 	VCDRES_MSG_MED("%s() set perl level : %d", __func__, *pn_set_perf_lvl);
-	pr_err("NOTE: %s() set perl level : %d", __func__, *pn_set_perf_lvl);
 	return true;
 }
 
@@ -795,8 +839,7 @@
             mem_type |= ION_SECURE;
          else if (res_trk_is_cp_enabled())
             mem_type |= ION_SECURE;
-      }
-		else
+	} else
 			mem_type = (ION_HEAP(mem_type) |
 					ION_HEAP(ION_IOMMU_HEAP_ID));
 	}
@@ -828,6 +871,10 @@
 	return resource_context.disable_dmx;
 }
 
+u32 res_trk_get_min_dpb_count(void){
+	return resource_context.vidc_platform_data->cont_mode_dpb_count;
+}
+
 void res_trk_set_mem_type(enum ddl_mem_area mem_type)
 {
 	resource_context.res_mem_type = mem_type;
@@ -856,7 +903,7 @@
 			ret = PTR_ERR(vidc_mmu_clks[i].mmu_clk);
 		}
 		if (!ret) {
-			ret = clk_enable(vidc_mmu_clks[i].mmu_clk);
+			ret = clk_prepare_enable(vidc_mmu_clks[i].mmu_clk);
 			if (ret) {
 				clk_put(vidc_mmu_clks[i].mmu_clk);
 				vidc_mmu_clks[i].mmu_clk = NULL;
@@ -864,7 +911,7 @@
 		}
 		if (ret) {
 			for (i--; i >= 0; i--) {
-				clk_disable(vidc_mmu_clks[i].mmu_clk);
+				clk_disable_unprepare(vidc_mmu_clks[i].mmu_clk);
 				clk_put(vidc_mmu_clks[i].mmu_clk);
 				vidc_mmu_clks[i].mmu_clk = NULL;
 			}
@@ -885,7 +932,7 @@
 	}
 	resource_context.mmu_clks_on = 0;
 	for (i = 0; i < ARRAY_SIZE(vidc_mmu_clks); i++) {
-		clk_disable(vidc_mmu_clks[i].mmu_clk);
+		clk_disable_unprepare(vidc_mmu_clks[i].mmu_clk);
 		clk_put(vidc_mmu_clks[i].mmu_clk);
 		vidc_mmu_clks[i].mmu_clk = NULL;
 	}
@@ -920,6 +967,10 @@
 		}
 		msm_ion_secure_heap(ION_HEAP(resource_context.memtype));
 		msm_ion_secure_heap(ION_HEAP(resource_context.cmd_mem_type));
+
+		if (resource_context.vidc_platform_data->secure_wb_heap)
+			msm_ion_secure_heap(ION_HEAP(ION_CP_WB_HEAP_ID));
+
 		res_trk_disable_iommu_clocks();
 		mutex_unlock(&resource_context.secure_lock);
 	}
@@ -942,6 +993,10 @@
 		}
 		msm_ion_unsecure_heap(ION_HEAP(resource_context.cmd_mem_type));
 		msm_ion_unsecure_heap(ION_HEAP(resource_context.memtype));
+
+		if (resource_context.vidc_platform_data->secure_wb_heap)
+			msm_ion_unsecure_heap(ION_HEAP(ION_CP_WB_HEAP_ID));
+
 		res_trk_disable_iommu_clocks();
 		mutex_unlock(&resource_context.secure_lock);
 	}
@@ -973,3 +1028,17 @@
 	}
 	return res_trk_perf_level;
 }
+
+u32 res_trk_estimate_perf_level(u32 pn_perf_lvl)
+{
+	VCDRES_MSG_MED("%s(), req_perf_lvl = %d", __func__, pn_perf_lvl);
+	if ((pn_perf_lvl >= RESTRK_1080P_VGA_PERF_LEVEL) &&
+		(pn_perf_lvl < RESTRK_1080P_720P_PERF_LEVEL)) {
+		return RESTRK_1080P_720P_PERF_LEVEL;
+	} else if ((pn_perf_lvl >= RESTRK_1080P_720P_PERF_LEVEL) &&
+			(pn_perf_lvl < RESTRK_1080P_MAX_PERF_LEVEL)) {
+		return RESTRK_1080P_MAX_PERF_LEVEL;
+	} else {
+		return pn_perf_lvl;
+	}
+}
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.h msm/vidc/1080p/resource_tracker/vcd_res_tracker.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/1080p/resource_tracker/vcd_res_tracker.h	2012-07-27 15:40:18.424765243 -0700
+++ msm/vidc/1080p/resource_tracker/vcd_res_tracker.h	2012-08-14 12:32:39.588339477 -0700
@@ -22,6 +22,14 @@
 #endif
 #include <mach/board.h>
 
+#define RESTRK_1080P_VGA_PERF_LEVEL    VCD_MIN_PERF_LEVEL
+#define RESTRK_1080P_720P_PERF_LEVEL   108000
+#define RESTRK_1080P_1080P_PERF_LEVEL  244800
+
+#define RESTRK_1080P_MIN_PERF_LEVEL RESTRK_1080P_VGA_PERF_LEVEL
+#define RESTRK_1080P_MAX_PERF_LEVEL RESTRK_1080P_1080P_PERF_LEVEL
+#define RESTRK_1080P_TURBO_PERF_LEVEL (RESTRK_1080P_MAX_PERF_LEVEL + 1)
+
 struct res_trk_context {
 	struct device *device;
 	u32 irq_num;
@@ -67,4 +75,8 @@
 #define VCDRES_MSG_ERROR(xx_fmt...)	printk(KERN_ERR "\n err: " xx_fmt)
 #define VCDRES_MSG_FATAL(xx_fmt...)	printk(KERN_ERR "\n<FATAL> " xx_fmt)
 
+#ifdef CONFIG_MSM_BUS_SCALING
+int res_trk_update_bus_perf_level(struct vcd_dev_ctxt *dev_ctxt,
+				u32 perf_level);
+#endif
 #endif
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.c msm/vidc/720p/ddl/vcd_ddl_utils.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.c	2012-07-31 21:49:36.942617917 -0700
+++ msm/vidc/720p/ddl/vcd_ddl_utils.c	2012-08-14 12:32:39.589339477 -0700
@@ -231,3 +231,12 @@
 	proc_time[index].ddl_ttotal = 0;
 	proc_time[index].ddl_count = 0;
 }
+int ddl_get_core_decode_proc_time(u32 *ddl_handle)
+{
+	return 0;
+}
+
+void ddl_reset_avg_dec_time(u32 *ddl_handle)
+{
+	return;
+}
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.h msm/vidc/720p/ddl/vcd_ddl_utils.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/720p/ddl/vcd_ddl_utils.h	2012-07-31 21:49:36.942617917 -0700
+++ msm/vidc/720p/ddl/vcd_ddl_utils.h	2012-08-14 12:32:39.589339477 -0700
@@ -46,6 +46,10 @@
 
 void ddl_reset_core_time_variables(u32 index);
 
+int ddl_get_core_decode_proc_time(u32 *ddl_handle);
+
+void ddl_reset_avg_dec_time(u32 *ddl_handle);
+
 #define DDL_ASSERT(x)
 #define DDL_MEMSET(src, value, len) memset((src), (value), (len))
 #define DDL_MEMCPY(dest, src, len)  memcpy((dest), (src), (len))
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker_api.h msm/vidc/720p/resource_tracker/vcd_res_tracker_api.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker_api.h	2012-08-08 09:32:42.878525949 -0700
+++ msm/vidc/720p/resource_tracker/vcd_res_tracker_api.h	2012-08-14 12:32:39.590339477 -0700
@@ -39,4 +39,5 @@
 void res_trk_secure_set(void);
 void res_trk_secure_unset(void);
 u32 get_res_trk_perf_level(enum vcd_perf_level perf_level);
+u32 res_trk_estimate_perf_level(u32 pn_perf_lvl);
 #endif
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker.c msm/vidc/720p/resource_tracker/vcd_res_tracker.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/720p/resource_tracker/vcd_res_tracker.c	2012-08-08 09:32:42.878525949 -0700
+++ msm/vidc/720p/resource_tracker/vcd_res_tracker.c	2012-08-14 12:32:39.590339477 -0700
@@ -92,17 +92,17 @@
 			goto bail_out;
 		}
 
-		if (clk_enable(resource_context.pclk)) {
+		if (clk_prepare_enable(resource_context.pclk)) {
 			VCDRES_MSG_ERROR("vidc pclk Enable failed\n");
 			goto bail_out;
 		}
 
-		if (clk_enable(resource_context.hclk)) {
+		if (clk_prepare_enable(resource_context.hclk)) {
 			VCDRES_MSG_ERROR("vidc hclk Enable failed\n");
 			goto disable_pclk;
 		}
 
-		if (clk_enable(resource_context.hclk_div2)) {
+		if (clk_prepare_enable(resource_context.hclk_div2)) {
 			VCDRES_MSG_ERROR("vidc hclk_div2 Enable failed\n");
 			goto disable_hclk;
 		}
@@ -120,9 +120,9 @@
 	}
 	msleep(20);
 
-	clk_disable(resource_context.pclk);
-	clk_disable(resource_context.hclk);
-	clk_disable(resource_context.hclk_div2);
+	clk_disable_unprepare(resource_context.pclk);
+	clk_disable_unprepare(resource_context.hclk);
+	clk_disable_unprepare(resource_context.hclk_div2);
 
 	clk_put(resource_context.hclk_div2);
 	clk_put(resource_context.hclk);
@@ -144,9 +144,9 @@
 	return true;
 
 disable_hclk:
-	clk_disable(resource_context.hclk);
+	clk_disable_unprepare(resource_context.hclk);
 disable_pclk:
-	clk_disable(resource_context.pclk);
+	clk_disable_unprepare(resource_context.pclk);
 bail_out:
 	if (resource_context.pclk) {
 		clk_put(resource_context.pclk);
@@ -175,7 +175,7 @@
 
 		VCDRES_MSG_LOW("%s(): Enabling the clocks ...\n", __func__);
 
-		if (clk_enable(resource_context.pclk)) {
+		if (clk_prepare_enable(resource_context.pclk)) {
 			VCDRES_MSG_ERROR("vidc pclk Enable failed\n");
 
 			clk_put(resource_context.hclk);
@@ -184,7 +184,7 @@
 			return false;
 		}
 
-		if (clk_enable(resource_context.hclk)) {
+		if (clk_prepare_enable(resource_context.hclk)) {
 			VCDRES_MSG_ERROR("vidc  hclk Enable failed\n");
 			clk_put(resource_context.pclk);
 			clk_put(resource_context.hclk_div2);
@@ -192,7 +192,7 @@
 			return false;
 		}
 
-		if (clk_enable(resource_context.hclk_div2)) {
+		if (clk_prepare_enable(resource_context.hclk_div2)) {
 			VCDRES_MSG_ERROR("vidc  hclk Enable failed\n");
 			clk_put(resource_context.hclk);
 			clk_put(resource_context.pclk);
@@ -253,9 +253,9 @@
 	VCDRES_MSG_LOW("%s(): Disabling the clocks ...\n", __func__);
 
 	resource_context.clock_enabled = 0;
-	clk_disable(resource_context.hclk);
-	clk_disable(resource_context.hclk_div2);
-	clk_disable(resource_context.pclk);
+	clk_disable_unprepare(resource_context.hclk);
+	clk_disable_unprepare(resource_context.hclk_div2);
+	clk_disable_unprepare(resource_context.pclk);
 	mutex_unlock(&resource_context.lock);
 
 	return true;
@@ -311,17 +311,17 @@
 			goto release_all_clks;
 		}
 
-		if (clk_enable(resource_context.pclk)) {
+		if (clk_prepare_enable(resource_context.pclk)) {
 			VCDRES_MSG_ERROR("vidc pclk Enable failed\n");
 			goto release_all_clks;
 		}
 
-		if (clk_enable(resource_context.hclk)) {
+		if (clk_prepare_enable(resource_context.hclk)) {
 			VCDRES_MSG_ERROR("vidc hclk Enable failed\n");
 			goto disable_pclk;
 		}
 
-		if (clk_enable(resource_context.hclk_div2)) {
+		if (clk_prepare_enable(resource_context.hclk_div2)) {
 			VCDRES_MSG_ERROR("vidc hclk_div2 Enable failed\n");
 			goto disable_hclk_pclk;
 		}
@@ -333,9 +333,9 @@
 		}
 		msleep(20);
 
-		clk_disable(resource_context.pclk);
-		clk_disable(resource_context.hclk);
-		clk_disable(resource_context.hclk_div2);
+		clk_disable_unprepare(resource_context.pclk);
+		clk_disable_unprepare(resource_context.hclk);
+		clk_disable_unprepare(resource_context.hclk_div2);
 
 	}
 	resource_context.rail_enabled = 1;
@@ -343,11 +343,11 @@
 	return true;
 
 disable_and_release_all_clks:
-	clk_disable(resource_context.hclk_div2);
+	clk_disable_unprepare(resource_context.hclk_div2);
 disable_hclk_pclk:
-	clk_disable(resource_context.hclk);
+	clk_disable_unprepare(resource_context.hclk);
 disable_pclk:
-	clk_disable(resource_context.pclk);
+	clk_disable_unprepare(resource_context.pclk);
 release_all_clks:
 	clk_put(resource_context.hclk_div2);
 	resource_context.hclk_div2 = NULL;
@@ -412,7 +412,7 @@
 		VCDRES_MSG_ERROR("Request AXI bus QOS fails.");
 		return false;
 	}
-	clk_enable(ebi1_clk);
+	clk_prepare_enable(ebi1_clk);
 }
 #endif
 
@@ -427,7 +427,7 @@
 #ifdef AXI_CLK_SCALING
 	VCDRES_MSG_MED("\n res_trk_power_down()::"
 		"Calling AXI remove requirement\n");
-	clk_disable(ebi1_clk);
+	clk_disable_unprepare(ebi1_clk);
 	clk_put(ebi1_clk);
 #endif
 	VCDRES_MSG_MED("\n res_trk_power_down():: Calling "
@@ -764,3 +764,8 @@
 	else
 		return 0;
 }
+u32 res_trk_estimate_perf_level(u32 pn_perf_lvl)
+{
+	return 0;
+}
+
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/dec/vdec.c msm/vidc/common/dec/vdec.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/dec/vdec.c	2012-08-08 09:32:42.879525949 -0700
+++ msm/vidc/common/dec/vdec.c	2012-08-14 12:32:39.590339477 -0700
@@ -347,11 +347,16 @@
 		ion_flag = vidc_get_fd_info(client_ctx, BUFFER_TYPE_OUTPUT,
 				pmem_fd, kernel_vaddr, buffer_index,
 				&buff_handle);
-		if (ion_flag == CACHED) {
+		if (ion_flag == CACHED && buff_handle) {
+			DBG("%s: Cache invalidate: vaddr (%p), "\
+				"size %u\n", __func__,
+				(void *)kernel_vaddr,
+				vcd_frame_data->alloc_len);
 			msm_ion_do_cache_op(client_ctx->user_ion_client,
 					buff_handle,
 					(unsigned long *) kernel_vaddr,
-					(unsigned long)vcd_frame_data->data_len,
+					(unsigned long)vcd_frame_data->\
+					alloc_len,
 					ION_IOC_INV_CACHES);
 		}
 	}
@@ -636,6 +641,26 @@
 		return true;
 }
 
+static u32 vid_dec_set_turbo_clk(struct video_client_ctx *client_ctx)
+{
+	struct vcd_property_hdr vcd_property_hdr;
+	u32 vcd_status = VCD_ERR_FAIL;
+	u32 dummy = 0;
+
+	if (!client_ctx)
+		return false;
+	vcd_property_hdr.prop_id = VCD_I_SET_TURBO_CLK;
+	vcd_property_hdr.sz = sizeof(struct vcd_property_frame_size);
+
+	vcd_status = vcd_set_property(client_ctx->vcd_handle,
+				      &vcd_property_hdr, &dummy);
+
+	if (vcd_status)
+		return false;
+	else
+		return true;
+}
+
 static u32 vid_dec_get_frame_resolution(struct video_client_ctx *client_ctx,
 					struct vdec_picsize *video_resoultion)
 {
@@ -866,10 +891,10 @@
 		vcd_h264_mv_buffer->client_data = (void *) mapped_buffer;
 		vcd_h264_mv_buffer->dev_addr = (u8 *)mapped_buffer->iova[0];
 	} else {
-		client_ctx->h264_mv_ion_handle = ion_import_fd(
+		client_ctx->h264_mv_ion_handle = ion_import_dma_buf(
 					client_ctx->user_ion_client,
 					vcd_h264_mv_buffer->pmem_fd);
-		if (!client_ctx->h264_mv_ion_handle) {
+		if (IS_ERR_OR_NULL(client_ctx->h264_mv_ion_handle)) {
 			ERR("%s(): get_ION_handle failed\n", __func__);
 			goto import_ion_error;
 		}
@@ -932,12 +957,16 @@
 	else
 		return true;
 ion_map_error:
-	if (vcd_h264_mv_buffer->kernel_virtual_addr)
+	if (vcd_h264_mv_buffer->kernel_virtual_addr) {
 		ion_unmap_kernel(client_ctx->user_ion_client,
 				client_ctx->h264_mv_ion_handle);
-	if (client_ctx->h264_mv_ion_handle)
+		vcd_h264_mv_buffer->kernel_virtual_addr = NULL;
+	}
+	if (!IS_ERR_OR_NULL(client_ctx->h264_mv_ion_handle)) {
 		ion_free(client_ctx->user_ion_client,
 			client_ctx->h264_mv_ion_handle);
+		 client_ctx->h264_mv_ion_handle = NULL;
+	}
 import_ion_error:
 	return false;
 }
@@ -1006,7 +1035,7 @@
 	vcd_status = vcd_set_property(client_ctx->vcd_handle,
 				      &vcd_property_hdr, &h264_mv_buffer_size);
 
-	if (client_ctx->h264_mv_ion_handle != NULL) {
+	if (!IS_ERR_OR_NULL(client_ctx->h264_mv_ion_handle)) {
 		ion_unmap_kernel(client_ctx->user_ion_client,
 					client_ctx->h264_mv_ion_handle);
 		if (!res_trk_check_for_sec_session()) {
@@ -1017,6 +1046,7 @@
 		}
 		ion_free(client_ctx->user_ion_client,
 					client_ctx->h264_mv_ion_handle);
+		 client_ctx->h264_mv_ion_handle = NULL;
 	}
 
 	if (vcd_status)
@@ -1265,7 +1295,7 @@
 						kernel_vaddr,
 						buffer_index,
 						&buff_handle);
-			if (ion_flag == CACHED) {
+			if (ion_flag == CACHED && buff_handle) {
 				msm_ion_do_cache_op(client_ctx->user_ion_client,
 				buff_handle,
 				(unsigned long *)kernel_vaddr,
@@ -1677,6 +1707,11 @@
 		}
 		break;
 	}
+	case VDEC_IOCTL_SET_PERF_CLK:
+	{
+		vid_dec_set_turbo_clk(client_ctx);
+		break;
+	}
 	case VDEC_IOCTL_FILL_OUTPUT_BUFFER:
 	{
 		struct vdec_fillbuffer_cmd fill_buffer_cmd;
@@ -1755,7 +1790,7 @@
 			}
 			put_pmem_file(pmem_file);
 		} else {
-			client_ctx->seq_hdr_ion_handle = ion_import_fd(
+			client_ctx->seq_hdr_ion_handle = ion_import_dma_buf(
 				client_ctx->user_ion_client,
 				seq_header.pmem_fd);
 			if (!client_ctx->seq_hdr_ion_handle) {
@@ -2175,7 +2210,6 @@
 static int vid_dec_release_secure(struct inode *inode, struct file *file)
 {
 	struct video_client_ctx *client_ctx = file->private_data;
-	enum buffer_dir dir_buffer;
 
 	INFO("msm_vidc_dec: Inside %s()", __func__);
 	vidc_cleanup_addr_table(client_ctx, BUFFER_TYPE_OUTPUT);
@@ -2192,7 +2226,6 @@
 static int vid_dec_release(struct inode *inode, struct file *file)
 {
 	struct video_client_ctx *client_ctx = file->private_data;
-	enum buffer_dir dir_buffer;
 
 	INFO("msm_vidc_dec: Inside %s()", __func__);
 	vidc_cleanup_addr_table(client_ctx, BUFFER_TYPE_OUTPUT);
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/enc/venc.c msm/vidc/common/enc/venc.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/enc/venc.c	2012-08-08 09:32:42.879525949 -0700
+++ msm/vidc/common/enc/venc.c	2012-08-14 12:32:39.605339476 -0700
@@ -252,6 +252,8 @@
 		/* Timestamp pass-through from input frame */
 		venc_msg->venc_msg_info.buf.timestamp =
 			vcd_frame_data->time_stamp;
+		venc_msg->venc_msg_info.buf.sz =
+			vcd_frame_data->alloc_len;
 
 		/* Decoded picture width and height */
 		venc_msg->venc_msg_info.msgdata_size =
@@ -265,11 +267,11 @@
 		ion_flag = vidc_get_fd_info(client_ctx, BUFFER_TYPE_OUTPUT,
 					pmem_fd, kernel_vaddr, buffer_index,
 					&buff_handle);
-		if (ion_flag == CACHED) {
+		if (ion_flag == CACHED && buff_handle) {
 			msm_ion_do_cache_op(client_ctx->user_ion_client,
 				buff_handle,
 				(unsigned long *) kernel_vaddr,
-				(unsigned long)venc_msg->venc_msg_info.buf.len,
+				(unsigned long)venc_msg->venc_msg_info.buf.sz,
 				ION_IOC_CLEAN_INV_CACHES);
 		}
 	}
@@ -1314,26 +1316,28 @@
 	}
 	case VEN_IOCTL_GET_SEQUENCE_HDR:
 	{
-		struct venc_seqheader seq_header, seq_header_user;
+		struct venc_seqheader seq_header;
 		if (copy_from_user(&venc_msg, arg, sizeof(venc_msg)))
 			return -EFAULT;
 
-		DBG("VEN_IOCTL_GET_SEQUENCE_HDR\n");
-		if (copy_from_user(&seq_header_user, venc_msg.in,
-			sizeof(seq_header_user)))
+		if (copy_from_user(&seq_header, venc_msg.in,
+			sizeof(seq_header)))
 			return -EFAULT;
-		seq_header.hdrbufptr = NULL;
+
+		DBG("VEN_IOCTL_GET_SEQUENCE_HDR\n");
 		result = vid_enc_get_sequence_header(client_ctx,
 				&seq_header);
-		if (result && ((copy_to_user(seq_header_user.hdrbufptr,
-			seq_header.hdrbufptr, seq_header.hdrlen)) ||
-			(copy_to_user(&seq_header_user.hdrlen,
-			&seq_header.hdrlen,
-			sizeof(seq_header.hdrlen)))))
-				result = false;
-		kfree(seq_header.hdrbufptr);
-		if (!result)
+		if (!result) {
+			ERR("get sequence header failed\n");
 			return -EIO;
+		}
+		DBG("seq_header: buf=%x, sz=%d, hdrlen=%d\n",
+			(int)seq_header.hdrbufptr,
+			(int)seq_header.bufsize,
+			(int)seq_header.hdrlen);
+		if (copy_to_user(venc_msg.out, &seq_header,
+			sizeof(seq_header)))
+			return -EFAULT;
 		break;
 	}
 	case VEN_IOCTL_CMD_REQUEST_IFRAME:
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/enc/venc_internal.c msm/vidc/common/enc/venc_internal.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/enc/venc_internal.c	2012-08-08 09:32:42.879525949 -0700
+++ msm/vidc/common/enc/venc_internal.c	2012-08-14 12:32:39.621339475 -0700
@@ -893,23 +893,17 @@
 	u32 vcd_status = VCD_ERR_FAIL;
 	u32 status = true;
 
-	if (!client_ctx ||
-			!seq_header || !seq_header->bufsize)
+	if (!client_ctx || !seq_header || !seq_header->bufsize)
 		return false;
 
 	vcd_property_hdr.prop_id = VCD_I_SEQ_HEADER;
-	vcd_property_hdr.sz =
-		sizeof(struct vcd_sequence_hdr);
-
-	hdr.sequence_header =
-		kzalloc(seq_header->bufsize, GFP_KERNEL);
-	seq_header->hdrbufptr = hdr.sequence_header;
+	vcd_property_hdr.sz = sizeof(struct vcd_sequence_hdr);
 
-	if (!hdr.sequence_header)
-		return false;
+	hdr.sequence_header = seq_header->hdrbufptr;
 	hdr.sequence_header_len = seq_header->bufsize;
 	vcd_status = vcd_get_property(client_ctx->vcd_handle,
 			&vcd_property_hdr, &hdr);
+	seq_header->hdrlen = hdr.sequence_header_len;
 
 	if (vcd_status) {
 		ERR("%s(): Get VCD_I_SEQ_HEADER Failed\n",
@@ -1694,7 +1688,7 @@
 				&buff_handle);
 
 		if (vcd_input_buffer.data_len > 0) {
-			if (ion_flag == CACHED) {
+			if (ion_flag == CACHED && buff_handle) {
 				msm_ion_do_cache_op(
 				client_ctx->user_ion_client,
 				buff_handle,
@@ -1729,6 +1723,7 @@
 	struct file *file;
 	s32 buffer_index = -1;
 	u32 vcd_status = VCD_ERR_FAIL;
+	struct ion_handle *buff_handle = NULL;
 
 	struct vcd_frame_data vcd_frame;
 
@@ -1744,9 +1739,13 @@
 
 		memset((void *)&vcd_frame, 0,
 					 sizeof(struct vcd_frame_data));
+		vidc_get_fd_info(client_ctx, BUFFER_TYPE_OUTPUT,
+				pmem_fd, kernel_vaddr, buffer_index,
+				&buff_handle);
 		vcd_frame.virtual = (u8 *) kernel_vaddr;
 		vcd_frame.frm_clnt_data = (u32) output_frame_info->clientdata;
 		vcd_frame.alloc_len = output_frame_info->sz;
+		vcd_frame.buff_ion_handle = buff_handle;
 
 		vcd_status = vcd_fill_output_buffer(client_ctx->vcd_handle,
 								&vcd_frame);
@@ -1822,7 +1821,7 @@
 			control->client_data = (void *) mapped_buffer;
 			control->dev_addr = (u8 *)mapped_buffer->iova[0];
 	} else {
-		client_ctx->recon_buffer_ion_handle[i] = ion_import_fd(
+		client_ctx->recon_buffer_ion_handle[i] = ion_import_dma_buf(
 				client_ctx->user_ion_client, control->pmem_fd);
 		if (IS_ERR_OR_NULL(client_ctx->recon_buffer_ion_handle[i])) {
 			ERR("%s(): get_ION_handle failed\n", __func__);
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/init/vidc_init.c msm/vidc/common/init/vidc_init.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/init/vidc_init.c	2012-08-08 09:32:42.880525949 -0700
+++ msm/vidc/common/init/vidc_init.c	2012-08-14 12:32:39.621339475 -0700
@@ -388,10 +388,13 @@
 	else
 		buf_addr_table = client_ctx->output_buf_addr_table;
 	if (buf_addr_table[index].pmem_fd == pmem_fd) {
-		if (buf_addr_table[index].kernel_vaddr == kvaddr)
+		if (buf_addr_table[index].kernel_vaddr == kvaddr) {
 			rc = buf_addr_table[index].buff_ion_flag;
 			*buff_handle = buf_addr_table[index].buff_ion_handle;
-	}
+		} else
+			*buff_handle = NULL;
+	} else
+		*buff_handle = NULL;
 	return rc;
 }
 EXPORT_SYMBOL(vidc_get_fd_info);
@@ -624,7 +627,7 @@
 			buf_addr_table[*num_of_buffers].dev_addr =
 				mapped_buffer->iova[0];
 		} else {
-			buff_ion_handle = ion_import_fd(
+			buff_ion_handle = ion_import_dma_buf(
 				client_ctx->user_ion_client, pmem_fd);
 			if (IS_ERR_OR_NULL(buff_ion_handle)) {
 				ERR("%s(): get_ION_handle failed\n",
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/init/vidc_init_internal.h msm/vidc/common/init/vidc_init_internal.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/init/vidc_init_internal.h	2012-07-16 10:04:32.227489769 -0700
+++ msm/vidc/common/init/vidc_init_internal.h	2012-05-19 18:38:37.654909376 -0700
@@ -28,7 +28,7 @@
 	struct device *device;
 	resource_size_t phys_base;
 	void __iomem *virt_base;
-	int irq;
+	unsigned int irq;
 	unsigned int ref_count;
 	unsigned int firmware_refcount;
 	unsigned int get_firmware;
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_api.c msm/vidc/common/vcd/vcd_api.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_api.c	2012-07-16 10:04:32.227489769 -0700
+++ msm/vidc/common/vcd/vcd_api.c	2012-08-14 12:32:39.622339475 -0700
@@ -11,6 +11,7 @@
  *
  */
 
+#include <linux/export.h>
 #include <media/msm/vidc_type.h>
 #include "vcd.h"
 
@@ -110,7 +111,8 @@
 	return count;
 }
 
-static int is_session_invalid(u32 decoding, u32 flags) {
+static int is_session_invalid(u32 decoding, u32 flags)
+{
 	int is_secure;
 	struct client_security_info sec_info;
 	int client_count = 0;
@@ -159,7 +161,7 @@
 	struct vcd_drv_ctxt *drv_ctxt;
 	struct vcd_clnt_ctxt *cctxt;
 	int is_secure = (flags & VCD_CP_SESSION) ? 1:0;
-	VCD_MSG_MED("vcd_open");
+	VCD_MSG_MED("vcd_open:");
 
 	if (!callback) {
 		VCD_MSG_ERROR("Bad parameters");
@@ -967,7 +969,6 @@
 }
 EXPORT_SYMBOL(vcd_get_num_of_clients);
 
-
 u32 vcd_get_ion_status(void)
 {
 	return res_trk_get_enable_ion();
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_client_sm.c msm/vidc/common/vcd/vcd_client_sm.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_client_sm.c	2012-08-08 09:32:42.909525946 -0700
+++ msm/vidc/common/vcd/vcd_client_sm.c	2012-08-14 12:32:39.622339475 -0700
@@ -96,8 +96,8 @@
 		 cctxt->in_buf_pool.validated != cctxt->in_buf_pool.count) ||
 	    cctxt->out_buf_pool.validated !=
 	    cctxt->out_buf_pool.count) {
-		VCD_MSG_ERROR("Buffer pool is not completely setup yet");
-		return VCD_ERR_BAD_STATE;
+		VCD_MSG_HIGH("%s: Buffer pool is not completely setup yet",
+			__func__);
 	}
 
 	rc = vcd_sched_add_client(cctxt);
@@ -541,6 +541,12 @@
 			}
 			break;
 		}
+	case VCD_I_SET_TURBO_CLK:
+	{
+		if (cctxt->sched_clnt_hdl)
+			rc = vcd_set_perf_turbo_level(cctxt);
+		break;
+	}
 	case VCD_I_INTRA_PERIOD:
 	   {
 		  struct vcd_property_i_period *iperiod =
@@ -548,11 +554,15 @@
 		  cctxt->bframe = iperiod->b_frames;
 		  break;
 	   }
+	case VCD_REQ_PERF_LEVEL:
+		rc = vcd_req_perf_level(cctxt,
+				(struct vcd_property_perf_level *)prop_val);
+		break;
 	case VCD_I_VOP_TIMING_CONSTANT_DELTA:
 	   {
 		   struct vcd_property_vop_timing_constant_delta *delta =
-			   (struct vcd_property_vop_timing_constant_delta *)
 			   prop_val;
+
 		   if (delta->constant_delta > 0) {
 			cctxt->time_frame_delta = delta->constant_delta;
 			rc = VCD_S_SUCCESS;
@@ -562,10 +572,6 @@
 		   }
            break;
 	   }
-	case VCD_REQ_PERF_LEVEL:
-		rc = vcd_req_perf_level(cctxt,
-			(struct vcd_property_perf_level *)prop_val);
-		break;
 	default:
 		{
 			break;
@@ -1613,12 +1619,7 @@
 {
 	struct vcd_clnt_state_ctxt *state_ctxt;
 
-	if (!cctxt) {
-		VCD_MSG_ERROR("cctxt error");
-		return;
-	}
-
-	if (to_state >= VCD_CLIENT_STATE_MAX) {
+	if (!cctxt || to_state >= VCD_CLIENT_STATE_MAX) {
 		VCD_MSG_ERROR("Bad parameters. cctxt=%p, to_state=%d",
 			      cctxt, to_state);
 	}
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_core.h msm/vidc/common/vcd/vcd_core.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_core.h	2012-08-08 09:32:42.909525946 -0700
+++ msm/vidc/common/vcd/vcd_core.h	2012-08-14 12:32:39.623339475 -0700
@@ -37,6 +37,7 @@
 
 #define VCD_TIMESTAMP_RESOLUTION             1000000
 #define VCD_DEC_INITIAL_FRAME_RATE           30
+#define VCD_MAXPERF_FPS_THRESHOLD_X_1000     (59*1000)
 
 #define VCD_FIRST_IP_RCVD                    0x00000004
 #define VCD_FIRST_OP_RCVD                    0x00000008
@@ -146,7 +147,7 @@
 	u32 reqd_perf_lvl;
 	u32 curr_perf_lvl;
 	u32 set_perf_lvl_pending;
-
+	u32 turbo_mode_set;
 };
 
 struct vcd_clnt_status {
@@ -211,8 +212,8 @@
 	u32 vcd_enable_ion;
 	struct vcd_clnt_ctxt *next;
 	u32 meta_mode;
-	int secure;
 	int perf_set_by_client;
+	int secure;
 };
 
 #define VCD_BUFFERPOOL_INUSE_DECREMENT(val) \
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c msm/vidc/common/vcd/vcd_device_sm.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_device_sm.c	2012-08-08 09:32:42.915525947 -0700
+++ msm/vidc/common/vcd/vcd_device_sm.c	2012-08-14 12:32:39.623339475 -0700
@@ -33,12 +33,7 @@
 {
 	struct vcd_dev_state_ctxt *state_ctxt;
 
-	if (!drv_ctxt) {
-		VCD_MSG_ERROR("Bad parameters. drv_ctxt error");
-		return;
-	}
-
-	if (to_state >= VCD_DEVICE_STATE_MAX) {
+	if (!drv_ctxt || to_state >= VCD_DEVICE_STATE_MAX) {
 		VCD_MSG_ERROR("Bad parameters. drv_ctxt=%p, to_state=%d",
 				  drv_ctxt, to_state);
 	}
@@ -224,6 +219,7 @@
 						   VCD_DEVICE_STATE_INITING,
 						   ev_code);
 	}
+	dev_ctxt->turbo_mode_set = 0;
 
 	return rc;
 }
@@ -763,6 +759,7 @@
 	client = dev_ctxt->cctxt_list_head;
 	dev_ctxt->cctxt_list_head = cctxt;
 	cctxt->next = client;
+	dev_ctxt->turbo_mode_set = 0;
 
 	*clnt_cctxt = cctxt;
 
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd.h msm/vidc/common/vcd/vcd.h
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd.h	2012-08-08 09:32:42.880525949 -0700
+++ msm/vidc/common/vcd/vcd.h	2012-08-14 12:32:39.622339475 -0700
@@ -395,4 +395,7 @@
 
 u32 vcd_set_num_slices(struct vcd_clnt_ctxt *cctxt);
 
+u32 vcd_update_decoder_perf_level(struct vcd_dev_ctxt *dev_ctxt, u32 perf_lvl);
+
+u32 vcd_set_perf_turbo_level(struct vcd_clnt_ctxt *cctxt);
 #endif
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_power_sm.c msm/vidc/common/vcd/vcd_power_sm.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_power_sm.c	2012-07-31 21:49:36.944617917 -0700
+++ msm/vidc/common/vcd/vcd_power_sm.c	2012-08-14 12:32:39.623339475 -0700
@@ -15,6 +15,7 @@
 #include "vcd_power_sm.h"
 #include "vcd_core.h"
 #include "vcd.h"
+#include "vcd_res_tracker.h"
 
 u32 vcd_power_event(
 	struct vcd_dev_ctxt *dev_ctxt,
@@ -281,7 +282,6 @@
 u32 vcd_set_perf_level(struct vcd_dev_ctxt *dev_ctxt, u32 perf_lvl)
 {
 	u32 rc = VCD_S_SUCCESS;
-	pr_err("NOTE: Inside vcd_set_perf_level, level to : %d\n", perf_lvl);
 	if (!vcd_core_is_busy(dev_ctxt)) {
 		if (res_trk_set_perf_level(perf_lvl,
 			&dev_ctxt->curr_perf_lvl, dev_ctxt)) {
@@ -298,6 +298,40 @@
 	return rc;
 }
 
+u32 vcd_set_perf_turbo_level(struct vcd_clnt_ctxt *cctxt)
+{
+	u32 rc = VCD_S_SUCCESS;
+#ifdef CONFIG_MSM_BUS_SCALING
+	struct vcd_dev_ctxt *dev_ctxt = cctxt->dev_ctxt;
+	pr_err("\n Setting Turbo mode !!");
+
+	if (res_trk_update_bus_perf_level(dev_ctxt,
+			RESTRK_1080P_TURBO_PERF_LEVEL) < 0) {
+		pr_err("\n %s(): update buf perf level failed\n",
+			__func__);
+		return false;
+	}
+	dev_ctxt->curr_perf_lvl = RESTRK_1080P_TURBO_PERF_LEVEL;
+	vcd_update_decoder_perf_level(dev_ctxt, RESTRK_1080P_TURBO_PERF_LEVEL);
+#endif
+	return rc;
+}
+
+u32 vcd_update_decoder_perf_level(struct vcd_dev_ctxt *dev_ctxt, u32 perf_lvl)
+{
+	u32 rc = VCD_S_SUCCESS;
+
+	if (res_trk_set_perf_level(perf_lvl,
+		&dev_ctxt->curr_perf_lvl, dev_ctxt)) {
+		dev_ctxt->set_perf_lvl_pending = false;
+	} else {
+		rc = VCD_ERR_FAIL;
+		dev_ctxt->set_perf_lvl_pending = true;
+	}
+
+	return rc;
+}
+
 u32 vcd_update_clnt_perf_lvl(
 	struct vcd_clnt_ctxt *cctxt,
      struct vcd_property_frame_rate *fps, u32 frm_p_units)
@@ -307,6 +341,18 @@
 	u32 new_perf_lvl;
 	new_perf_lvl = frm_p_units *\
 		(fps->fps_numerator / fps->fps_denominator);
+
+	if ((fps->fps_numerator * 1000) / fps->fps_denominator
+		 > VCD_MAXPERF_FPS_THRESHOLD_X_1000) {
+		u32 max_perf_level = 0;
+		if (res_trk_get_max_perf_level(&max_perf_level)) {
+			new_perf_lvl = max_perf_level;
+			VCD_MSG_HIGH("Using max perf level(%d) for >60fps\n",
+						 new_perf_lvl);
+		} else {
+			VCD_MSG_ERROR("Failed to get max perf level\n");
+		}
+	}
 	if (cctxt->status.req_perf_lvl) {
 		dev_ctxt->reqd_perf_lvl =
 		    dev_ctxt->reqd_perf_lvl - cctxt->reqd_perf_lvl +
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_scheduler.c msm/vidc/common/vcd/vcd_scheduler.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_scheduler.c	2012-07-27 15:43:44.660751143 -0700
+++ msm/vidc/common/vcd/vcd_scheduler.c	2012-05-19 18:38:37.655909376 -0700
@@ -88,8 +88,6 @@
 			prop_hdr.sz = sizeof(cctxt->frm_p_units);
 			rc = ddl_get_property(cctxt->ddl_handle, &prop_hdr,
 						  &cctxt->frm_p_units);
-			if (VCD_FAILED(rc))
-				kfree(sched_cctxt);
 			VCD_FAILED_RETURN(rc,
 				"Failed: Get DDL_I_FRAME_PROC_UNITS");
 			if (cctxt->decoding) {
@@ -101,8 +99,6 @@
 				prop_hdr.sz = sizeof(cctxt->frm_rate);
 				rc = ddl_get_property(cctxt->ddl_handle,
 						&prop_hdr, &cctxt->frm_rate);
-				if (VCD_FAILED(rc))
-					kfree(sched_cctxt);
 				VCD_FAILED_RETURN(rc,
 					"Failed: Get VCD_I_FRAME_RATE");
 			}
diff -r --unified -w /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_sub.c msm/vidc/common/vcd/vcd_sub.c
--- /home/shade/dev/cm/10/kernel/samsung/d2/drivers/video/msm/vidc/common/vcd/vcd_sub.c	2012-08-08 09:32:42.916525947 -0700
+++ msm/vidc/common/vcd/vcd_sub.c	2012-08-14 12:32:39.623339475 -0700
@@ -20,6 +20,7 @@
 #define MAX(x, y) (((x) > (y)) ? (x) : (y))
 #define MAP_TABLE_SZ 64
 #define VCD_ENC_MAX_OUTBFRS_PER_FRAME 8
+#define MAX_DEC_TIME 33
 
 struct vcd_msm_map_buffer {
 	phys_addr_t phy_addr;
@@ -893,9 +894,6 @@
 	u32 i;
 	u32 found = false;
 
-	if(pool->entries==NULL)
-		return NULL;
-
 	for (i = 0; i <= pool->count && !found; i++) {
 		if (pool->entries[i].virtual == addr)
 			found = true;
@@ -1508,6 +1506,8 @@
 	struct vcd_buffer_entry *op_buf_entry = NULL;
 	u32 rc = VCD_S_SUCCESS;
 	u32 evcode = 0;
+	u32 perf_level = 0;
+	int decodeTime = 0;
 	struct ddl_frame_data_tag ddl_ip_frm;
 	struct ddl_frame_data_tag *ddl_op_frm;
 	u32 out_buf_cnt = 0;
@@ -1523,6 +1523,16 @@
 	ip_frm_entry->ip_frm_tag = (u32) transc;
 	memset(&ddl_ip_frm, 0, sizeof(ddl_ip_frm));
 	if (cctxt->decoding) {
+		decodeTime = ddl_get_core_decode_proc_time(cctxt->ddl_handle);
+		if (decodeTime > MAX_DEC_TIME) {
+			if (res_trk_get_curr_perf_level(&perf_level)) {
+				vcd_update_decoder_perf_level(dev_ctxt,
+				   res_trk_estimate_perf_level(perf_level));
+				ddl_reset_avg_dec_time(cctxt->ddl_handle);
+			} else
+				VCD_MSG_ERROR("%s(): retrieve curr_perf_level"
+						"returned FALSE\n", __func__);
+		}
 		evcode = CLIENT_STATE_EVENT_NUMBER(decode_frame);
 		ddl_ip_frm.vcd_frm = *ip_frm_entry;
 		rc = ddl_decode_frame(cctxt->ddl_handle, &ddl_ip_frm,
@@ -2071,8 +2081,8 @@
 		rc = VCD_ERR_CLIENT_FATAL;
 
 	if (VCD_FAILED(rc)) {
-		VCD_MSG_FATAL(
-			"vcd_validate_io_done_pyld: invalid transaction");
+		VCD_MSG_FATAL("vcd_validate_io_done_pyld: "\
+			"invalid transaction 0x%x", (u32)transc);
 	} else if (!frame->vcd_frm.virtual &&
 		status != VCD_ERR_INTRLCD_FIELD_DROP)
 		rc = VCD_ERR_BAD_POINTER;
@@ -3421,7 +3431,8 @@
 	struct vcd_property_slice_delivery_info slice_delivery_info;
 	u32 rc = VCD_S_SUCCESS;
 	prop_hdr.prop_id = VCD_I_SLICE_DELIVERY_MODE;
-	prop_hdr.sz = sizeof(struct vcd_property_slice_delivery_info);
+	prop_hdr.sz =
+		sizeof(struct vcd_property_slice_delivery_info);
 	rc = ddl_get_property(cctxt->ddl_handle, &prop_hdr,
 				&slice_delivery_info);
 	VCD_FAILED_RETURN(rc, "Failed: Get VCD_I_SLICE_DELIVERY_MODE");
